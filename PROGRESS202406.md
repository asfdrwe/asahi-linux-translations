[Vulkan 1.3 on the M1 in 1 month](https://asahilinux.org/2024/06/vk13-on-the-m1-in-1-month/)の非公式日本語訳です。

訳注: まだDeepLの結果を貼っただけ(2024/10/19)

---
# M1 の Vulkan 1.3 が1ヶ月で登場

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202402.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202410.md)

ついに、M1用のコンフォーマントなVulkanが登場しました！新しい 「Honeykrisp 」ドライバは、「移植性 」の免除なしに1.3の完全な仕様を実装した、あらゆるオペレーティングシステム上のAppleハードウェアのための最初のコンフォーマントなVulkan®です。

Honeykrispはまだエンドユーザー向けにリリースされていません。私たちは機能の追加、パフォーマンスの向上、より多くのハードウェアへの移植を続けています。ソースコードは開発者向けに公開されています。

![Honeykrisp上で動作するHoloCure。DXVK、FEX、Proton。](https://asahilinux.org/img/blog/2024/06/holocure.png)

Honeykrisp上で動作するHoloCure。DXVK、FEX、Proton上で動作するHoloCure。

Honeykrispは、以前のM1 Vulkanの取り組みに基づくものではなく、フェイス・エクストランドのNVIDIA GPU用オープンソースNVKドライバに基づくものです。彼女の言葉を借りれば

    MesaのすべてのVulkanドライバは、その系譜をIntel Vulkanドライバに辿り、そこからコピー＋ペーストすることから始まりました。私の希望は、NVKが最終的に誰もがコピー＆ペーストするドライバになることです。そのために、過去7年半の間にVulkanドライバ用に開発したすべてのベストプラクティスを使ってNVKを構築し、コードベースをクリーンでよく整理された状態に保とうとしています。

NVKを再利用できるのに、なぜゼロから機能を実装するのに何年も費やすのでしょうか？NVIDIAのデスクトップ・アーキテクチャが、M1のルーツであるモバイル・アーキテクチャと異なるため、最初は摩擦があるでしょう。その代わり、デスクトップゲーム用に設計された最新のドライバを手に入れることができます。

私たちは、正しさを保証する50万のテストに合格し、その結果を提出する必要があります。NVKと私たちのOpenGL 4.6ドライバから始めて...私たちは、30日間のレビュー期間よりも早くVulkan 1.3適合性テストスイートをパスするドライバを書くことができますか？

前例がない...

チャレンジは受け入れられました。

## 4月2日

それはテキストから始まる。

    フェイス・・・Vulkanドライバを書きたいと思うんだ。

彼女のアドバイス？

    とにかくタイプし始めなさい。

M1のコードをNVKに追加し、NVIDIAを削除するだけです。ハードウェアへのアクセスはカーネルが仲介してくれるので、OpenGLと共有されているコードを使用して、「NVK」を朝日リナのカーネル・ドライバに接続し始めます。そして、シェーダー・コンパイラーを接続し、大活躍させるのだ。

## 4月3日

リソースにアクセスするために、GPUはリソースのアドレス、フォーマット、サイズを含む「ディスクリプタ」を使用する。Vulkanは、アプリケーションの「記述子セットレイアウト」に従って、記述子を「セット」にまとめます。シェーダーをコンパイルする際、ドライバは記述子へのアクセスを減らし、セットレイアウトをハードウェアのデータ構造と一致させます。私たちのディスクリプタは NVIDIA のものとは異なるため、次のタスクは NVK のディスクリプタセット低レイアウトを適応させることです。私たちは、追加したコードよりも削除したコードの方がはるかに多いという、シンプルで正しいアプローチから始めます。

## 4月4日

ディスクリプタが使えるようになったので、コンピュートシェーダをコンパイルできるようになりました。ここで、計算をディスパッチする固定機能ハードウェアをプログラムします。まず、Vulkanコマンド・バッファをM1「コントロール・ストリーム」のリストにマッピングするためのブックキーピングを追加し、次にコンピュート・コントロール・ストリームを生成する。そのコードをOpenGLドライバからコピーし、GLをVulkanに変換し、計算を行います。

これで、バッファと画像の「コピー」に進むには十分です。我々はVulkanのコピーをコンピュートシェーダーで実装し、あたかも我々がアプリケーションであるかのように、内部的にVulkanコマンドでディスパッチします。最初のコピーテストはパスした。

## 4月5日

昨日のコードに肉付けし、すべてのコピーテストに合格。

## 4月6日

グラフィックスに取り組む準備ができた。目新しいのは、深度やステンシルのようなグラフィックスの状態を処理することだ。これは簡単だが、扱わなければならない状態がたくさんある。フェイスのコードでは、すべての「ダイナミック・ステート」を1つの構造体に集め、それをハードウェア制御語に変換している。いつものように、この翻訳をOpenGLドライバから取得し、NVKとブレンドして、次に進む。

## 4月7日

何が状態を「動的」にするのか？ダイナミック・ステートは、シェーダーを再コンパイルすることなく変更できます。対照的に、静的状態は「パイプライン」と呼ばれるシェーダーバイナリに焼き付けられます。ゲームがローディング画面中にすべてのパイプラインを作成すれば、ゲームプレイ中にコンパイラが「スタッター」することはない。多くのゲーム開発者は事前に状態を把握していないため、パイプラインを早期に作成することができません。それに対して、Vulkanは、パイプラインをオプションにするEXT_shader_object拡張で中断され、より多くのステートをダイナミックにしました。

我々は、完全なダイナミックステートとシェーダーオブジェクトを望んでいる。残念なことに、M1はシェーダーにランダムなステートを焼き付けています：頂点アトリビュート、フラグメント出力、ブレンディング、リンク補間修飾子まで。2010年代のほとんどの業界と同様、M1の設計者はパイプラインに賭けた。

このハードウェアを前にすれば、合理的なドライバ開発者ならパイプラインに二の足を踏むだろう。DXVKは吃驚するだろうが、我々はコンフォーマンスに合格するだろう。

私は合理的ではありません。

OpenGLのスタッタリングをなくすために、私たちは4つの戦略でステートをダイナミックにします：

- 条件付きコード。
- プリコンパイルされたバリアント。
- インダイレクト。
- プロログとエピログ。

待って、ログって何？

AMDもまたシェーダーにステートを埋め込んでいる。ハードウェア・バイナリをプロログ、シェーダー、エピログの3つに分割するのだ。ダイナミック・ステートを周辺に限定することで、シェーダーのバリエーションを排除している。プロログとエピログはオンザフライでコンパイルされるが、これは高速でもたつかない。シェーダーパーツのリンクは素早く連結するか、ロングジャンプでリンクを完全に回避する。この戦略はM1にも有効です。

Honeykrispについては、NVKのリードに従い、すべてのステートをダイナミックとして扱いましょう。他のVulkanドライバでは、これほど早い段階で完全なダイナミックステートとシェーダオブジェクトを実装したものはありませんが、後々のリファクタリングを避けることができます。今日、プロログとエピログをビルド、コンパイル、キャッシュするコードを追加しました。

これをまとめると、（ダイナミックな）三角形になる：

[古典的な虹の三角形](https://asahilinux.org/img/blog/2024/06/hk-triangle.avif)

## 4月8日

失敗したテストのリストに導かれながら、ボーダーの色の翻訳など、途中で見逃した小さな部分を配線していく。

```
/* Translate an American VkBorderColor into a Canadian agx_border_colour */
enum agx_border_colour
translate_border_color(VkBorderColor color)
{
   switch (color) {
   case VK_BORDER_COLOR_INT_TRANSPARENT_BLACK:
      return AGX_BORDER_COLOUR_TRANSPARENT_BLACK;
   ...
   }
}

```

テスト結果はそこそこになってきた。

```
    Pass: 149770, Fail: 7741, Crash: 2396
```

vkQuakeには十分ですね。

![Honeykrisp上で動作するQuakeのVulkanポート](https://asahilinux.org/img/blog/2024/06/vkquake.png)

## 4月9日

たくさんの小さな修正により、Vulkan 1.1の合格率は99.6%になりました。なぜそこで止まるのか？NVKは1.3に準拠しているので、1.3を主張してゴールまでスキップしよう。

```
Pass: 255209, Fail: 3818, Crash: 599
```

1週間記念で1.3の合格率98.3%。

悪くない。

## 4月10日

SuperTuxKart に Vulkan レンダラーが追加された。

![Honeykrispを使ったSuperTuxKartのレンダリング。STKエンタープライズでほうきに乗るPepper（Pepper and Carrotのキャラクター）](https://asahilinux.org/img/blog/2024/06/hkr-stk.png)

## 4月11日

Zinkも動く。

![HoneykrispでZinkを使ったSuperTuxKartのレンダリング](https://asahilinux.org/img/blog/2024/06/hkr-stk-zink.avif)


## 4月12日

あるデバイスで、任意の検証しきい値が厳しすぎて通らないというテストのバグを突き止めた。バグレポートを提出し、数週間で解決した。

## 4月16日

記述子インデクシング」のテストで、非均一制御フローにおけるサブグループ・シャッフルに影響するコンパイラのバグが発見された。M1のシャッフル命令は風変わりだが、回避するのは簡単だ。これを修正することで、記述子インデクシングのテストが修正される。
## 4月17日

レジスタ・アロケータ内部でいくつかのテストがクラッシュする。それらのシェーダーには奇妙な構造が含まれている：

```
if (condition) {
   while (true) { }
}
``

条件は常に偽だが、コンパイラはそれを知らない。

シェーダーは有限時間で終了しなければならないため、無限ループは名目上無効だが、このシェーダーは構文上有効である。「すべてのループはブレークを含む」というのはシェーダとしては当然のことのように思えますが、これは誤りです。レジスタ割り当てを修正するのは簡単だが、なんともドジだ。

## 4月18日

コピーを覚えているだろうか？遅いし、現在、すべてのフレームが画面に表示されるにはコピーが必要だ。

ゼロコピー」レンダリングのためには、プロセス境界を越えて効率的なサーフェスレイアウトをネゴシエートするために、Linuxウィンドウシステムの十分な統合が必要だ。Linuxはこの目的のために「モディファイア」を使うので、EXT_image_drm_format_modifierエクステンションを実装する。実装するというのは、コピーするということだ。

コピーを避けるためのコピーだ。

## 4月20日

```
    「16K arm64 Linux Vulkan Macで4K x86 Windows Direct3D PCゲームがしたい。」

    ...

    「奥さん、ここはウェンディーズです」
```

## 4月22日

バグの修正が遅くなったので、一歩下がってドライバーのアーキテクチャをチェックする。我々はすべての状態を動的なものとして扱っているため、パイプライン作成時に制御ワードをプリパックしていない。そのため、理論上のCPUオーバーヘッドが増える。

これは問題だろうか？いくつかの最適化の後、vkoverheadによれば、1秒間に1億回の描画が可能だという。

大丈夫だと思う。

## 4月24日

YCbCrを点灯させる時が来た。特別なYCbCrハードウェアを使わなければ、この機能は「ソフトウェア専用」だ。しかし、多くのコードに触れる。

あまりに多くのコードに触れるので、モハメド・アーメッドは丸一夏を費やしてNVKにこの機能を追加した。

つまり、彼はひと夏かけてこの機能をHoneykrispに追加したのだ。

ありがとう、モハメド。）

## 4月25日

次はクエリーコピーだ。Vulkanでは、アプリケーションはレンダリングされたサンプルの数を照会し、その結果を不透明な「クエリプール」に書き込むことができます。結果は、CPUまたはGPU上のクエリプールからコピーできます。

CPU では、ドライバがプールの内部データ構造をマップし、結果をコ ピーします。これには、非自明なリパッキングが必要になる場合がある。

GPUの場合は、コンピュートシェーダーでリパックする必要があります。GPU上でCコードを実行することはできないので、それは難しいですよね？

...実は、できるんです。

ちょっとした魔術を使えば、GPUのクエリー・コピーはC言語と同じくらい簡単になります。

```
void copy_query(struct params *p, int i) {
  uintptr_t dst = p->dest + i * p->stride;
  int query = p->first + i;

  if (p->available[query] || p->partial) {
    int q = p->index[query];
    write_result(dst, p->_64, p->results[q]);
  }

  ...
}
```

## 4月26日
ラスボス：ボーダーカラー、ハードモード。

Direct3Dでは、サンプラーを作成する際に、アプリケーションが任意のボーダーカラーを選択できます。対照的に、Vulkanは3つのボーダーカラーしか必要としません：
-    (0, 0, 0, 0) - 透明な黒
-    (0, 0, 0, 1) - 不透明な黒
-    (1, 1, 1, 1) - 不透明な白

これらを4月8日に扱った。残念ながら、2つの問題がある。

まず、Direct3Dとの互換性のために、カスタムボーダーの色が必要です。DXVKもvkd3d-protonもEXT_custom_border_color拡張を必要とする。

第二に、私たちのハードウェアには微妙な問題があり、カスタムボーダーカラーがなくても何十回も失敗します。この問題を理解するために、ピクセルフォーマットとコンポーネントの並べ替えスウィズルを含むテクスチャ記述子を再検討してみましょう。

いくつかのフォーマットは暗黙的に並び替えられます。一般的な「BGRA」フォーマットは、歴史的な理由から赤と青を入れ替えます。M1はこれらのフォーマットを直接サポートしない。その代わり、ドライバはフォーマットの並び替えでスウィズルを構成する。アプリケーションがBGRAフォーマットでBARBスウィズルを使用する場合、ドライバはRGBAフォーマットでRABRスウィズルを使用します。

スウィズルはボーダーカラーに適用されますが、フォーマットは適用されません。ハードウェアが構成されたスウィズルを適用した後に正しい結果を得るためには、ボーダー・カラーをプログラムするときにフォーマットの並べ替えを元に戻す必要があります。私たちのOpenGLドライバは、サンプラーを作成するときにテクスチャフォーマットを知っているため、この方法でボーダーカラーを実装しています。残念ながら、Vulkanはその情報を与えてくれません。

カスタムボーダーカラーのサポートがなければ、「大丈夫なはず」です。赤と青を入れ替えても、色が白か黒なら何も変わりません。

さらに微妙な引っかかりがある。Vulkanは、4ビットコンポーネントでパックされた16ビットフォーマットのサポートを義務付けている。M1は同様のフォーマットをサポートしているが...「エンディアン」を逆にして、赤とアルファを入れ替えている。

それでもまだ大丈夫なようだ。透明な黒（すべてゼロ）と不透明な白（すべて1）については、成分を入れ替えても結果は変わりません。

問題は不透明な黒：(0, 0, 0, 1)。赤とアルファを入れ替えると(1, 0, 0, 0)になります。透明な赤？うーん。

困った。既知のハードウェア構成では、正しいVulkanセマンティクスを実装していません。

希望は失われたのか？
諦めるのか？
合理的な人間ならそうするだろう。
私は合理的ではない。

ディープエンドに飛び込もう。カスタムボーダーカラーを実装すれば、不透明な黒は特殊なケースになる。しかし、どうやって？M1のカスタムボーダーカラーは、テクスチャーフォーマットとサンプラーを絡める。合理的な人なら、Direct3Dのサポートをスキップするだろう。

ご存知のように、私は合理的ではありません。

ハードウェアは不向きだが、我々はソフトウェアをコントロールする。シェーダーがテクスチャをサンプリングするときはいつでも、ボーダーカラーを修正するコードを注入します。このエミュレーションはシンプルで、正しく、遅い。後でドライバの汚いトリックを使ってスピードアップする。今のところ、我々はコストを払い、フルカスタムのボーダーカラーを宣伝し、不透明な黒のテストに合格している。

##4月27日
あとは最後のバグ修正だけだ。

```
Pass: 686930, Fail: 0
```

成功。

## 未来
次の課題は、DXVKとvkd3d-protonがDirect3Dをレイヤーするのに必要なものをすべて実装することだ。これにはtransform feedbackのような難解な拡張も含まれる。それから、Wineとオープンソースのx86エミュレータがAsahi Linux上でWindowsゲームを動かす。

というわけで、前置きが長くなった。その間に、我々の準拠したOpenGL 4.6ドライバでLinuxゲームを楽しんでください。

![Honeykrispで動作するBaby Storm。DXVK、FEX、Proton](https://asahilinux.org/img/blog/2024/06/babystorm.avif)

#### アリッサ・ローゼンツヴァイク - 2024-06-05
