[Vulkan 1.3 on the M1 in 1 month](https://asahilinux.org/2024/06/vk13-on-the-m1-in-1-month/)の非公式日本語訳です。

訳注: まだDeepLの結果を貼っただけ(2024/10/19)

---
# M1 の Vulkan 1.3 が1ヶ月で登場

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202402.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202410.md)

ついに、M1 用の規格準拠な Vulkanが登場しました！新しい『Honeykrisp』ドライバはあらゆるオペレーティングシステム上で Apple ハードウェア用の
最初の[規格準拠の Vulkan®]https://www.khronos.org/conformance/adopters/conformant-products/vulkan#submission_780)です。
『移植性』の免除なしに 1.3 の完全な仕様を実装しています。Honeykrisp はまだエンドユーザー向けに*リリースされていません*。
機能の追加や性能の向上やより多くのハードウェアへの移植を続けています。[ソースコード](https://gitlab.freedesktop.org/alyssa/mesa/-/tree/honeykrisp-20240506-2/src/asahi/vulkan?ref_type=heads)は開発者向けに公開されています。

![horocure](https://asahilinux.org/img/blog/2024/06/holocure.png)

**Honeykrisp 上で動作する [HoloCure](https://kay-yu.itch.io/holocure)。DXVK、FEX、Proton上で動作。**

Honeykrispは、以前の M1 Vulkan の取り組みに基づくものではなく、[Faith Ekstrand氏](https://mastodon.gamedev.place/@gfxstrand)のNVIDIA GPU用
オープンソース[NVKドライバ](https://www.collabora.com/news-and-blog/news-and-events/introducing-nvk.html)に基づくものです。彼女の言葉を借りれば

```
Mesa のすべての Vulkan ドライバは、その系譜を Intel Vulkan ドライバにたどり、そこからコピー＋ペーストすることから始まりました。私の希望は、NVKが
最終的に誰もがコピー＆ペーストするドライバになることです。そのために、過去7年半の間に Vulkan ドライバ用に開発したすべてのベストプラクティスを使って NVK を
構築し、コードベースをクリーンでよく整理された状態に保とうとしています。
```

NVK を再利用できるのに、なぜゼロから機能を実装するのに何年も費やすのでしょうか？ NVIDIA のデスクトップ・アーキテクチャが、M1 のルーツであるモバイル・アーキテクチャと
異なるため、最初は摩擦を生じるでしょう。その代わり、デスクトップゲーム用に設計された最新のドライバを手に入れることができます。

正確性を保証する50万のテストに合格し、[その結果を提出](https://www.khronos.org/conformance/adopters)する必要があります。NVK と私たちの OpenGL 4.6 ドライバから
始めて... 30日間のレビュー期間よりも早く Vulkan 1.3 適合性テストスイートをパスするドライバを書くことができるでしょうか?

前例がない...

挑戦は受け入れられました。

### 4月2日

テキストから始まる。

```
    Faithさん・・・Vulkanドライバを書きたいと思っています。
```

アドバイス?

```
    とにかくタイプし始めなさい。
```

コピーペーストはまだです。M1 のコードを NVK に追加し、進めるにつれて NVIDIA のコードを削除するだけです。ハードウェアへのアクセスはカーネルが仲介してくれるので、
OpenGL と共有されているコードを使用して、『NVK』を[Asahi Lina氏](https://vt.social/@lina)のカーネル・ドライバに接続し始めます。そして、
シェーダ・コンパイラをつないで、大活躍させましょう。

### 4月3日

リソースにアクセスするために、GPU はリソースのアドレス、フォーマット、サイズを含む『記述子(descriptor)』を使用します。Vulkan は、アプリケーションの
『記述子セットレイアウト』に従って、記述子を『セット』にまとめます。シェーダをコンパイルする際、ドライバは記述子へのアクセスを減らし、セットレイアウトを
ハードウェアのデータ構造と一致させます。私たちの記述子は NVIDIA のものとは異なるため、次のタスクは NVK の記述子セット低層に適応させることです。
追加したコードよりも削除したコードの方がはるかに多いという、シンプルで正しいアプローチから始めます。

### 4月4日

記述子が使えるようになったので、コンピュートシェーダをコンパイルできるようになりました。ここで、計算をディスパッチする固定機能ハードウェアをプログラムします。
まず、Vulkan コマンド・バッファを M1の『コントロール・ストリーム』のリストにマッピングするためのブックキーピングを追加し、次にコンピュート・コントロール・ストリームを
生成します。そのコードを OpenGL ドライバからコピーし、GL を Vulkan に変換し、計算を行います。

バッファと画像の『コピー』に進むにはこれで十分です。Vulkan のコピーをコンピュートシェーダで実装し、あたかも自身がアプリケーションであるかのように、内部的に
Vulkan コマンドでディスパッチします。最初のコピーテストは合格しました。

### 4月5日

昨日のコードに肉付けし、*すべての*コピーテストに合格しました。

### 4月6日

グラフィックスに取り組む準備ができました。目新しいのは、深度やステンシルのようなグラフィックスの状態を処理することです。これは簡単だが、扱わなければならない状態が
*たくさん*あります。Faith氏のコードでは、すべての『動的状態(dynamic state)』を1つの構造体に集め、それをハードウェア制御語に変換しています。いつものように、
この変換結果を OpenGL ドライバから取得し、NVK とブレンドして、次に進みます。

### 4月7日

何が状態を『動的』にするのでしょうか? 動的状態は、シェーダーを再コンパイルすることなく変更できます。対照的に、静的状態は『パイプライン』と呼ばれるシェーダーバイナリに
焼き付けられます。ゲームがローディング画面中にすべてのパイプラインを作成すれば、ゲームプレイ中にコンパイラが『もたつく(stutter)』することはありません。
このアイデアはまだうまくいっていません。多くのゲーム開発者は事前に状態を把握していないため、パイプラインを早期に作成することができません。それに対して、
Vulkan　は、パイプラインを*オプション*にする`EXT_shader_object`拡張を中断し、より多くの状態を動的にしました。

私たちは完全な動的状態とシェーダーオブジェクトを求めています。残念なことに、M1 はシェーダーにランダムな状態を焼き付けています：頂点属性、フラグメント出力、
ブレンディング、さらにリンク補間修飾子まで。2010年代のほとんどの業界と同様、M1 の設計者はパイプラインに賭けました。

このハードウェアを前にすれば、合理的なドライバ開発者ならパイプラインに二の足を踏むでしょう。DXVK はもたつくが、適合性テストに合格するでしょう。

私は合理的ではありません。

OpenGL のもたつきをなくすために、4つの戦略で状態を動的にします。

- 条件付きコード
- プリコンパイルされたバリアント
- 間接参照(indirect)
- プロローグ(prolog)とエピローグ(epilog)

待って、ログって何ですか?

AMD もまたシェーダに状態を埋め込んでいます。ハードウェア・バイナリをプロローグ、シェーダ、エピローグの3つに分割しています。動的状態を周辺に限定することで、
シェーダのバリエーションを排除しています。プロローグとエピローグはオンザフライでコンパイルされますが、これは高速でもたつきません。シェーダパーツのリンクは
素早く連結するか、ロングジャンプでリンクを完全に回避します。この戦略は M1 にも有効です。

Honeykrisp については、NVK の先導に従い、*すべて*の状態を動的に扱います。他の Vulkan ドライバでは、これほど早い段階で完全な動的状態とシェーダオブジェクトを
実装したものはありませんが、後々のリファクタリングを避けることができます。今日、プロローグとエピローグをビルド、コンパイル、キャッシュするコードを追加しました。

これをまとめると、（動的な）三角形を得ました。

![古典的な虹の三角形](https://asahilinux.org/img/blog/2024/06/hk-triangle.avif)

### 4月8日

失敗したテストのリストに導かれながら、ボーダーの色の変換など、途中で見逃した小さな部分を配線していきます。

```
/* Translate an American VkBorderColor into a Canadian agx_border_colour */
enum agx_border_colour
translate_border_color(VkBorderColor color)
{
   switch (color) {
   case VK_BORDER_COLOR_INT_TRANSPARENT_BLACK:
      return AGX_BORDER_COLOUR_TRANSPARENT_BLACK;
   ...
   }
}
```

テスト結果はそこそこになってきました。

```
    Pass: 149770, Fail: 7741, Crash: 2396
```

[vkQuake](https://github.com/Novum/vkQuake)には十分ですね。

![Honeykrisp上で動作するQuakeのVulkanポート](https://asahilinux.org/img/blog/2024/06/vkquake.png)

### 4月9日

たくさんの小さな修正により、Vulkan 1.1 の合格率は99.6%になりました。なぜそこで止まるのですか？ NVK は 1.3 に準拠しているので、1.3 を主張してゴールまでスキップしましょう。

```
Pass: 255209, Fail: 3818, Crash: 599
```

1週間記念で 1.3 の合格率 98.3% です。

悪くないです。

### 4月10日

SuperTuxKart に Vulkan レンダラーが追加されました。

![Honeykrispを使ったSuperTuxKartのレンダリング。STKエンタープライズでほうきに乗るPepper(Pepper and Carrotのキャラクター)](https://asahilinux.org/img/blog/2024/06/hkr-stk.png)

### 4月11日

[Zink](https://docs.mesa3d.org/drivers/zink.html)も動きます。

![HoneykrispでZinkを使ったSuperTuxKartのレンダリング](https://asahilinux.org/img/blog/2024/06/hkr-stk-zink.avif)

### 4月12日

あるデバイスで、任意の検証しきい値が厳しすぎて通らないというテストのバグを突き止めた。バグレポートを提出し、数週間で解決した。

## 4月16日

記述子インデクシング」のテストで、非均一制御フローにおけるサブグループ・シャッフルに影響するコンパイラのバグが発見された。M1のシャッフル命令は風変わりだが、回避するのは簡単だ。これを修正することで、記述子インデクシングのテストが修正される。
## 4月17日

レジスタ・アロケータ内部でいくつかのテストがクラッシュする。それらのシェーダーには奇妙な構造が含まれている：

```
if (condition) {
   while (true) { }
}
``

条件は常に偽だが、コンパイラはそれを知らない。

シェーダーは有限時間で終了しなければならないため、無限ループは名目上無効だが、このシェーダーは構文上有効である。「すべてのループはブレークを含む」というのはシェーダとしては当然のことのように思えますが、これは誤りです。レジスタ割り当てを修正するのは簡単だが、なんともドジだ。

## 4月18日

コピーを覚えているだろうか？遅いし、現在、すべてのフレームが画面に表示されるにはコピーが必要だ。

ゼロコピー」レンダリングのためには、プロセス境界を越えて効率的なサーフェスレイアウトをネゴシエートするために、Linuxウィンドウシステムの十分な統合が必要だ。Linuxはこの目的のために「モディファイア」を使うので、EXT_image_drm_format_modifierエクステンションを実装する。実装するというのは、コピーするということだ。

コピーを避けるためのコピーだ。

## 4月20日

```
    「16K arm64 Linux Vulkan Macで4K x86 Windows Direct3D PCゲームがしたい。」

    ...

    「奥さん、ここはウェンディーズです」
```

## 4月22日

バグの修正が遅くなったので、一歩下がってドライバーのアーキテクチャをチェックする。我々はすべての状態を動的なものとして扱っているため、パイプライン作成時に制御ワードをプリパックしていない。そのため、理論上のCPUオーバーヘッドが増える。

これは問題だろうか？いくつかの最適化の後、vkoverheadによれば、1秒間に1億回の描画が可能だという。

大丈夫だと思う。

## 4月24日

YCbCrを点灯させる時が来た。特別なYCbCrハードウェアを使わなければ、この機能は「ソフトウェア専用」だ。しかし、多くのコードに触れる。

あまりに多くのコードに触れるので、モハメド・アーメッドは丸一夏を費やしてNVKにこの機能を追加した。

つまり、彼はひと夏かけてこの機能をHoneykrispに追加したのだ。

ありがとう、モハメド。）

## 4月25日

次はクエリーコピーだ。Vulkanでは、アプリケーションはレンダリングされたサンプルの数を照会し、その結果を不透明な「クエリプール」に書き込むことができます。結果は、CPUまたはGPU上のクエリプールからコピーできます。

CPU では、ドライバがプールの内部データ構造をマップし、結果をコ ピーします。これには、非自明なリパッキングが必要になる場合がある。

GPUの場合は、コンピュートシェーダーでリパックする必要があります。GPU上でCコードを実行することはできないので、それは難しいですよね？

...実は、できるんです。

ちょっとした魔術を使えば、GPUのクエリー・コピーはC言語と同じくらい簡単になります。

```
void copy_query(struct params *p, int i) {
  uintptr_t dst = p->dest + i * p->stride;
  int query = p->first + i;

  if (p->available[query] || p->partial) {
    int q = p->index[query];
    write_result(dst, p->_64, p->results[q]);
  }

  ...
}
```

## 4月26日
ラスボス：ボーダーカラー、ハードモード。

Direct3Dでは、サンプラーを作成する際に、アプリケーションが任意のボーダーカラーを選択できます。対照的に、Vulkanは3つのボーダーカラーしか必要としません：
-    (0, 0, 0, 0) - 透明な黒
-    (0, 0, 0, 1) - 不透明な黒
-    (1, 1, 1, 1) - 不透明な白

これらを4月8日に扱った。残念ながら、2つの問題がある。

まず、Direct3Dとの互換性のために、カスタムボーダーの色が必要です。DXVKもvkd3d-protonもEXT_custom_border_color拡張を必要とする。

第二に、私たちのハードウェアには微妙な問題があり、カスタムボーダーカラーがなくても何十回も失敗します。この問題を理解するために、ピクセルフォーマットとコンポーネントの並べ替えスウィズルを含むテクスチャ記述子を再検討してみましょう。

いくつかのフォーマットは暗黙的に並び替えられます。一般的な「BGRA」フォーマットは、歴史的な理由から赤と青を入れ替えます。M1はこれらのフォーマットを直接サポートしない。その代わり、ドライバはフォーマットの並び替えでスウィズルを構成する。アプリケーションがBGRAフォーマットでBARBスウィズルを使用する場合、ドライバはRGBAフォーマットでRABRスウィズルを使用します。

スウィズルはボーダーカラーに適用されますが、フォーマットは適用されません。ハードウェアが構成されたスウィズルを適用した後に正しい結果を得るためには、ボーダー・カラーをプログラムするときにフォーマットの並べ替えを元に戻す必要があります。私たちのOpenGLドライバは、サンプラーを作成するときにテクスチャフォーマットを知っているため、この方法でボーダーカラーを実装しています。残念ながら、Vulkanはその情報を与えてくれません。

カスタムボーダーカラーのサポートがなければ、「大丈夫なはず」です。赤と青を入れ替えても、色が白か黒なら何も変わりません。

さらに微妙な引っかかりがある。Vulkanは、4ビットコンポーネントでパックされた16ビットフォーマットのサポートを義務付けている。M1は同様のフォーマットをサポートしているが...「エンディアン」を逆にして、赤とアルファを入れ替えている。

それでもまだ大丈夫なようだ。透明な黒（すべてゼロ）と不透明な白（すべて1）については、成分を入れ替えても結果は変わりません。

問題は不透明な黒：(0, 0, 0, 1)。赤とアルファを入れ替えると(1, 0, 0, 0)になります。透明な赤？うーん。

困った。既知のハードウェア構成では、正しいVulkanセマンティクスを実装していません。

希望は失われたのか？
諦めるのか？
合理的な人間ならそうするだろう。
私は合理的ではない。

ディープエンドに飛び込もう。カスタムボーダーカラーを実装すれば、不透明な黒は特殊なケースになる。しかし、どうやって？M1のカスタムボーダーカラーは、テクスチャーフォーマットとサンプラーを絡める。合理的な人なら、Direct3Dのサポートをスキップするだろう。

ご存知のように、私は合理的ではありません。

ハードウェアは不向きだが、我々はソフトウェアをコントロールする。シェーダーがテクスチャをサンプリングするときはいつでも、ボーダーカラーを修正するコードを注入します。このエミュレーションはシンプルで、正しく、遅い。後でドライバの汚いトリックを使ってスピードアップする。今のところ、我々はコストを払い、フルカスタムのボーダーカラーを宣伝し、不透明な黒のテストに合格している。

##4月27日
あとは最後のバグ修正だけだ。

```
Pass: 686930, Fail: 0
```

成功。

## 未来
次の課題は、DXVKとvkd3d-protonがDirect3Dをレイヤーするのに必要なものをすべて実装することだ。これにはtransform feedbackのような難解な拡張も含まれる。それから、Wineとオープンソースのx86エミュレータがAsahi Linux上でWindowsゲームを動かす。

というわけで、前置きが長くなった。その間に、我々の準拠したOpenGL 4.6ドライバでLinuxゲームを楽しんでください。

![Honeykrispで動作するBaby Storm。DXVK、FEX、Proton](https://asahilinux.org/img/blog/2024/06/babystorm.avif)

#### アリッサ・ローゼンツヴァイク - 2024-06-05
