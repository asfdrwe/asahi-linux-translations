[Vulkan 1.3 on the M1 in 1 month](https://asahilinux.org/2024/06/vk13-on-the-m1-in-1-month/)の非公式日本語訳です。

訳注: まだDeepLの結果を貼っただけ(2024/10/19)

---
# M1 の Vulkan 1.3 が1ヶ月で登場

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202402.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202410.md)

ついに、M1 用の規格準拠な Vulkanが登場しました！新しい『Honeykrisp』ドライバはあらゆるオペレーティングシステム上で Apple ハードウェア用の
最初の[規格準拠の Vulkan®]https://www.khronos.org/conformance/adopters/conformant-products/vulkan#submission_780)です。
『移植性』の免除なしに 1.3 の完全な仕様を実装しています。Honeykrisp はまだエンドユーザー向けに*リリースされていません*。
機能の追加や性能の向上やより多くのハードウェアへの移植を続けています。[ソースコード](https://gitlab.freedesktop.org/alyssa/mesa/-/tree/honeykrisp-20240506-2/src/asahi/vulkan?ref_type=heads)は開発者向けに公開されています。

![horocure](https://asahilinux.org/img/blog/2024/06/holocure.png)

**Honeykrisp 上で動作する [HoloCure](https://kay-yu.itch.io/holocure)。DXVK、FEX、Proton上で動作。**

Honeykrispは、以前の M1 Vulkan の取り組みに基づくものではなく、[Faith Ekstrand氏](https://mastodon.gamedev.place/@gfxstrand)のNVIDIA GPU用
オープンソース[NVKドライバ](https://www.collabora.com/news-and-blog/news-and-events/introducing-nvk.html)に基づくものです。彼女の言葉を借りれば

```
Mesa のすべての Vulkan ドライバは、その系譜を Intel Vulkan ドライバにたどり、そこからコピー＋ペーストすることから始まりました。私の希望は、NVKが
最終的に誰もがコピー＆ペーストするドライバになることです。そのために、過去7年半の間に Vulkan ドライバ用に開発したすべてのベストプラクティスを使って NVK を
構築し、コードベースをクリーンでよく整理された状態に保とうとしています。
```

NVK を再利用できるのに、なぜゼロから機能を実装するのに何年も費やすのでしょうか？ NVIDIA のデスクトップ・アーキテクチャが、M1 のルーツであるモバイル・アーキテクチャと
異なるため、最初は摩擦を生じるでしょう。その代わり、デスクトップゲーム用に設計された最新のドライバを手に入れることができます。

正確性を保証する50万のテストに合格し、[その結果を提出](https://www.khronos.org/conformance/adopters)する必要があります。NVK と私たちの OpenGL 4.6 ドライバから
始めて... 30日間のレビュー期間よりも早く Vulkan 1.3 適合性テストスイートをパスするドライバを書くことができるでしょうか?

前例がない...

挑戦は受け入れられました。

### 4月2日

テキストから始まる。

```
    Faithさん・・・Vulkanドライバを書きたいと思っています。
```

アドバイス?

```
    とにかくタイプし始めなさい。
```

コピーペーストはまだです。M1 のコードを NVK に追加し、進めるにつれて NVIDIA のコードを削除するだけです。ハードウェアへのアクセスはカーネルが仲介してくれるので、
OpenGL と共有されているコードを使用して、『NVK』を[Asahi Lina氏](https://vt.social/@lina)のカーネル・ドライバに接続し始めます。そして、
シェーダ・コンパイラをつないで、大活躍させましょう。

### 4月3日

リソースにアクセスするために、GPU はリソースのアドレス、フォーマット、サイズを含む『記述子(descriptor)』を使用します。Vulkan は、アプリケーションの
『記述子セットレイアウト』に従って、記述子を『セット』にまとめます。シェーダをコンパイルする際、ドライバは記述子へのアクセスを減らし、セットレイアウトを
ハードウェアのデータ構造と一致させます。私たちの記述子は NVIDIA のものとは異なるため、次のタスクは NVK の記述子セット低層に適応させることです。
追加したコードよりも削除したコードの方がはるかに多いという、シンプルで正しいアプローチから始めます。

### 4月4日

記述子が使えるようになったので、コンピュートシェーダをコンパイルできるようになりました。ここで、計算をディスパッチする固定機能ハードウェアをプログラムします。
まず、Vulkan コマンド・バッファを M1の『コントロール・ストリーム』のリストにマッピングするためのブックキーピングを追加し、次にコンピュート・コントロール・ストリームを
生成します。そのコードを OpenGL ドライバからコピーし、GL を Vulkan に変換し、計算を行います。

バッファと画像の『コピー』に進むにはこれで十分です。Vulkan のコピーをコンピュートシェーダで実装し、あたかも自身がアプリケーションであるかのように、内部的に
Vulkan コマンドでディスパッチします。最初のコピーテストは合格しました。

### 4月5日

昨日のコードに肉付けし、*すべての*コピーテストに合格しました。

### 4月6日

グラフィックスに取り組む準備ができました。目新しいのは、深度やステンシルのようなグラフィックスの状態を処理することです。これは簡単だが、扱わなければならない状態が
*たくさん*あります。Faith氏のコードでは、すべての『動的状態(dynamic state)』を1つの構造体に集め、それをハードウェア制御語に変換しています。いつものように、
この変換結果を OpenGL ドライバから取得し、NVK とブレンドして、次に進みます。

### 4月7日

何が状態を『動的』にするのでしょうか? 動的状態は、シェーダーを再コンパイルすることなく変更できます。対照的に、静的状態は『パイプライン』と呼ばれるシェーダーバイナリに
焼き付けられます。ゲームがローディング画面中にすべてのパイプラインを作成すれば、ゲームプレイ中にコンパイラが『もたつく(stutter)』することはありません。
このアイデアはまだうまくいっていません。多くのゲーム開発者は事前に状態を把握していないため、パイプラインを早期に作成することができません。それに対して、
Vulkan　は、パイプラインを*オプション*にする`EXT_shader_object`拡張を中断し、より多くの状態を動的にしました。

私たちは完全な動的状態とシェーダーオブジェクトを求めています。残念なことに、M1 はシェーダーにランダムな状態を焼き付けています：頂点属性、フラグメント出力、
ブレンディング、さらにリンク補間修飾子まで。2010年代のほとんどの業界と同様、M1 の設計者はパイプラインに賭けました。

このハードウェアを前にすれば、合理的なドライバ開発者ならパイプラインに二の足を踏むでしょう。DXVK はもたつくが、適合性テストに合格するでしょう。

私は合理的ではありません。

OpenGL のもたつきをなくすために、4つの戦略で状態を動的にします。

- 条件付きコード
- プリコンパイルされたバリアント
- 間接参照(indirect)
- プロローグ(prolog)とエピローグ(epilog)

待って、ログって何ですか?

AMD もまたシェーダに状態を埋め込んでいます。ハードウェア・バイナリをプロローグ、シェーダ、エピローグの3つに分割しています。動的状態を周辺に限定することで、
シェーダのバリエーションを排除しています。プロローグとエピローグはオンザフライでコンパイルされますが、これは高速でもたつきません。シェーダパーツのリンクは
素早く連結するか、ロングジャンプでリンクを完全に回避します。この戦略は M1 にも有効です。

Honeykrisp については、NVK の先導に従い、*すべて*の状態を動的に扱います。他の Vulkan ドライバでは、これほど早い段階で完全な動的状態とシェーダオブジェクトを
実装したものはありませんが、後々のリファクタリングを避けることができます。今日、プロローグとエピローグをビルド、コンパイル、キャッシュするコードを追加しました。

これをまとめると、（動的な）三角形を得ました。

![古典的な虹の三角形](https://asahilinux.org/img/blog/2024/06/hk-triangle.avif)

### 4月8日

失敗したテストのリストに導かれながら、ボーダーの色の変換など、途中で見逃した小さな部分を配線していきます。

```
/* Translate an American VkBorderColor into a Canadian agx_border_colour */
enum agx_border_colour
translate_border_color(VkBorderColor color)
{
   switch (color) {
   case VK_BORDER_COLOR_INT_TRANSPARENT_BLACK:
      return AGX_BORDER_COLOUR_TRANSPARENT_BLACK;
   ...
   }
}
```

テスト結果はそこそこになってきました。

```
    Pass: 149770, Fail: 7741, Crash: 2396
```

[vkQuake](https://github.com/Novum/vkQuake)には十分ですね。

![Honeykrisp上で動作するQuakeのVulkanポート](https://asahilinux.org/img/blog/2024/06/vkquake.png)

### 4月9日

たくさんの小さな修正により、Vulkan 1.1 の合格率は99.6%になりました。なぜそこで止まるのですか？ NVK は 1.3 に準拠しているので、1.3 を主張してゴールまでスキップしましょう。

```
Pass: 255209, Fail: 3818, Crash: 599
```

1週間記念で 1.3 の合格率 98.3% です。

悪くないです。

### 4月10日

SuperTuxKart に Vulkan レンダラーが追加されました。

![Honeykrispを使ったSuperTuxKartのレンダリング。STKエンタープライズでほうきに乗るPepper(Pepper and Carrotのキャラクター)](https://asahilinux.org/img/blog/2024/06/hkr-stk.png)

### 4月11日

[Zink](https://docs.mesa3d.org/drivers/zink.html)も動きます。

![HoneykrispでZinkを使ったSuperTuxKartのレンダリング](https://asahilinux.org/img/blog/2024/06/hkr-stk-zink.avif)

### 4月12日

テストバグの失敗を突き止めました。あるデバイスで任意の検証しきい値が厳しすぎて通らなかったです。バグレポートを提出し、数週間で[解決](https://github.com/KhronosGroup/VK-GL-CTS/commit/5fd73c841d775dff1ad52d8340d79dc120d64696)しました。

### 4月16日

『記述子インデクシング』のテストで、非単一制御フローにおけるサブグループ・シャッフルに影響するコンパイラのバグが発見されました。M1 のシャッフル命令は風変わりだが、
回避するのは簡単です。これを修正することで、記述子インデクシングのテストが修正されます。

### 4月17日

レジスタ・アロケータ内部でいくつかのテストがクラッシュします。それらのシェーダには奇妙な構造が含まれています。

```
if (condition) {
   while (true) { }
}
```

`condition` は常に偽だが、コンパイラはそれを知りません。

シェーダは有限時間で終了しなければならないため、無限ループは名目上無効ですが、このシェーダは構文上有効です。『すべてのループはブレークを含む』というのは
シェーダとしては当然のことのように思えますが、これは誤りです。レジスタ割り当てを修正するのは簡単ですが、なんともドジですね。

### 4月18日

コピーを覚えていますか? コピーでは遅いし、現在、すべてのフレームが画面に表示されるにはコピーが必要です。

『ゼロコピー』レンダリングのため、Linuxウィンドウシステムの十分な統合が必要で、プロセス境界を越えて効率的なサーフェスレイアウトをネゴシエートします。
Linux はこの目的のために『modifier』を使うので、`EXT_image_drm_format_modifier` エクステンションを実装します。実装するというのは、コピーするということです。

コピーを避けるためのコピーです。

### 4月20日

```
「16K arm64 Linux Vulkan Mac で 4K x86 Windows Direct3D PCゲームがやりたいです」

...

「奥さん、ここはウェンディーズです」
```

### 4月22日

バグの修正が遅くなったので、一歩下がってドライバーのアーキテクチャを検証します。すべての状態を動的なものとして扱っているため、パイプライン作成時に
制御ワードをプリパックしていません。そのため、理論上のCPUオーバーヘッドが増えます。

これは問題でしょうか?いくつかの最適化の後、[vkoverhead](https://github.com/zmike/vkoverhead) によれば、1秒間に1億回の描画が可能だといっています。

大丈夫だと思っています。

### 4月24日

YCbCrを点灯させる時が来ました。特別なYCbCrハードウェアを使わなければ、この機能は『ソフトウェア専用』です。しかし、*多くの*コードに触れます。

あまりに多くのコードに触れるので、[Mohamed Ahmed氏](https://mohamexiety.github.io/posts/final_report/)は丸一夏を費やして NVK にこの機能を追加しました。

つまり、ひと夏かけてこの機能を Honeykrisp に追加したのです。

ありがとう、Mohamedさん;-)

### 4月25日

次はクエリーコピーです。Vulkan では、アプリケーションはレンダリングされたサンプルの数を照会し、その結果を不透明な『クエリプール(query pool)』に
書き込むことができます。結果は、CPUまたはGPU上のクエリプールからコピーできます。

CPUの場合、ドライバがプールの内部データ構造をマップし、結果をコピーします。これには、自明でないリパッキングが必要になる場合があります。

GPUの場合、コンピュートシェーダでリパックする必要があります。難しいです。GPU上でCコードを実行することはできないので。あっています?

...実は、できるんです。

ちょっとした魔術を使えば、GPU のクエリーコピーは C 言語と同じくらい簡単になります。

```
void copy_query(struct params *p, int i) {
  uintptr_t dst = p->dest + i * p->stride;
  int query = p->first + i;

  if (p->available[query] || p->partial) {
    int q = p->index[query];
    write_result(dst, p->_64, p->results[q]);
  }

  ...
}
```

### 4月26日
ラスボス：ボーダーカラー、ハードモード

Direct3D では、サンプラーを作成する際に、アプリケーションが任意のボーダーカラーを選択できます。対照的に、Vulkan は3つのボーダーカラーしか必要としません：
- (0, 0, 0, 0) - 透明な黒
- (0, 0, 0, 1) - 不透明な黒
- (1, 1, 1, 1) - 不透明な白

これらを4月8日に扱いました。残念ながら、2つの問題があります。

はじめに、Direct3D との互換性のために、カスタムボーダーの色が必要です。[DXVK](https://github.com/doitsujin/dxvk) も
[vkd3d-proton](https://github.com/HansKristian-Work/vkd3d-proton) も`EXT_custom_border_color`拡張を必要とします。

第二に、ハードウェアには微妙な問題があり、カスタムボーダーカラーがなくても何十回も失敗します。この問題を理解するために、ピクセル*フォーマット*と
コンポーネントを並べ替える*swizzle*(訳注: [swizzling](https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)))を含むテクスチャ記述子を
再検討してみましょう。

いくつかのフォーマットは暗黙に並び替えられます。一般的な『BGRA』フォーマットは、[歴史的な理由](https://stackoverflow.com/questions/74924790/why-bgra-instead-of-rgba)から
赤と青を入れ替えます。M1 はこれらのフォーマットに直接対応しません。その代わり、ドライバはフォーマットの並び替えで swizzle を構成します。アプリケーションが `BGRA`フォーマットに対して
`BARB` swizzleを使用する場合、ドライバは `RGBA` フォーマットで `RABR` swizzle を使用します。

ひっかけがあります。swizzle はボーダーカラーに適用されますが、フォーマットは適用されません。構成されたswizzleをハードウェアが適用した後に正しい結果を得るためには、
ボーダーカラーをプログラムするときにフォーマットの並べ替えを*元に戻す*必要があります。OpenGLドライバは、サンプラーを作成するときにテクスチャフォーマットを知っているため、
この方法でボーダーカラーを実装しています。残念ながら、Vulkan はその情報を与えてくれません。

カスタムボーダーカラー対応がなければ、大丈夫な『はず』です。赤と青を入れ替えても、色が白か黒なら何も変わりません。

さらに*微妙な*引っかかりがあります。Vulkan は4ビットコンポーネントでパックされた16ビットフォーマットへの対応を義務付けています。M1 は同様のフォーマットに対応していますが...
『エンディアン』を逆にして、赤と*アルファ*を入れ替えています。

それでもまだ大丈夫なようです。透明な黒（すべて0）と不透明な白（すべて1）については、成分を入れ替えても結果は変わりません。

問題は不透明な黒：`(0, 0, 0, 1)`です。赤とアルファを入れ替えると`(1, 0, 0, 0)`になります。透明な赤ですか?うーん。

困りました。既知のハードウェア構成では、正しい Vulkan セマンティクスを実装していません。

希望は失われたのでしょうか?

諦めますか？

合理的な人間ならそうするでしょう。

私は合理的ではありません。

ディープエンドに飛び込みましょう。カスタムボーダーカラーを実装すれば、不透明な黒は特殊なケースになります。しかし、どうやって？ M1 のカスタムボーダーカラーは、
テクスチャーフォーマットとサンプラーを絡めます。合理的な人なら、Direct3D への対応をスキップするでしょう。

ご存知のように、私は合理的ではありません。

ハードウェアは不向きだが、私たちはソフトウェアをコントロールします。シェーダがテクスチャをサンプリングするときはいつでも、ボーダーカラーを修正するコードを注入します。
このエミュレーションはシンプルで、正しく、遅いです。後でドライバの汚いトリックを使ってスピードアップします。今のところ、コストを払い、フルカスタムのボーダーカラーを
宣伝し、不透明な黒のテストに合格しています。

### 4月27日
あとは最後のバグ修正だけです。

```
Pass: 686930, Fail: 0
```

成功しました。

### 未来
次の課題は、[DXVK](https://github.com/doitsujin/dxvk/blob/master/VP_DXVK_requirements.json)と
[vkd3d-proton](https://github.com/HansKristian-Work/vkd3d-proton/blob/master/VP_D3D12_VKD3D_PROTON_profile.json)がDirect3Dを
層にするのに必要なものをすべて実装することです。これには
[トランスフォームフィードバック](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_transform_feedback.html)のような
難解な拡張も含まれています。それから、[Wine](https://www.winehq.org/)と[オープンソースx86エミュレータ](https://github.com/FEX-Emu/FEX)に
よって[Asahi Linux](https://asahilinux.org/)上で Windows ゲームが動くようになります。

先走りすぎました。それまでの間、[OpenGL 4.6準拠ドライバ](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202402.md)で 
Linux ゲームを楽しんでください... お楽しみに。

![Honeykrispで動作するBaby Storm。DXVK、FEX、Proton](https://asahilinux.org/img/blog/2024/06/babystorm.avif)

#### Alyssa Rosenzweig - 2024-06-05
