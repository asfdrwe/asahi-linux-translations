---
title: ASC
---

2025/8/22時点の[ASC](https://github.com/AsahiLinux/docs/blob/main/docs/hw/soc/asc.md)の翻訳

---
## ASC レジスタ
```
0x40 - いくつかのフラグ/コントロール

0x44 - CPU_CTRL
    4 - CPU_START

0x48 - CPU_STATUS
    5 - MBOXES_TO_AP_EMPTY
    4 - ?
    3 - FIQ_NOT_PENDING
    2 - IRQ_NOT_PENDING
    1 - CPU_STOPPED
    0 - CPU_IDLE
    
0x400
    10 - CPUが開始したときにセット(おそらくファームウェアにより)
    
0x80c - IRQ_CONFIG
    0 - IRQ_CONTROLLER_ENABLE

0x818 - IRQ_EVENT_IRQ?
0x820 - IRQ_EVENT_FIQ?

0xa00.. - IRQ_MASK_SET
0xa80.. - IRQ_MASK_CLEAR
0xb00.. - IRQ_MASK2_SET?
0xb80.. - IRQ_MASK2_CLEAR?

0x1000 - CFG?
    1 - IPIsからIRQへ、FIQではない?
0x1010 - A_SET
0x1014 - B_SET
0x1018 - A_CLR
    2 - FIQ IPIをトリガー?
    1 - IRQ IPIをトリガー?
0x101c - B_CLR

0x1030 - C_SET
0x1034 - D_SET
0x1038 - C_CLR
0x103c - D_CLR

0x8000 - CPU_STATUSのミラー?

0x4000~ と 0x8000~ はmailbox関連
```

## Mailboxes

M1のメインCPUコアとASCやIOP（I/Oプロセッサ）の間の通信にプロセッサ間で128ビット通知を送り返すハードウェアMailboxを使用しています。
さらにより大きなメッセージは共有メモリを使って送られます。通常のプロトコルは、一方のプロセッサが
共有メモリに書き込みを行い、mailbox通知をもう一方のプロセッサに送信して割り込みを発生させ、もう一方のプロセッサが変更された
メモリを見てより大きなメッセージを解釈する、というものです。

プロトコルはプロセッサによって異なりますが、メッセージの後半64ビットの下位8ビットがメッセージのIOP側でのエンドポイントを
エンコードすることが共通の要素であるように見えます。前半の64ビットはそのままmailboxに渡されるようで、それらには非常に
異なるエンコーディングが使用されているようです。

mailboxのハードウェア側はMMIO空間のオフセット+0x8000に位置し、[AIC](aic.md)で連続した番号を持つ4つの割り込みを使用
しており、そのうち2つは我々にとって有用です。

データは、2つの64ビット書き込みがオフセット+0x8800と+0x8808をターゲットにしたとき、メインCPUからIOPに送信されます。
IOPがデータを読み取りキューから削除すると、AICで最も低い番号を持つ割り込みが無効にされるかさらにデータが書き込まれるまで
トリガされます。

IOPからのデータは、メインCPUがオフセット+0x8830と+0x8838で64ビットMMIOリードを実行することにより、キューから読み出され
削除されます。データが利用可能な間はAICで最も高い番号を持つ割り込みがトリガされます。

0x8110の32ビットステータスレジスタは、CPU-to-IOPキューが空か（ビット17）空でないか（ビット16）を示します。対称的に、
+0x8114のステータスレジスタは、IOP-CPU間キューが空であるか（ビット17）空でないか（ビット16）を表示します。

同一方向に同時に複数のメッセージをキューに入れることが可能で、ackを待たずにCPUに複数の通知を送るIOPによって使用されます。
