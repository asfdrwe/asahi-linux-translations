---
title: SPMI
---

2025/10/25時点の[SPMI](https://github.com/AsahiLinux/docs/blob/main/docs/hw/soc/spmi.md)の翻訳

---

このブロックは SPMI バス上の単一のマスターを制御します。SPMI コマンドの送信を可能にするとともに、バス参加者向けの256ライン割り込みコントローラとしても機能します。ADT 互換性に基づいて、いくつかのリビジョンが存在します：

- `spmi,gen1`：M1 で使用
- `spmi,gen2`：M2 で使用
- `spmi,gen3`：M3 及びに M4 で使用

この文書は gen3 を基づて記述しています。リビジョンは後方互換性のあるインターフェースを備えているようですが、古いものでは一部の機能が利用できない場合があります。

## レジスタ概要

ADT 内の3つの MMIO 領域の最初の領域には、以下の32ビットレジスタが含まれます：

- [0x00] **STATUS** [RO]：TX FIFO と FIFOの状態
- [0x04] **TX_PUSH** [WO]：32bit ワードを TX FIFO に入れる書き込み
- [0x08] **RX_PULL** [RO]：RX FIFO から 32bit ワードを消費する読み取り
<!-- space -->
- [0x20..0x3F] **BUS_IRQ_MASK** [RW]：バスアサート割り込みラインの IRQ マスク領域
- [0x40] **IRQ_MASK** [RW]：コントローラアサート割り込みラインの IRQ マスク領域
<!-- space -->
- [0x60..0x7F] **BUS_IRQ_ACK** [RW]：バスアサート割り込みラインの IRQ ACK 領域
- [0x80] **IRQ_ACK** [RW]：コントローラアサート割り込みラインの IRQ ACK 領域
<!-- space -->
- [0xA0] **CONFIG1** [RW]：ビット0..2が設定可能、iBootにより6（`nub-spmi-aN`）または7（その他）に初期化。マスターアドレス？
- [0xA4] **ACTION1** [WO]：一部のビットに 1 を書き込むとアクションがトリガー
<!-- space -->
- [0xB0] **CURSORS** [RO]：TX FIFO と RX FIFO の読み書きカーソル位置
- [0xB4] **PEEK_POS** [RW]：ピークする FIFO とバッファ位置
- [0xB8] **PEEK_VALUE** [RO]：PEEK_POS で指定された位置のワード
- [0xBC] **STATUS1** [RO]：ビット 0 のみ確認、バス上で通信できないことを示す？

## 一般動作

SPMI バスに SPMI コマンドを送信するために、32 ビットワードのバッチをTX FIFOにプッシュします。以下のすべての条件が満たされる必要があります：

- TX FIFO 内に完全で有効なバッチ TX FIFOが次のものとして存在
- RX FIFO に十分な空き容量
- バスが空いている
- CONFIG1 が非ゼロ値を持つ（？）

この条件を満たすと SPMI マスター側が TX FIFO からバッチを消費し、対応するフレームをバス上に送信し、RX FIFO にワードのバッチを書き込みます。FIFO内のワードバッチの一般的な構造は以下の通りです：

1. コマンドワード（TX FIFO）またはリプライワード（RX FIFO）
2. 0〜16 のデータバイト。リトルエンディアン順でワードにパックされ、結果は（必要に応じて）0〜4ワード
   - バイト数が4で割り切れない場合、末尾に必要に応じてバイトが追加されるため、最後のワードの上位 0..3 バイトは未使用（TX FIFO）もしくは 0（RX FIFO）

たとえば、5データバイトのバッチは以下の3ワードで構成されます：

~~~
+------------------------+  +--------+--------+--------+--------+  +--------------------+--------+
|   コマンド/リプライワード  |  | バイト3 | バイト2 | バイト1 | バイト0 |  |     未使用/ゼロ     | バイト4 |
+------------------------+  +--------+--------+--------+--------+  +--------------------+--------+
~~~

データバイト数は、コマンド/リプライワードの OPCODE フィールドによって完全に決定されます。
RX FIFO バッチ（リプライ）では、データバイト数は常に SPMI 入力フレーム数（例：レジスタ読み取りで要求されたバイト数）と一致します。ただし、TX FIFO バッチ（コマンド）では関係がより複雑で、以下を参照してください。

コマンドワードの一般的な構造は以下の通りです：

- [ビット0..7] **OPCODE**：8 ビットの SPMI コマンドオペコード。この値はバス上で送信される正確なオペコードと常に一致するわけではなく、場合によっては一般的なコマンドタイプ（例：レジスタ 0 書き込み、レジスタ読み取り）を識別するだけ（後述する SPMI コマンド参照）
- [ビット8..11] **SLAVE_ID**：4 ビットのスレーブアドレス
- [ビット15] **NOTIFY**：設定されている場合、このコマンドの完了時に NOTIFY 割り込みラインがアサート（後述する割り込み参照）
- [ビット16..31] **PARAM**：データバイトに含まれないオペコード依存の追加パラメータ用の 16 ビット領域

リプライワードの一般的な構造は以下の通りです：

- [ビット0..7] **OPCODE**：コマンドフレームで実際に送信された 8 ビットの SPMI オペコード（上記のように、コマンドワードの OPCODE フィールドと常に一致するとは限らない）
- [ビット8..11] **SLAVE_ID**：4 ビットのスレーブアドレス（常にコマンドワードと一致）
- [ビット15] **ACK**：SPMI コマンドに確認フレームが含まれる場合（基本的に読み取り以外のすべてのコマンド）、このビットはその値（スレーブが確認した場合 1）を保持し、そうでない場合は 0
- [ビット16..31] **PARITY**：このフィールドの下位 N ビット（N は SPMI コマンドに含まれる入力フレーム数であり、このワードに続くデータバイト数でもある）は、それらのフレームごとのパリティチェック結果（チェック成功なら 1）を保持し、残りは 0

ワードのバッチ全体はFIFOから/へのアトミックに消費およびプッシュされます。バッチの最初のワードが利用可能になると、他のワードを待つ必要はありません。

## SPMI コマンド

コマンド/リプライワードバッチの追加要件は、発行されるコマンドの種類に依存します。

### 単純コマンド

電源状態管理コマンド（reset, sleep, shutdown, wakeup）は追加パラメータを持たないため、PARAM フィールドは未使用です。コマンドまたはリプライにデータバイトは続きません。

### 基本レジスタアクセス

単一レジスタの読み書きコマンド（レジスタ読み取り、レジスタ書き込み、レジスタ 0 書き込み）の場合、PARAM フィールドは以下のように構成されます：

- [ビット0..7] **ADDRESS**：レジスタアドレス、0..0x1F（レジスタ 0 書き込みコマンドでは未使用）
- [ビット8..15] **VALUE**：書き込まれるレジスタ値（レジスタ読み取りコマンドでは未使用）

コマンドの OPCODE フィールドでは、この情報を指定するビットは無視され、PARAM の関連ビットに置き換えられます。コマンドにデータバイトは続きませんが、リプライには 0（書き込み）または 1（読み取り）のデータバイトが続きます。

### 拡張レジスタアクセス

複数のレジスタを一度に操作可能で、拡張レジスタアドレス空間へのアクセスも許可するコマンド（拡張読み取り、拡張書き込み、拡張読み取りロング、拡張書き込みロング）の場合、
PARAM フィールドはレジスタアドレス（拡張読み取り/書き込みでは 0..0xFF、拡張読み取り/書き込みロングでは0..0xFFFF）を保持します。

コマンド（書き込み）またはリプライ（読み取り）に続くデータバイト数は、OPCODE でエンコードされた読み書きされるレジスタ/バイト数です。

<!-- TODO: 他のコマンド -->

## FIFO

各 FIFO の容量は 64 ワードです。既知のすべてのバッチが最大 5 ワードであるため、コントローラは最悪の場合 12 個の未処理 SPMI コマンドを保持できます。

STATUS およびに CURSORS は TX FIFO に関する情報を下位ハーフワードで返し RX FIFOに関する情報を上位ハーフワードで返します。STATUS のハーフワードの構造は以下の通りです：

- [ビット0..7] **COUNT**：FIFO内のワード数。0..0x40
- [ビット8] **EMPTY**：FIFO が空の場合に設定。例：COUNT == 0
- [ビット9] **FULL**：FIFO が満杯の場合に設定。例：COUNT == 0x40

CURSORS のハーフワードの構造は以下の通りです：

- [ビット0..7] **WRITE_CURSOR**：次に入れるワードのバッファ位置。0..0x3F
- [ビット8..15] **READ_CURSOR**：次に消費するワードのバッファ位置。0..0x3F

両方のカーソルが等しい場合、FIFO は空または満杯のいずれかです。STATUS を使用して区別できます。

ACTION1 レジスタのビット 0 に 1 を書き込むと、両方の FIFO がクリアされます。

FIFO のバッファから任意のワードを読み取るデバッグ機構があります。PEEK_POS で読み取るワードを選択：

- [ビット8] **FIFO_IDX**：選択する FIFO（0 = TX、1 = RX）
- [ビット16..24] **CURSOR**：読み取るバッファ位置。0..0x3F

そして PEEK_VALUE は選択された位置の現在の値を返します。

## 割り込み

ADT にはいくつかの AIC 割り込みラインが記載されていますが、他のラインはすべての SPMI コントローラ間で共有されているように見えます。なので、2 番目のラインのみが重要と思われます。

マスク領域は `0x20..0x5F` にあり、それぞれのビットが対応するラインがマスクされていない場合は 1、マスクされている場合は 0 に設定されます。

ACK 領域は `+0x40` だけシフトされ、`0x60..0x9F` にあります。それぞれのビットは、対応するラインがトリガーされると 1 に設定され、そのビットに 1 を書き込むとクリアされます。

両方の領域に少なくとも 1 つのビットが設定されている場合、AIC ラインがアサートされます。
最初の 256 ライン（各領域の前半）は、バス上の参加者によってトリガーされるようです（SPMI の仕様ではこれに関するコマンドは指定されていません。マスター書き込みコマンドの可能性？）。
残りは、特定のイベントが発生したときにコントローラ自身によってトリガーされます。
なお、ラインをマスクしても、トリガーされること（および ACK 領域の対応するビットが 1 に設定されること）は防げません。

M3では以下のコントローラトリガー割り込みラインのみがマスク解除可能です：

- [ビット 0] **NOTIFY**：NOTIFY フラグ付きのコマンドが完了し、そのリプライが RX FIFO に入ったときにトリガー
<!-- space -->
- [ビット 4]
- [ビット 5]
- [ビット 6] **READ_FAIL_1**：読み取りコマンドがパリティチェック失敗で完了したときにトリガー
- [ビット 7] **ACK_FAIL**：（読み取り以外の）コマンドが完了し、スレーブによって確認されなかったときにトリガー
- [ビット 8]
- [ビット 9]
- [ビット 10]
- [ビット 11] **READ_FAIL_2**：読み取りコマンドがパリティチェック失敗で完了したときにトリガー
- [ビット 12]
- [ビット 13]
<!-- space -->
- [ビット 16]
- [ビット 17]
<!-- space -->
- [ビット 23]（`nub-spmiN` のみ）
- [ビット 24]（`nub-spmiN` のみ）
- [ビット 25]（`nub-spmiN` のみ）
- [ビット 26]（`nub-spmiN` のみ）
- [ビット 27] **FAIL**：RX FIFO が空のときにワードを消費しようとしたときにトリガー。他とは異なり、これはレベルトリガーされているようで、(PMGR リセット以外）クリア方法が見つからない
- [ビット 28]（`nub-spmiN` のみ）
- [ビット 29]（`nub-spmiN` のみ）
