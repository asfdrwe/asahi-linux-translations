[Progress Report: January / February 2021](https://asahilinux.org/2021/03/progress-report-january-february-2021/)の非公式日本語訳です。

まだ、作業中です。DeepLの結果を貼っただけ。

---
# 進歩報告:2021年1月2月
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202109.md)

第一回Asahi Linuxプログレスレポートへようこそ! このシリーズでは、Dolphinに習って、プロジェクトの進捗状況を毎月お伝えしていきます。

新しいシステム・オン・チップをLinuxでサポートすることは、簡単なことではありません。この連載が皆さんの勉強になり、新しいデバイスで
Linuxを動作させるための舞台裏を垣間見ることができれば幸いです。当初の予定では、1月と2月に分けて更新する予定でしたが、物事があまりにも
早く進みすぎて、区切りをつけるのが難しかったので、結局2ヶ月間の更新となりました。

### 用語の説明

本レポートでは、「AArch64」、「ARM64」、「ARMv8-A」という用語を使用しています。AArch64は64ビットARMアーキテクチャの命令セット、
ARM64はLinuxがサポートする64ビットARMの呼称、ARMv8-AはAArc64を含むARM CPUアーキテクチャの仕様です。それぞれ微妙に意味が異なりますが、
ここでは「64ビットARM」という意味で捉えていただければと思います

## すべての始まり

Asahi Linuxプロジェクトは、年初に正式に始動しましたが、その時点では、Apple Siliconシステムで代替カーネルを起動するためのAppleからの
サポートという、ある重要な要素を待っていました。この機能は文書化され、ほとんど実装されていましたが、最後に一つだけ足りないものがありました。
それは、Apple以外のカーネルをインストールするためのkmutil configure-bootコマンドのサポートです。ドキュメント化されていないプラット
フォームにOSを移植するための最初のステップは、ドキュメント化することなのですから。

Apple SiliconのMacは、PCとは全く異なる方法で起動します。その仕組みは、Android携帯やiOSデバイスのような組み込み型のプラットフォームに
近いものですが、独自の仕組みがいくつも組み込まれています。しかし、Appleはこの起動プロセスをIntel Macのそれに近づけるためにいくつかの手段を
講じており、実際の動作については多くの混乱が生じています。例えば、Apple Silicon Macでは、従来の意味での外部ストレージからの起動が一切
できないことをご存知でしたか？また、Apple Silicon Macのブートローダは、グラフィカル・ユーザ・インタフェースを表示することができず、
「Boot Picker」はブートローダの一部ではなく、実際にはフルスクリーンのmacOSアプリであることをご存知でしたか？

そこで私たちは、このマシンで独自のカーネルを実行する前に、ブートプロセスの仕組み、内蔵SSD上のパーティションやボリュームの配置、さらには
PCとの比較を明らかにしようとしました。このドキュメントは、私たちのプロジェクトに役立つだけでなく、自分のマシンがどのように動作するかを
理解したいと考えているmacOSユーザーにも役立つことを目的としています。この機能の一部とその根拠は、2021年2月版のApple Platform 
Security Guideに記載されています（すべてではありません）。

## 2つの世界の架け橋

アップルのシリコンMacは、既存の規格に基づかないブートプロセスを採用しています。これは、iOSデバイスの初期段階から徐々に進化してきた
アップル独自の仕組みです。一方、他の64ビットARMの世界では、2つの競合する規格にほぼ収束しています。UEFI + ACPI（主にWindowsや
Linuxが動作するサーバーで使用されています）と、ARM64 Linuxブートプロトコル + DeviceTree（小型システムで使用されており、U-Bootなど
でもサポートされています）です。Asahi Linuxではこれらのうちのどれかを選択し、Appleの世界と私たちの世界を「橋渡し」する方法を考えなければなりません。

UEFIやACPIは複雑で、通常は大型のARMシステムにしか使われません。UEFIとACPIは、大規模なARMシステムにしか使われない複雑な規格で、
UEFIフォーラムの委員会がその大部分を管理しています。同質性の高いx86 PCの世界とは異なり、ARMの世界は非常に多様で、システムオンチップには
あらゆる種類のデザインがあり、その中に含まれるハードウェアを記述するための要件も異なります。つまり、新しいSoCのサポートを追加するには、
ほとんどの場合、そのSoCをユニークにするハードウェアのビットに対応する「バインディング」を追加するために、これらの規格を修正する必要があります。
ACPIの場合、この作業にはコストと時間がかかるため、Windowsを搭載していない小型の組み込みシステムではACPIがほとんど使われていません。
私たちにとっては、実行可能な選択肢ではありません。

多種多様な小型の組み込み用ARM Linuxシステムでは、ほとんどの場合、DeviceTree規格が採用されています。例えば、ほとんどのAndroidデバイスは
この規格で起動します。ACPIテーブルがデータとコードの組み合わせであるのに対し、devicetreeは純粋にハードウェアを記述するデータの集まりで
あるため、devicetreeはACPIよりもはるかにシンプルです。最近では、デビセツリー・バインディングの権威は、Linuxカーネルツリー内のドキュメントに
なっています。つまり、Linuxドライバを作成すると同時に、この規格を修正することができるのです。つまり、Linuxのドライバを書くのと同時に規格を
変更することができるのです。

興味深いことに、アップルもアップルシリコン上では、アップルデバイスツリーという独自のデバイスツリーを使っています。これは、Apple Device Treeと
オープンなDeviceTree規格の両方が、古いMacを含む多くのPowerPCシステムのブート方法であるOpen Firmware仕様に基づいているからです。残念ながら、
ADTは組み込みLinuxの開発者にとっては非常に馴染み深いものですが、直接使用することはできません。バイナリ形式が異なるため、データが
何を表しているかという高度な情報がないと自動的に変換できないのです。その上、デバイスに使用される実際のバインディングも大きく異なります。
LinuxとmacOSはPowerPC Mac上では同じように動作し、直接の互換性がありますが、LinuxはARM分野では10年以上にわたってAppleとは異なる進化を
遂げてきました。AppleとLinuxのデバイスツリーの考え方を統一しようとすると、悪夢のようなことになります。

アップルの世界をデバイスツリーの世界に適応させるために、私たちはアップルのシリコンマシン用のブートローダ「m1n1」を開発しています。その目的は、
できるだけ多くの「Appleイズム」を解消し、Linuxやその他の下流のものができるだけ簡単に使えるようにすることです。

Linuxのカーネルにm1n1を前置し（最小限の固定カーネルのインストールには、
cat m1n1.macho initrd.bin devicetree.dtb Image.gz > m1n1-kernel.machoを使うだけ）、Appleのkmutilツールを使ってMacに
インストールすると、Linuxの起動に必要なすべてのことが行われます。m1n1を使ってLinuxを起動すると、だいたいこんな感じになります:

-     メインCPUを初期化し、正しく動作させるためのチキンビット設定を行います。
-    AppleのブートローダであるiBootから提供されたブート情報を読み込みます。RAMの空き容量やRAM内のフレームバッファ
（画面に表示されるビデオメモリ）のアドレスなどが含まれます。
- Memory management unitの初期化を行います。これは、CPUのキャッシュを使用するために必要なもので、これがないとすべての動作が非常に遅くなります。
- Apple ロゴに代わって Asahi Linux のロゴを画面に表示します。
- ウォッチドッグ・タイマーを無効にします。これがないと、起動プロセスが滞っていると考えて、1分ほどでMacが自然に再起動してしまいます。
- Linux カーネル、devicetree、（オプションで）起動時のアプリケーションが入った initramfs ラムディスクが追加されている場合は、
    それらを含めて起動するものを把握します。
- 他のすべてのCPUコアを初期化し、必要なチキンビットを適用して、Linuxが引き継げるように「スピンテーブル」に待機させます。
- Apple Device Treeから情報を取得し、提供されたdevicetreeテンプレートをそれに合わせてカスタマイズします。これは、
メモリサイズ、フレームバッファに関する情報、Linuxの乱数ジェネレータを初期化するためのシードなど、マシンやAppleのiBootファームウェアの
バージョンごとに変わる設定に使用されます。Linuxにジャンプしたり、次のステージに進むことができます。

スピンテーブル」とは、ARM版Linuxがデバイスツリーの世界で追加のCPUコアをオンにするために使用できる2つの規格のうちの1つです。
プラットフォーム固有のドライバに頼るのではなく、すべてのプラットフォームが使用することが期待される2つの標準的な方法が用意されています。
最もシンプルなスピンテーブルは、ブートローダがあらかじめすべてのCPUをオンにしておき、ループの中でCPUを待機させる（「スピンさせる」）だけの
ものです。このループからCPUを解放するために、LinuxはRAMに値を書き込み、どこでカーネルにジャンプするかを伝えます。唯一の制限は、CPUを完全に
停止させることができないことです。ブートローダからCPUを引き継ぐのは一度限りですから。しかし、他のメカニズムを使って様々な低電力モードに
することができます。今はこの方法を使っていますが、今後もこの方法が必要になる可能性があります。

PSCI」はARMの規格で、Linuxの実行中でもシステムのファームウェアが提供できる適切なサービスとして設計されており、CPU
（およびその他のコンポーネント）を実行時に制御できるようになっています。通常は、「EL3」で動作するコード（セキュアなファームウェア、
またはTrustZone）、または「EL2」で動作するVMハイパーバイザーを介して行われ、OSは通常「EL1」で動作します。しかし、EL3もEL2も
ARMv8-AのCPUのオプション機能であり、結局、M1にはEL3のサポートはありません。EL2はありますが、Linuxで動作するVMをサポートしたいので、
Linux自体をEL2で動作させる必要があり、その上に他のハイパーバイザーを置くことはできません。PSCIには標準的なインターフェースが存在しないため、
現在はPSCIを使用することができません。近い将来、PSCIを使用できるような代替メカニズムが開発されるかもしれません。これは、フルシステムの
スリープモードをサポートするために必要になるかもしれません。しかし、きめ細かな電源管理が十分であれば、非常に良好なバッテリー寿命を得るために、
「真の」フルシステムのスリープは必要ないかもしれません（最近のデバイスは、きめ細かなスリープモードで非常にうまく機能します）。
時間が解決してくれるでしょうし、この分野はまだ発展途上です。

さて、devicetreeを使うと言いましたが、UEFIを使えないわけではありません。ARM64システムは、UEFI＋devicetreeを使って起動することができます。
これは、GRUBのようなブートローダや、カーネルのインストールやアップグレードのための典型的なフローを使って、「PCライク」なブート体験を
得るために必要です。しかし、m1n1はそれらを一切サポートしていないので、どうすればいいのでしょうか？ありがたいことに、パズルを完成させる
もう一つのピースがあります：U-Bootです。U-BootはLinuxカーネルのように起動できるので、m1n1からU-Bootを起動することができますし、
U-Boot自体がGRUBやLinuxのための十分なUEFI環境を提供することができます。

というわけで、エンドユーザーが使うAsahi Linuxのブートチェーンは、おそらく次のようになるでしょう。

m1n1 → U-Boot → GRUB → Linux

これにApple固有のブートチェーンが加わると、ブートプロセス全体は以下のようになります:

- コールドブート時には、M1 SoC内のSecureROMが起動し、NORフラッシュからiBoot1をロードします。
- iBoot1は内蔵SSDのブート構成を読み込み、システムブートポリシーを検証し、起動する「OS」を選択します。
私たちの場合は、Asahi Linux / m1n1がiBoot1にとってOSパーティションのように見えます。
- iBoot2は「OSローダー」であり、起動先のOSパーティションに常駐する必要があります。内蔵デバイスのファームウェアのロード、
Apple Device Treeの設定、Mach-Oカーネル（私たちの場合はm1n1）の起動を行います。
- m1n1はADTを解析し、さらにデバイスをセットアップしてLinuxらしくし、FDT（Flattened Device Tree、バイナリのデバイスツリー形式）を
セットアップし、U-Bootを起動します。
- U-Bootは、内蔵SSD用のドライバを持ち、その設定と次のステージを読み込み、m1n1からのdevicetreeの転送を含むUEFIサービスを提供します。
- ディスクパーティションから標準のUEFIアプリケーションとして起動するGRUBは、どのPCでもGRUBのように動作します。これにより、
ディストリビューションは、grub-mkconfigや/etc/default/grubなどを使って、私たちが慣れ親しんだ方法でカーネルを管理することができます。
- 最後に、m1n1からずっと渡されてきたdevicetreeが動作に必要な情報を提供することで、Linuxカーネルが起動します。

ふぅ～。PCの世界から来た人にはちょっとクレイジーに見えるかもしれませんが、このような長いブートチェーンは組み込みシステムでは一般的です
（実際、一般的なPCの「UEFI」には複数のステージが含まれていますが、エンドユーザーには見えていないだけです）。例えば、DragonBoard 410c
（Qualcommベースのプラットフォーム）のブートチェーンは以下のようになります。

PBL → SBL → QSEE → QHEE → LK → U-Boot → GRUB → Linux

iBoot2を置き換えることはできませんが（Appleの署名が必要です）、エンドユーザー向けのインストールプロセスでは、iBoot2と必要な
サポートファイルを含む最小限の「macOS」を自動的にセットアップし、Appleのブートプロセスが起動可能なOSとして認識できるようにします
（ただし、実際のmacOSカーネル／ファイルシステムは含まれません）。インストーラはまだ準備ができていないので、当面の間、m1n1/Linuxを
試している開発者は、完全なmacOSを別途インストールして、そのカーネルを置き換える必要があります。私たちは、この冒険に参加したい方のために、
ステップバイステップのクイックスタートガイドを書きました。

今のところ、私たちの主な開発ワークフローは、m1n1 から直接 Linux をロードすることですが、Mark Kettenis は U-Boot や OpenBSD の
サポートについて私たちと一緒に作業しています。

しかし、m1n1はLinuxを実行するためだけのものではありません。実際には、本質的にはブートローダですらないのです。

## ハードウェアで遊ぶ

m1n1は、私がNintendo WiiのセキュリティCPUのために書いたミニマルな環境であるminiにまで遡ります。これは、実験やBootMiiのバックエンドと
して役立ちました。Wiiをお持ちの方でWiiに詳しい方は、BootMiiメニューを表示している間、miniがARM CPU上で動作しています。

それがApple Siliconのブートローダと何の関係があるのか、あなたは尋ねるでしょうか？miniは、外部のライブラリや依存関係なしにベアメタルの
32ビットARMシステム上で動作する、とてもシンプルなソフトウェアです。ベアメタルのコードを作るのに適したシンプルなベースになるので、
AArch64とApple Siliconに移植して、m1n1と改名しました。しかし、それよりも重要なのは、miniとm1n1には仕掛けがあることです。メインCPUから
制御する必要のある別のプロセッサ上で動作するファームウェアとしてのminiのレガシーと、過去のWiiハードウェア研究の実験のおかげで、miniは
シリアルポート上で動作するRPCプロキシを内蔵しています。つまり、開発用コンピュータからminiとm1n1をリアルタイムに「リモートコントロール」
することができるのです。m1n1では、任意のコンピュータ上で動作するシンプルなPythonスクリプトや、対話型シェルからでもM1ハードウェアを操作する
ことができます。m1n1は、Linuxブートローダを搭載したハードウェア実験ツールと言っても過言ではありません。

これにより、ハードウェアについての知識を深めたり、Apple独自の機能を発見したりするのに最適なプラットフォームとなります。例えば、この
スクリプトでは、x86 固有の浮動小数点構成ビットのサポートを CPU に追加し、Rosetta x86 エミュレーションを高速化するために使用する 
Apple の特別な機能をテストします。このスクリプトは、すべてのAppleカスタムCPUレジスタを検索し、その値とアクセス制限を表示します。
このスクリプトは、Appleが独自に開発したハイパーバイザーの設定レジスタによって、それらのアクセス制限がどのようにカスタマイズできるかを
自動的に把握します。そしてもちろん、このスクリプトは、シリアルポートから直接ストリーミングでLinuxカーネルを起動します。

M1のMac Miniをm1n1で起動するのにかかる時間は約7秒で、これらのスクリプトはすべて（マシンをクラッシュさせるまで）再起動せずに
インタラクティブに実行できます。m1n1は自分自身をロードすることもできるので、m1n1自体の開発サイクルも非常に高速です。

m1n1を使って、AppleのカスタムARM命令、Apple固有のシステムレジスタ、Apple Interrupt Controllerなどのハードウェアのドキュメント
作成に励んでいます。

今後もm1n1に機能を追加し、より強力な研究ツールにしていきたいと考えています。特にエキサイティングな目標は、m1n1を非常に薄いVM
ハイパーバイザーにして、macOSを起動し、そのM1ハードウェアへのアクセスをインターセプトすることです。これにより、Appleのドライバーが
どのように動作するかを、分解することなく調査することができます。この方法は、nouveauがNvidiaのGPUのリバースエンジニアリングに
成功したのと同じだと思う人もいるかもしれない。

でも、これをやるには、シリアルポートが必要です。M1マックのシリアルポートはどこにあるの？よくぞ聞いてくれました。

## そうだよ、UARTだよ

新しいシステムで低レベルの立ち上げ作業を行うには、シリアルポートが必要不可欠です。シリアルポートは、UARTポートと呼ばれることもありますが、
実質的には最もシンプルな通信ハードウェアであり、低レベルのデバッグツールとして非常に便利なものです。シリアルポートを使ってメッセージを
送信するには、数個のCPU命令が必要なだけなので、早い段階でセットアップして、開発用のテキスト端末として利用することができます。

もちろん、最近のPCにはRS-232シリアルポートが搭載されていましたが、それはもう昔の話です。多くの組み込みシステム（家庭用ルータなど）では、
低電圧のシリアルポートが内部に存在していますが、コネクタや基板上のテストポイントにアクセスするにはケースを取り外す必要があります。
M1マックの場合は？

M1 Macの場合は、ケースの外側にあるUSB-Cポートの上にシリアルポートがあることが判明しました。ただし、シリアルポートを有効にするには、
USB-PDで特別なコマンドを送信する必要があります。USB-PD（USB Power Delivery）は、Type Cポートの "Configuration Channel "
ピン上で動作するプロトコルです。電圧の設定や充電器の識別だけでなく、ケーブルの種類やドングルの識別、DisplayPortなどの代替モード、
そして今回はApple独自の設定メッセージのチャンネルとしても使用されています。これらのメッセージは、ある特定のType Cポートの2本のピンに
シリアルポートを露出させるようにMacに要求することができます。他にも、リモートでシステムを再起動したり（高速開発には欠かせない）、
DFUリカバリーモードにしたり、I²Cなどの内部バスにアクセスしたりすることができるなど、優れた機能を備えています。

これらのMacでシリアルポートを使えるようにするための最初の解決策はvdmtoolでした。それは、Arduino、USB-PD PHY（インターフェース）
チップ、そしてある種の1.2Vシリアルポートアダプターを使ったDIYケーブルです。これはDIYが得意な人にはいいかもしれませんが、自分で
ハードウェアを作ることに慣れていない人にはあまり実用的ではありません。必要なType C信号をすべて備えた優れたUSB-PD PHYブレイクアウト
ボードがない、1.2VのUARTアダプタが少ないなど、いくつかの問題点があります。

そこで、私たちは2つ目の解決策を考えました。もしあなたが2台のM1 Macを持っているなら、喜んでください。必要なのは、標準のType Cケーブル
（SuperSpeed / USB 3.0タイプ）とmacvdmtoolです。この小さなmacOSアプリを使えば、1台のM1マシンをもう1台のシリアルデバッグ端末に
することができ、m1n1スクリプトを実行したり、LinuxカーネルをmacOSから直接起動したりすることができます。AppleのAPIにより、Mac自身の
ポートをシリアルモードに設定したり、リモートのMacをシリアルモードに設定するために必要なメッセージを送信したりすることができるので、
カスタムハードウェアを一切使用せずにこれらのことが可能になります。

しかし、Macをもう一台買うとなると、シリアルケーブルはかなり高価なものになってしまいます。そこで私たちは、M1 Mac用のシリアルアダプターと
してだけでなく、その他の機能も充実させたUSB-PDデバッグケーブルを、オープンハードウェアプロジェクトとして開発することにしました。実際には、
Macだけでなく、多くのAndroid携帯電話など、他の機器のデバッグインターフェースとしても使えるようになるでしょう。また、USB-PDの開発
プラットフォームとしても機能し、一般的なソース（電源）やシンク（電力消費）などの役割を果たすことができ、USB-PDの充電器やデバイスの
実験を行うことができます。まだ計画段階ですが、最新情報をお届けします。最終的には、誰もがボタンをクリックするだけで購入できるように、
広くコミュニティに提供することを目標としています。

最後に、ハードウェアのシリアルポートは、低レベルのデバッグや開発に最適なソリューションですが、制限があります：最高でも150kB/sと
かなり遅いのです。M1 Macは、通常のUSBデバイス（iPhoneなど）として動作することができ、ほとんどのOSでドライバーなしで動作するUSB
シリアルデバイス（CDC-ACM）として表示させることができます。これにより、USBの全帯域幅を利用できるだけでなく、通常のType Cケーブル
（またはType C-Type Aケーブル）を使って他のコンピュータから接続できるという利便性が得られます。また、USBにはフローコントロール
機能があり、受信側がデータを受け入れる準備ができていない場合でも、データが失われることはありません。この方法の欠点は、より複雑な
ドライバーコードを必要とするため、本当に低いレベルの問題を解明するのには適していないことです。MacのType Cポートは、UARTシリアル
信号とUSB信号の両方を同時にサポートしています。帯域幅とパフォーマンスの向上は、前述のハイパーバイザーの開発に着手する際に非常に
役立ちます。また、現在シリアル帯域幅がボトルネックになっているLinuxカーネルのロードも格段に速くなります。このサポートは数週間以内に
m1n1に導入される予定ですので、ご期待ください。

## ペンギンスへの道

これらのツールはどれも素晴らしいものですが、私たちの目的は結局のところLinuxを動かすことです。では、新しいプラットフォームにLinuxを
移植するにはどうすればいいのでしょうか？もちろん、全体の大部分は新しいドライバを書くことですが、その前にやるべきことがあります。
これを「ブリングアップ」と呼んでいます。

ブリングアップが非常に重要なのは、OSの他の部分がマシン上で動作するための基礎を作るからだけではなく、マシン固有の機能がどのように
動作するかの基準を設定することでもあります。ブリングアップは、OSの最も深い部分に関わる低レベルのコードであり、一般的なドライバとは
異なり、他のプラットフォームと共通するLinuxの部分に変更を加える必要があることが多い。そのため、サブシステムを担当するLinuxの
メンテナと調整し、適切な方法でアプローチすることが必要です。

例えば、初期のM1サポートパッチセットでは、SPARC64アーキテクチャのサポートに関連するファイルを変更しなければなりませんでした。
Linux開発の特徴として、Linuxカーネルには安定したドライバAPI/ABIが存在しないことが挙げられます。つまり、Linuxカーネルの
内部設計は、時間をかけて継続的に改善やリファクタリングが行われています。つまり、あるアーキテクチャで何かをサポートするために、
他のアーキテクチャをクリーンアップしたり変更したりする必要がある場合、そうすることは完全に実行可能であり、しばしば最良の方法
であると言えます。一方で、Linux のフォークや、上流のカーネルに含まれていないサードパーティのドライバを保守することは非常に
難しいことでもあります。

朝日リナックスでは、単にLinuxをApple Siliconに移植するだけでなく、コミュニティ主導のオープンなプロジェクトとして、Linux
コミュニティ全体と協力して、我々の作業を公式のLinuxカーネルにアップストリームすることを目指しています。というのも、自社の
ハードウェアにLinuxを移植する企業の多くは、製品開発の締め切りに追われ、結局、Linuxのフォークを作り、そこですべての開発を行い、
上流のコミュニティから切り離されてしまうからです。そして、その変更を正式なLinuxカーネルにアップストリームしようと思ったときには、
2つのフォークが大きく乖離していて、マージするのは悪夢のような状態になっているのです。また、設計上の決定は、Linux全体の理念に
反しており、アップストリームでは受け入れられないかもしれません。結局、多くのコードが書き直され、長期的な持続性よりも短期的な
結果を追求することで、多くの開発時間が無駄になってしまいます。

このような事態は絶対に避けたいので、私たちは早い段階でアップストリームを行い、初日からコミュニティ全体と協力していくという
アプローチをとっています。そのために、私たちは上流のLinuxメンテナと一緒に仕事をしていますし、実際、Linuxの主要な人たちが
Asahi LinuxのIRCチャンネルに集まっています。

Linuxがどのようなシステムでも起動できるようにするには、絶対に正しく動作する必要がある5つの要素があります。

- CPU
- メモリマネジメントユニット（MMU）
- 割り込みコントローラ
- システムタイマー
- ある種のコンソール（ここではシリアルコンソール

ほとんどのAArch64システムでは、最初の4つは非常に標準的なものです。Linuxは、基本的なコンソールが使えるようになるまで、
実質的に何の変更も必要ありません。しかし、AppleのSoCは独自のやり方を好むので、私たちはかなりの作業を強いられました。

## 電源を切ってもう一度入れる

現在のCPUは、80年代や90年代の設計と比べると、技術的に驚異的なものです。当時のCPUの仕事は、単純な演算、メモリの読み書き、
意思決定を、1つ1つ順番に、止まることなく行うことだけでした。パワーマネジメントもキャッシュもマルチコアもなく、浮動小数点数の
サポートもほとんどありませんでした。

時代は変わり、現在のCPUはますます高性能になり、同時に消費電力も少なくなってきています。どうやってそれを実現しているのでしょうか。
それはもちろん、ICの製造技術の向上によるものです。もうひとつは、CPUの設計が大幅に進歩したことです。最近のシングルCPUコアは、
複数の命令を同時に実行したり、未来を予測して物事を先に進めたり、予測が間違っていたら元に戻したり、最近使用したデータや近日中に
使用されると予測されるデータのコピーを保持したり、さらには電力を節約するために自分自身の一部を動的にオン/オフすることもできます。

しかし、このような複雑さには2つの問題があります。それは、予期しない機能と、明らかなバグです。最近のOSでは、このようなCPUの細かい
部分まで管理する必要がありますし、アプリケーションソフトでも、CPUが壊れてもいいような前提条件をつけないように注意する必要があります。

90年代にパソコンを使っていた方は、Windows 95やWindows 98の特徴を覚えているかもしれません。これらのOSを新品（当時）のパソコンで
使うと、どんなにパソコンを使わなくても、CPUの温度がかなり上昇し、その状態が続いた。これは、これらのOSが、何もしないでいると、CPUを
無限ループさせてしまうからである。何もしていなくても、CPUの100％が常に使用されていたのです。昔のCPUには「アイドル」という概念が
ありませんでした。有用な仕事をするためにCPUを使っていなければ、時間を無駄にするためにCPUを使っていたのです。パワーマネジメントも
ありませんでしたから、CPUにしばらく何もしないように指示しても、電力は節約できませんでした。

もちろん、今日、私たちは、アイドル状態のCPUがビジー状態のCPUよりも電力を節約できるという考えに慣れています。これは、何もすることが
ないとき、OSがCPUにある程度の動作停止を指示して、外界からのイベント（何かをしなければならないという信号）を待つことができるからだ。
Windows 95時代には、HLTを無限ループで実行する「CpuIdle」というプログラムがあり、使用していないときにCPUを低電力モードにして、
エネルギーを節約し、CPUの温度を下げることができた。最近のOSにはこれが組み込まれており、ARMのCPUは「WFI」（Wait For Interrupt）と
いうCPU命令を使って同じ仕組みを実装しています。

最近のCPUは、HLTやWFIを呼び出すと、単に命令の実行を停止するだけでなく、実際にコアの一部をパワーダウンさせて、さらに電力を節約することが
できます。クロックを停止させることを「クロックゲーティング」、パワーダウンさせることを「パワーゲーティング」といいます。しかし、
パワーゲーティングを行うと、CPUは電源を切った部分に保存されているデータを失ってしまうという問題があります。重要なデータは、電源が
入っている回路に置くか、電源が入っているバックアップストレージに移す必要があります。通常、これらの命令によって目に見える形でデータが
失われることはありません。CPUは必要のないデータを捨てることはあっても、ソフトウェアが作業しているデータが失われないように注意します。

M1でLinuxがなんとなく起動している状態になったとき、起動プロセスが終わるとすぐにクラッシュしてしまいました。実際、WFI命令を実行した
直後にクラッシュしたようだ。正しく呼び出した関数に戻るのではなく、ゼロアドレスにジャンプしていた。何が起こっているのでしょうか？

その結果、M1はデフォルトで、WFIがクロックゲートとパワーゲートのどちらかを行うモードで動作します。実際には、ある種の自動
ヒューリスティックな手法を用いて、どちらを使用するかを選択します（素晴らしい！）。残念なことに、パワーゲートを決定すると、
スタックポインタとプログラムカウンタを除くすべてのCPUレジスタの内容が失われます。Linuxはこのような事態を想定していません。
他のすべてのAArch64 CPUはこのようなことをしないので、これはLinuxに追加するにはかなり厄介なパッチになります。Linuxには、
特定のSoCがWFIアイドルループを別のものに置き換える仕組みがありません。

ありがたいことに、私たちはCPUのApple独自のレジスタを文書化し、CPUを正しく動作させるために必要な鶏のビット配列に取り組んだ結果、
この動作を無効にしてWFIをパワーゲートさせないようにし、Linuxを正しく動作させるために使用できる特定のレジスタがあることがわかりました。
このレジスタをm1n1で正しい値に設定するだけで、問題は解決しました。これは最高の修正方法です。m1n1が問題を解決し、Linuxのパッチは必要ありません。

これがシステムの電力効率に影響するかどうか気になるかもしれません。恐れることはありません。M1のパワーゲーティング機能を
利用できないわけではありません。Linuxはcpuidleと呼ばれるサブシステムにより、より深いCPU省電力モードをサポートしています。
このサブシステムのドライバは、CPUの状態を失わせても、それを回復する方法を知っていれば問題ありません。したがって、私たちがすべきことは、
M1 をパワーゲーティングモードに戻す cpuidle ドライバを書き、ドライバ内で直接 WFI を実行し、CPU の状態を回復してから、Linux の
コアコードに戻ることです。Linux流のCPUパワーセーブです。

これは、私たちの開発アプローチの重要な部分です。ドキュメント化されていないデバイスを扱う場合、オリジナルのソフトウェア（macOS）と
同じことをするのは簡単です。しかし、他のOSやファームウェアの動作方法が、必ずしもLinuxに最適なモデルであるとは限りません。むしろ、
システムの細かい部分を理解することを優先し、その上でLinuxでの活用方法を決めていきたいと考えています。もし、関連するCPUレジスタを
調査せずに、macOSと同じこと（メインCPUのアイドルループでパワーゲーティングモードをサポート）をしていたら、より厄介なLinuxパッチに
なっていたでしょうし、よりクリーンな方法で行う機会を逃していたでしょう。時間はかかりますが、それだけの価値があると思います。

Linuxを起動している間に見つけたCPUの驚きはこれだけではありませんでしたが、残念ながらその話は後回しにすることにします...では、
次のパートに移りましょう：メモリ管理です。

## 未配達の郵便物が送信者に返送されました。

Linuxを最初に立ち上げるとき、起動プロセスのフィードバックを早期に得られることは、デバッグのために非常に重要です（私たちは
ハードウェア・デバッグ機能を持っていません - Appleの製品デバイスでは利用できないのです）。前述のシリアルポートは、文字を送信するのに
数個のCPU命令を必要とするだけで、UARTハードウェアのレジスタに文字を書き込むことができるので、この点で優れています。Linuxには
earlyconという機能があり、メインのシリアルポートドライバが立ち上がる前に、通常のLinuxのprintk()関数を動作させることで、この
問題を解決することができますが、残念ながら、最初のテストではそこまではできませんでした。この状況は、Linuxの一番最初のARM64起動
コード（アセンブリで書かれている）にパッチを当てて、特定のポイントで文字を出力するようにして、どこが壊れているのかを探すゲームになりました。

その結果、シリアルポートは、メモリ管理ユニットをオンにするところまでは動作することがわかりました。メモリ管理ユニットは、UARTデバイスへの
アクセスを含め、メモリへのアクセス方法を変更するため、これはかなり残念な状況ですが、MMUが設定され、最終的に一発でオンになるため、
このような問題のデバッグは非常に困難です。MMUは設定してから一発で電源を入れてしまうので、その時に問題が発生しても、どこに問題が
あるのか分からないのです。

しかし、非常に長いデバッグセッションの間に（結局、代替のフィードバックメカニズムとして、Linuxカーネルブートの進捗状況を示すために、
ディスプレイフレームバッファの上部を異なる色で塗るコードを追加することになりました）、Linuxが実際にブートし続けており、すべての
アセンブリコードを通り越して、実行中のCコード、さらにはearlyconシリアルポートドライバにまで及んでいることが明らかになりました。
しかし、シリアルポートからは何も送られてきません。まるで...我々が投げかけたものを全て無視しているかのようだ。アドレスは正しく、
メモリのマッピングも正しいのですが、何も出てきませんでした。

それは、M1がデバイスのメモリ管理に異常にうるさいからだとわかった。

メモリ管理ユニットは、最新のOSカーネルが行うことの中心となるものです。実行中のプロセス同士の隔離、仮想メモリ
（スワップファイル／パーティション）の管理、ディスク上のファイルのメモリへのマッピング、スレッドやプロセス間のデータ共有などを
可能にするCPUの一部です。複数の仮想メモリアドレス空間（アプリケーションやカーネルが持つメモリアドレスの概念）を物理アドレス空間
（システム内のハードウェアの実際のメモリアドレス）にマッピングする役割を担っています。ここでいう「メモリ」には、実際のRAMだけでなく、
MMIO（Memory-Mapped I/O）として表示されるデバイスも含まれます。UARTはMMIOデバイスです。

ほとんどのプラットフォームでは、通常のメモリとMMIOが区別されています。通常のメモリ（すなわちRAM）は、書き込まれたデータを後で
読み返したときに必ず戻ってくるなど、ある種の合理的な振る舞いをすると想定できます。しかし、デバイスはMMIOを使ってコマンドを受け取り、
ステータスやデータをソフトウェアに返すので、通常のRAMのようには振る舞いません。CPUは、通常のメモリアクセスの順番を変えたり、
キャッシュしたりすることができますが、MMIOのアクセスにそれをしてしまうと、すべてが壊れてしまいます。ドライバーは、デバイスとの
データの送受信を正確にコントロールすることに依存しているからです。MMUはこの区別を担当しており、カーネルはメモリの断片を通常の
メモリとして設定したり、デバイスメモリとして設定したりします。

しかし、最近ではもっと複雑になっています。アクセスパーミッションがあったり、キャッシュモードが違ったり、デバイスメモリの種類が
違ったりします。AArch64では、デバイスメモリのマッピングに4つのモードがあります。GRE、nGRE、nGnRE、nGnRnEです。G、R、Eは、
システムができること、できないことを表しています。

- 複数の書き込みを1つの書き込みにまとめる。例えば、CPUは隣接する2つの8ビットの書き込みを1つの16ビットの書き込みにすることができます。
- 書き込みの順序変更。異なるアドレスに2つの値を連続して書き込んだ場合、CPUはそれらを逆の順序で書き込むことを決めるかもしれません。
- 書き込みの早期完了。システムは、データがターゲットデバイスに到達する前に、CPUにメモリへの書き込みが完了したことを伝え、CPUは
その完了を待たずにコードを実行することができます。これは、x86の世界では「posted write」とも呼ばれています。

ほとんどのドライバーやデバイスは、ライトギャザリングやリオーダリングを有効にすると壊れてしまうため、これらのモードは非常に特殊な
ドライバーを除いてほとんど使用されていません。しかし、早期書き込み完了は、PCIの仕様で義務付けられているため、実際にはPCの標準と
なっています。そのため、ほとんどすべてのドライバがこれを考慮して書かれています。このため、AArch64 Linuxでもデフォルトでは、
すべてのI/OメモリをnGnREとしてマッピングし、早期書き込み完了を有効にしています。他のデバイスでは、これで問題ありません。
そのようなデバイスの多くは、ポストライトをサポートしていないかもしれませんが、その場合は単にアクセスをnGnRnEとして扱います。
デバイスは、ソフトウェアが要求するよりも厳しい保証を提供することが常に許されており、少なくともソフトウェアが要求するのと同じように
デバイスが厳密に動作するのであれば問題はありません。

調べてみると、M1の内部バスファブリックは、すべてのアクセスがnGnRnEモードで行われることを積極的に強制していることがわかりました。
nGnREモードを使おうとすると、書き込みは中止され、代わりにシステムがSError（システムエラー）を通知します。当初、このSErrorsは
表示されていませんでしたが、これは別のプロジェクトから不注意に持ち込まれたCPUの設定により、エラー報告が誤って無効になっていた
ためです（ただし、UARTが壊れていたため、私たちもエラーを確認することはできませんでしたが、少なくとも、UARTの書き込み後にシステムが
動作を停止し、静かにドロップして続行することはなかったはずです）。

賢明な読者の皆様は、ここで興味深い内容にお気づきかもしれません。M1 SoCにはPCIeが搭載されているのです。実際、いくつかの内部デバイスは
PCIeデバイスであり（Mac MiniのEthernetなど）、Thunderboltのおかげで、M1 MacはあらゆるPCIeデバイスに接続することができます。
ポストライトは使わないの？その通りです。実際、M1ではPCIデバイスにnGnREマッピングを必要とし、nGnRnEの書き込みを拒否します。

これには難問があります。Linux には、メモリを nGnRnE としてマッピングするためのフレームワークがありません。どこでもnGnREモードの
代わりにnGnRnEを使用するような一回限りの癖を導入することはできますが、そうするとnGnREを必要とするPCIeデバイスをサポートすることが
できなくなります。私たちは、nGnRnEとしてメモリをマッピングするための完全に特注のメカニズムを開発しなければなりませんでした。そして、
PCIドライバがnGnREモードを使用することを可能にしながら、Apple Siliconプラットフォーム上の非PCIデバイスにそれを使用するように
Linuxに指示する方法を開発しなければなりませんでした。そして、既存のコードを邪魔しないことと、他のApple以外のデバイスに役立つ可能性の
バランスをとり、これらのサブシステムを担当するメンテナと合意できるような、クリーンでよくできた方法でそれを行う必要がありました。

最終的には、複数のサブシステムと複数のパッチリビジョンにまたがるカーネルのメンテナと数週間にわたって議論を重ねた結果、ほぼこの方法に落ち着きました。

- ioremap_np()の紹介です。Linuxは通常、すべてのアーキテクチャにおいて、MMIOデバイスのメモリをマッピングするために汎用のioremap()関数を
使用します。ioremap_wt()のように、それほど厳密ではない他のモードのための特別なバリアントがあります。私たちは、ポストされないメモリ・マッピングを
特に要求する新しいバリアントを追加します。
- ARM64でnGnRnEモードを使用するためにioremap_np()を実装しました（他のアーキテクチャでは今のところこのバリアントを実装しませんが、
便利だと思ったら実装してもいいでしょう）。
- nonposted-mmio devicetreeプロパティの導入。これを使って、デバイスツリーの特定のバスに ioremap_np() が必要であることを示すことができます。
- Linuxのデバイスツリーサブシステムが、デバイスを検索するときにnonposted-mmioモードを自動的にピックアップして、MMIOリソースを記述する
構造体のフラグ（IORESOURCE_MEM_NONPOSTED）に変更しました。
- devm_ioremap_resource()とof_iomap()の2つの高レベルAPIで、このフラグを自動的に解釈してioremap_np()に「アップグレード」するようにしました。
- M1 SoCで使用する必要のある既存のドライバがまだ使用していない場合は、生のioremap()の代わりにこれらのAPIのいずれかを使用するように調整します。

ioremap()を直接使用しているドライバについては、若干のドライバのリファクタリングが必要ですが、これはM1に組み込まれているハードウェアに
対してのみ必要なので、変更が必要なドライバはごくわずかです。最近では、PCIドライバの大部分が生のioremap()を使用しており、その全てが
Thunderboltアダプタを介してM1コンピュータで使用することができます。これらのドライバを変更する必要はなく、nGnREモードを要求するデフォルトの
ioremap()が適切に動作します。

この変更の一環として、Linuxの様々なioremap()モードに関するドキュメントが非常に不足していることに気がつきました。Arnd Bergmann氏と協力して、
これらの不足しているドキュメントを追加しましたので、こちらをご覧ください（変更が上流にマージされたら、こちらにも追加されます）。

興味深いことに、この変更は一般的な「simple-bus」デバイスに適用されるため、DeviceTreeのコア仕様とそのスキーマにパッチを提供しなければ
なりませんでした。ありがたいことに、DeviceTreeはコミュニティ主導のオープンなプロジェクトなので、必要なのはGitHub PRを2つほど作成することだけです。

## ほら、AICだから

現代のCPUの仕事は、命令を順番に実行するだけでなく、環境の変化に対応して、実行していることをやめて別のことをしなければならないこともあります。
これを「例外」と呼びます。高レベルのプログラミング言語では、これらはある種のエラーとして知られているかもしれませんが、CPUでは、外部からの
注意の必要性を示すためにも使用されます（POSIXユーザースペースプログラムのSIGCHLDやSIGALRMなどのシグナルに似ています）。

その中でも最も重要なのが割り込み要求（IRQ）で、ハードウェア周辺機器がCPUの注意を喚起するために使用します。CPU は OS コードを実行して、
どの周辺機器が注意を必要としているかを判断し、要求を処理します。

AArch64のCPUでは、IRQの入力は1つです。つまり、システム内のすべてのデバイスからの割り込み要求をまとめて、（OSが設定した）正しいCPUコアに
分配し、IRQが発生したときにどの基本デバイスに注意を払う必要があるかをOSに伝える必要があるのです。これが、Linux用語で「irqchip」と
呼ばれる割り込みコントローラの仕事です。

複数のコアを持つシステムでは、IRQコントローラーには、プロセッサ間割り込み（IPI）を処理するという別の仕事もあります。あるコアで動作している
ソフトウェアが、別のコアの注意を引きたい場合があります。IPIはこれを可能にします。割り込みコントローラは、あるコアが割り込みコントローラに
要求を送り、その要求を割り込みとして別のコアに転送するようなメカニズムを提供します。IPIがなければ、マルチコアシステムは正常に動作しません。

ほとんどのAArch64システムでは、GIC（Generic Interrupt Controller）と呼ばれる標準的な割り込みコントローラを使用しています。
これはかなり複雑で、割込みの優先順位や仮想化などの高度な機能を備えた割込みコントローラです。これにより、LinuxはほとんどのAArc64システムで
メインの割り込みコントローラとして独自のirqchipsを実装する必要がなくなるので、とても便利です。

もうお分かりだと思いますが、Appleは独自の道を歩むことにしました。独自のカスタムApple Interrupt Controller (AIC)を持っているのです。
私たちは、このハードウェアをリバースエンジニアリングし、それをサポートするためにLinux用の独自のirqchipドライバを構築しなければなりませんでした。
ありがたいことに、AICは非常にシンプルなものです。macOS/iOSのオープンソース(XNU)に存在する数少ない古いドキュメントを利用し、試行錯誤
しながらハードウェアを調査することで、割り込みを動作させるために必要なことをすべて把握し、Linuxドライバを書くことができました。

しかし、そこにはもう一つの問題がありました。Linuxが正常に動作するためには、IPIが必要です。具体的には、Linuxは7種類のIPIを使用しています。
つまり、7種類の独立した要求をあるCPUコアから別のCPUコアに送信し、それらを別々のイベントとして扱うことができることを期待しているのです。
AArch64システムで使用されている他のIRQコントローラは、このような細かいIPIの分離をサポートしています。残念ながら、AICは
そうではありません。AICは2つのIPIしかサポートしておらず、実際にはこれらを異なる方法で使用するように設計されています（1つは他のCPUに
送信するためのもので、もう1つはあるコアから自分自身への「セルフIPI」のためのもので、これは時々必要になります）。これをLinuxで実現する
ためには、「仮想」割り込みコントローラを実装する必要がありました。AICドライバは、任意のCPUコアで保留されている最大32種類のイベントを
内部で管理し、そのコアの単一のハードウェアIPIを介してすべてのイベントを伝達します。IPIがそのコアに到着すると、どのイベントが保留されているかを
チェックし、あたかも別々のIPIのようにLinuxに配信します。他のLinuxは、ハードウェアが2つしかサポートしていないにもかかわらず、CPUあたり
最大32個のIPIを処理できる割り込みコントローラを見ています（そして私たちは1つしか使いません）。ふう。

AICのような単純な割り込みコントローラのドライバを書くのは複雑です。割り込み処理には多くの微妙な点があり、コードが少しでも間違っていると、
稀なイベントの連続の時にのみ現れるイライラするハイゼンバグが発生しますが、OS全体をハングアップさせ、デバッグをほぼ不可能にしてしまいます。
割り込みハンドラからデバッグ情報を出力することは、タイミングを変更することでバグをなくすことができる一方で、すべての処理が遅すぎて
使えなくなることもあるため、厄介です。ソフトウェアIPIマルチプレクサを追加すると、さらに複雑になります。通常はハードウェアで処理されるものを
ソフトウェアでエミュレートしなければならないからです。これを間違えると、レースコンディションによるIPIの欠落などが発生します。

AICのコードが正しいことを確認するためにこれらの詳細を理解しようとしているうちに、私はAArch64のメモリ順序とメモリバリアの詳細を調べているうちに、
ウサギの穴に入り込んでしまいました。そして、ARM64 Linuxのアトミック操作の実装に微妙なバグを発見したのです。このテーマについて話すと、
複数のパートに分かれてしまいますが、もっと知りたいという勇気のある方には、Will Deaconの講演をお勧めします。特にこの講演では多くの疑問が
解消されましたし、私の疑問も解消されました。メモリモデルやAICコードの健全性に自信を持つことで、将来的にデバッグ作業でイライラすることが
なくなります。もし、ゲーム中に特定の操作をしたときにだけ発生する微妙なGPUハングの問題（ただし、たまにしか発生せず、再現には1時間かかる）を、
AICドライバーのレース状態にまで遡って解明しなければならないとしたら、想像してみてください。

良くも悪くも、M1はこういった微妙なバグを明らかにするのが得意です。他のCPUでは決して起こらないようなレースコンディションをくすぐるような、
非常に秩序の乱れたマシンなのだ。以前のM1n1の問題をデバッグしていたとき、M1n1が（合法的に）割り込みハンドラから抜け出そうとしているのを
見たことがあります......コードからは、まだハンドラの途中でデバッグ情報を表示しているように見えましたが この問題は、MMUの微妙な設定ミスが
原因であることが判明しました。このことから、これらのコアシステムがどれほど密接に結びついているか、また、どれほどデバッグが難しいかがわかると
思います。

面白いことに、M1チップには標準的なGICが少しだけ搭載されています。具体的には、GICの低レベルビットをVMゲストにネイティブに仮想化することを
サポートしています。そうでなければ、VMのハイパーバイザは割り込みコントローラの細かい部分までエミュレートしなければならず、割り込みのたびに
ハイパーバイザのコードを何度も呼び出す必要があるからです。奇妙なことに...macOS Hypervisor Frameworkはこの機能をサポートしておらず
（記事執筆時点）、VMハイパーバイザーはソフトウェアで完全なGICエミュレーションを行う必要があります。私はMarc Zyngierと一緒に、これらの
チップ上でVMを実行する際の特殊性について研究しています。彼はすでに、M1 Mac上のAsahi Linuxカーネル上で動作するKVMの上で、Linuxの
仮想マシンを起動しています。ベンチマークをするにはまだ早いですが、macOSでサポートされていなくても、他の部分が整備されれば、特にIPIを
多用するワークロードでは、ネイティブのLinux-on-Linux VMがLinux-on-macOS VMよりも速くなると期待しています。

## フィニークなFIQ

次に、すべてのOSが動作するためには、システムタイマーが必要です。コンピュータで複数のアプリケーションを実行する場合、マルチタスクを
実現するために、OSは同じCPUコア上でアプリケーションを切り替えられる必要があります。また、バッファリングされたデータをディスクに書き込んだり、
YouTubeの動画の次のフレームを表示したり、タスクバーの時計を進めたりするなど、特定のタイミングで何かを実行するようにスケジューリングする
機能も必要です。これらはすべて、ある種のタイマーハードウェアによって実現されており、OSは将来のある時点でIRQを送出するようプログラム
することができます。

AArch64にはシステムタイマーの仕様が含まれており、M1はこれらの標準的なタイマーを期待通りに実装しています。しかし、プラットフォーム
固有のビットがあります。タイマーは、IRQコントローラを介して割り込みを配信する必要があります。GICシステムでは、もちろんGICを経由します
（ただし、使用される具体的な割り込み番号はシステムごとに異なります）。Apple Siliconでは、AICを経由することになるでしょう。

しかし、タイマーを作動させ、AICに保留中の割り込みについて教えを請うても、何も出てきません。どうしたものか。M1のタイマーはIRQを全く
送れないのだ。代わりにFIQだけが送られてくる。

AArch64のCPUにはIRQラインが1本しかないと言ったとき、よく無視される姉妹ラインであるFIQラインについては言及しなかった。FIQ
（Fast Interrupt Requests）とは、二次的な割り込みメカニズムです。高速」というのは、古いAArc32システムではもう少し効率的に
動作していたことを意味していますが、AArc64ではこれは廃止されています。FIQとIRQは事実上同等です。GICシステムでは、OSは個々の
割り込みをIRQとFIQのどちらを経由するかを設定できますが、ほとんどのAArch64システムではFIQはセキュアモニタ（TrustZone）で使用
するために確保されているので、Linuxでは使用できません。なので、LinuxはFIQを使いません。全くです。AArch64 LinuxはFIQを期待
していないので、FIQを受け取るとパニックになります。

FIQに対応していないと、M1にはタイマーがないので、対応はオプションではありません。これは、Apple Siliconが必要としているLinux 
AArch64のサポートに対する、もう一つの大きな変更となりました。FIQをサポートするのは簡単だが（簡単に言えば、IRQの扱い方を機械的に
コピーしてFIQも同じように扱うだけ）、FIQを必要としないシステムではFIQをどう扱うか、FIQをどこでも有効にしておくのか、使わない
システムでは無効にするのかなど、細かい部分ではいろいろな方法があるという。

最終的には、いくつかの選択肢を検討し、いくつかのアプローチを繰り返した後、Linux ARM64チームのMark Rutlandがボランティアで
このパズルの一部を引き継ぎ、FIQサポートをLinuxに導入することになりました。

FIQを配信するものは他にもあります。実際にFIQベースの「Fast IPI」メカニズムがありますが、これはまだ使っていません。また、FIQを
利用したハードウェアのパフォーマンスカウンターもあります。実質的には、FIQは個々のCPUコアやコアクラスタに内蔵されたハードウェアで
使用され、IRQは全CPUで共有されるハードウェアを管理する単一の共有AICペリフェラルで使用されます。しかし、もう一つの問題として、
FIQコントローラが存在しないことが挙げられます。AICはIRQコントローラの役割を果たしていますが、これらのFIQソースはすべて1つの
FIQに「混ぜられて」（ORされて）おり、それらを集中的に見分ける方法がありません。その代わり、FIQ処理コードは、これらのFIQソースを
1つ1つチェックし（特定のデバイス・レジスタを覗く必要があるため、それぞれに固有の方法で）、どれが注意を必要とするかを把握し、
そのデバイスのドライバに割り込みを配信しなければなりません。これは非常に醜いことであり、アップルがなぜ些細な「FIQコントローラ」を
搭載しようと考えなかったのかはよくわかりません。各FIQソースのステータスを1ビットで示す1つのレジスタだけでも十分だったはずです。
私たちは、CPUの全レジスタを徹底的に探しましたが、残念ながら存在しなかったようです。

M1には、VMゲストのタイマー割り込みを処理するための特別な機能があります（ありがたいことに、これはVMを正常に動作させるための必要条件なのです）。
私たちはこれらの機能をリバースエンジニアリングし、マークがKVMを立ち上げる作業の一部として使用しています。

コアのFIQサポートパッチに加えて、将来的にこれらのパスの間でより密接な結合を可能にするために、（厳密にはAICの一部ではないにもかかわらず）
AICドライバで下流のデバイスドライバにFIQを配布することを選択しました。これは、将来的にIRQを介したAIC IPIからFIQを介した
"Fast IPI "に切り替える際に必要になるかもしれません。

## 歴史を振り返る

デバイス上でLinuxを動かすことは素晴らしいことですが、実際に操作できなければ何の役にも立ちません。dmesgログを取得したり、Linux
コンソールと対話するためには、M1用のUARTドライバが必要です。UARTにはさまざまな種類がありますが、最も人気があるのはPC標準の
16550 UARTで、最近ではあらゆる種類のARM SoCに組み込まれています。もちろん、AppleはAppleで、代わりに独自のものを開発
したのでしょうね。

いや、そうじゃない。しかし、16550ではありません。M1はSamsungのUARTを採用しています。

Appleの最初のiPhoneはSamsung製のSoCを搭載していましたが、Appleが自社設計に切り替えると発表したのは有名な話ですが、実際には
複数のチップ世代にわたってSamsungからの移行は遅々として進んでいませんでした。「Apple Silicon」チップは、他のSoCと同様に、
多くの企業からライセンスされたIPコアを搭載しています。例えば、M1に搭載されているUSBコントローラーはシノプシス社製ですが、
同じハードウェアがRockchip社、TI社、NXP社のチップにも搭載されています。Appleが製造をSamsungからTSMCに変更しても、チップには
Samsungらしさが残っていました......そして、UARTのデザインは今でも残っています。これがサムスンの知的財産がM1にあることを
意味しているのか、それともアップルが単にソフトウェア互換性を保つためにインターフェースをクローンしただけなのかはわかりませんが
（UARTの設計は決して難しいものではありません）、いずれにしても今日のExynosチップとアップルのシリコンにはまだ共通点があることを意味しています。

というわけで、LinuxにはすでにSamsungのUART用のドライバが用意されています。しかし、そこには問題があります（当然ですが）。
Samsung UART」は1つではありません。Appleが使用しているものは、LinuxのSamsung UARTドライバではサポートされていません。

同じハードウェアの多くの種類をサポートするドライバは非常に厄介であり、このドライバのように古いドライバの場合はなおさらです。
さらに、Linuxのシリアルポートサブシステムは初期のバージョンにまでさかのぼり、別の次元の厄介さをもたらしています：この先を
読む方はご注意ください。そこで課題となるのが、コードを悪化させることなく、この新しいタイプのUARTのサポートを統合する方法を
見つけることです。これは、リファクタリングとクリーンアップを意味します。例えば、Linux にはユーザー空間に公開されている
シリアルポートタイプの古い概念がありますが（つまり、ユーザー空間 API は後方互換性を維持しなければならないため、これらのタイプは
追加できるだけで削除はできません）、これは現代の Linux でのデバイスの処理方法とは完全に矛盾しています。ユーザースペースが
シリアルポートのタイプを気にする理由はまったくありませんし、もし気にするのであれば、ハードコードされた定義リストを持つ不便な
TTY APIを使用すべきではありません（そのためにsysfsがあるのですから）。既存のSamsung UARTの各品種には、それぞれ独自の
ポートタイプが定義されていましたが（実装されなかった未使用のものもあります）、さらに別のものを追加するのは問題外でした......
そこで私たちはドライバをリファクタリングし、ユーザースペースに公開されるポートタイプとは無関係に、UART品種の内部プライベートな
概念を持つようにしました。Apple Silicon UARTは、このレガシーAPIに対して16550であることを示すだけで、誰も何にも使っていません。

もう1つの課題は、このバージョンでの割り込みの処理方法です。Samsungの旧式のUARTでは、送信用と受信用に2つの独立した割り込み出力
があり、システムの割り込みコントローラで別々に処理されていました。新しいExynos製品ではこれを内部で処理しており、UARTの中に
小さな割り込みコントローラを設けてさまざまな種類の割り込みを処理し、それらを1つにまとめてシステムのIRQコントローラに渡しています。
Apple社の製品でもこれを行っていますが、異なるレジスタを使用した互換性のない方法で行われているため、別のコードパスを記述する必要がありました。

その上、このUARTバリアントはエッジトリガー割り込みしかサポートしていません。エッジトリガ割り込みとは、特定のイベントが発生
したときに、そのイベントが発生した瞬間にのみ発生する割り込みのことで、例えば、UARTの送信バッファが空になったときなどに発生します。
逆に、レベルトリガー割り込みは、ある条件が真である限り発生し、その条件がクリアされるまで発生し続ける割り込みです：例えば、
送信バッファが空になるまで。様々な理由から、レベルトリガー割り込みは扱いやすく、最近のシステムでは好まれています。AIC自体は
レベルトリガー割り込みを使用しており、UART自体からの割り込みもレベルトリガーですが、それを駆動する内部イベント（送信バッファや
受信バッファが空になったり、いっぱいになったり）はエッジトリガー方式でのみ動作します。サムスンの他の UART タイプは両方のモードを
サポートしており、Linux はそれらをレベルトリガーモードで使用します。既存のコードは、送信機をオンにするだけで何もしないで動作
していたのですが、これが問題になりました。既存のコードは、送信機の電源を入れるだけで何もしないで動作していました。すべてが
レベルトリガモードで構成されている場合、送信バッファが空になると直ちに割り込みが発生し、ドライバ内の割り込みハンドラが最初に
送信するデータでバッファを埋めます。エッジトリガモードでは、バッファが空になるのではなく、すでに空になっているので、これは
機能しません。何も起こらず、ドライバーはデータを送信しません。そこで、データをデバイスに送信できる状態になったら、すぐに
ドライバが送信バッファを「プライム」するようにしなければなりません。なぜなら、最初のデータの塊が送信されて初めて、割り込みが
発生してデータの追加を要求するからです。

実験にはm1n1を使用していましたが、m1n1自体がUARTで制御されているため、UARTのこのようなクセを理解するのは二重の意味で困難でした。
デバッグ用の通信チャネルがデバイスそのものである場合に、デバイスの動作を理解しようとすると、非常に混乱してしまいます。ありがたいことに、
今ではこれがすべて完了し、m1n1を使ってハードウェアの他の部分を操作するのがより快適になりました。

同じ処理をしなければならないドライバーがもう一つありますが、その系統は全く異なります。M1チップのI²Cハードウェアは、P.A.Semiから
来ています。M1のI²Cペリフェラルは、AmigaOne X1000をはじめとするPWRficientのチップに搭載されているものをベースにしています。
Linuxはこのプラットフォームをサポートしていますが、既存のドライバは非常に素っ気ないものです。幸いなことに、ドライバの作者に連絡を
取ったところ、彼はまだ機能するX1000を所有しており、パッチをテストできることが判明しました。そのチップのハードウェアドキュメントを
入手できたので、ドライバを改良し、X1000で動作するはずの不足機能（割り込みサポートなど）を追加したり、M1のサポートに必要な変更を
加えたりすることができました。このドライバーは、USB Type-Cポートを完全に動作させるために必要なものなので、この作業はすぐに
開始される予定です。

## 最後のペンギン

拍子抜けするほどにLinuxの導入の話を終わらせるために、LinuxのフレームバッファコンソールをM1で動作させるために必要なことを
話しましょう。ここでさらに2000字を期待していた方は、残念ながら失望することになるでしょう。

PCでは、UEFIファームウェアがフレームバッファを設定し、efifbというドライバを使うことで、適切なディスプレイドライバを一切使わずに
Linuxを動かすことができます。AppleのシリコンMacもほぼ同じように、iBootでフレームバッファを設定してOSが使えるようにしています。
私たちがすべきことは、一般的なsimplefbというLinuxドライバを使うことだけで、コードを全く変更せずに動作します。devicetree
バインディングの変更をドキュメント化する必要があったのは、必要なのにドキュメント化されていない機能をコードが既にサポートしていたからです。

そして、すべての作業の後、devicetreeに数行加えるだけで、真っ白な画面がこのように変わりました:

![image](https://asahilinux.org/img/blog/2021/03/penguins.png)

m1n1は、iBootから渡されたフレームバッファの情報（幅、高さ、ピクセルフォーマット、ストライド、ベースアドレス）を、Linuxが
使えるようにdevicetreeに貼り付けて、これを適切に行うようになりました。

もちろん、これはあくまでもファームウェアが提供するフレームバッファである。ちゃんとしたディスプレイドライバではないので、
解像度の変更やディスプレイのホットプラグに対応する方法はなく、ディスプレイをスリープさせることもできません。開発やデモには
十分ですが、いずれは適切なディスプレイコントローラドライバを書かなければなりません。

そしてもちろん、ディスプレイコントローラではなく、論理的に独立したハードウェアであるGPUもあります。しかし、論理的にはまったく
別のものであり、M1のようなSoCでは、ディスプレイコントローラとGPUの間には、USBコントローラとGPUの間と同じくらいの関係があります。
GPUへの対応は独自の道を歩むことになるので、今後の情報を楽しみにしています。

## まだまだあります

まだまだ語り尽くせませんが、残念ながらこの記事はすでに長すぎます。しかし、この2ヶ月間にコミュニティで起こったことをもっとチェック
したいという方のために、見逃せないものをリストアップしてみました。

- AlyssaによるM1 GPUのリバースエンジニアリング（パート1、パート2）。
- DougallのGPU ISAドキュメント、CPUマイクロアーキテクチャドキュメント、AMX命令セットドキュメント
- QEMUにM1サポートを導入したIrisの作業
- Mark の U-Boot と OpenBSD の M1 への移植作業。彼は、すでに PCIe をサポートしています!
- Sven の DART と Apple の IOMMU のリバースエンジニアリングの仕事。

私たちの現在の Linux 持ち込みシリーズは、3 番目のバージョンで、アップストリームに含めるためにレビューされています。
この記事の内容がどのようにコードに反映されているかを知りたい方は、パッチをチェックしてみてください。すべてがうまくいき、
新たな障害がなければ、これは Linux 5.13 にマージされる予定です。期待していてください。

Asahi Linuxは、組み込み開発初心者からハードウェアエンジニア、ベテランのカーネル担当者まで、プロジェクトを前進させるために
参加してくれた人々のコミュニティ全体のおかげで成り立っています。もしあなたが貢献することに興味があれば、私たちのコミュニティ
ページをチェックして、IRCチャンネルに参加してください。

個人的な話になりますが、私はAsahi Linuxをフルタイムの仕事にしようとしています。もしあなたが私のやっていることを気に入って
くださり、プロジェクトにもっと時間を割きたいと思ってくださるのであれば、PatreonやGitHubで私をサポートしてください。これまでに
寄付をしてくださった皆様に感謝します。皆様のおかげでこのプロジェクトは実現しました。

この記事を校正してくださったJMC47さん、Davidさん、Ridleyさんに感謝します。

#### marcan · 2021-03-11
