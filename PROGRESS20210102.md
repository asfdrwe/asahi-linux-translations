[Progress Report: January / February 2021](https://asahilinux.org/2021/03/progress-report-january-february-2021/)の非公式日本語訳です。

訳注: 
- 原文で本家文書wikiへのリンクは対応する日本語訳文書wikiへのリンクに置き換え
- 原文での単語説明のための英語版Wikipediaへのリンクは、対応する日本語版が存在する場合、日本語版Wikipediaへのリンクに置き換え
- Githubのmarkdownで使えないiframeでのtwitterへの埋め込みはリンクに置き換え

---
# 進歩報告:2021年1月2月
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202109.md)

第一回Asahi Linuxへ進歩報告ようこそ！ このシリーズでは[Dolphin](https://dolphin-emu.org/blog/series%23series-1)を
見習ってプロジェクトの進捗状況を毎月お伝えしていきます。

新しいsystem-on-chipにLinuxが対応するのは簡単ではありません！この連載が皆さんの学習つながり、新しいデバイスで
Linuxを動作させるための舞台裏を垣間見ることになるなら幸いです。当初の予定では1月と2月に分けて更新する予定でしたが、
物事があまりにも早く進みすぎて区切りをつけるのが難しかったので、結果2ヶ月間の更新となりました。

### 用語の説明

本報告では、AArch64、ARM64、ARMv8-Aという単語を使用しています。AArch64は64ビットARMアーキテクチャの命令セット、
ARM64はLinuxがサポートする64ビットARMの呼称、ARMv8-AはAArc64を含むARM CPUアーキテクチャの仕様です。
それぞれ微妙に意味が異なりますが、ここでは『64ビットARM』という意味で捉えていただければと思います

## すべての始まり

Asahi Linuxプロジェクトは正式には年初に始動しましたが、その時点ではある重要な要素を待っていました。Apple Siliconシステムで
代替カーネルを起動するためのAppleの対応です。この機能は文書化されほとんど実装されていましたが、最後に一つだけ足りないものが
ありました。それはApple以外のカーネルをインストールするための`kmutil configure-boot`コマンドの対応です。
これにより私たちの進歩が止まることはありませんでしたが、文書化されていないプラットフォームにOSを移植するための
最初のステップは文書化です！

Apple SiliconのMacはPCとは全く異なる方法で起動します。仕組みは(Android携帯やiOSデバイスのような)組み込み型のプラットフォームに
近いものですが、独自の仕組みがいくつも組み込まれています。しかし、Appleはこの起動プロセスをIntel Macのそれに近づける*ような*
いくつかの手段を講じており、実際の動作については多くの混乱が生じています。例えば、Apple Silicon Macでは従来の意味での
外部ストレージからの起動が一切できないことをご存知でしたか？また、Apple Silicon Macのブートローダはグラフィカル・ユーザ・
インタフェースを表示することができず、『Boot Picker』はブートローダの一部ではなく実際にはフルスクリーンのmacOSアプリで
あることをご存知でしたか？

そこで私たちは、このマシンで独自のカーネルを実行する前に、
[ブートプロセスの仕組み](https://github.com/asfdrwe/asahi-linux-translations/wiki/SW%3ABoot)、
[内蔵SSD上のパーティションやボリュームの配置](https://github.com/asfdrwe/asahi-linux-translations/wiki/SW%3AStorage)、
さらには[PCとの比較](https://github.com/asfdrwe/asahi-linux-translations/wiki/M1-vs.-PC-Boot)
を明らかにしようとしました。この文書は、私たちのプロジェクトに役立つだけでなく、自分のマシンがどのように動作するかを
理解したいと考えているmacOSユーザーにも役立つことを目的としています。この機能の一部とその根拠は（すべてではありませんが）
[2021年2月版のApple Platform Security Guide](https://support.apple.com/guide/security/welcome/web)
に記載されています。

## 2つの世界の架け橋

Apple Silicon Macは既存のどの規格にも基づかないブートプロセスを採用しています。これはiOSデバイスの初期段階から徐々に進化してきた
Apple独自の仕組みです。一方、他の64ビットARMの世界では、2つの競合する規格にほぼ収束しています。
[UEFI](https://ja.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface) 
＋
[ACPI](https://ja.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface)
（主にWindowsやLinuxが動作するサーバーで使用されています）と、
[ARM64 Linuxブートプロトコル](https://www.kernel.org/doc/Documentation/arm64/booting.txt)
＋
[DeviceTree](https://www.devicetree.org/)
（小型システムで使用されており[U-Boot](https://ja.wikipedia.org/wiki/Das_U-Boot) なども対応）です。Asahi Linuxでは
これらのうちのどれかを選択し、Appleの世界と私たちの世界を『橋渡し』する方法を考えなければなりません。

UEFIやACPIは複雑で、通常は大型のARMシステムにしか使われません。UEFIとACPIは、大規模なARMシステムにしか使われない複雑な規格で、
[UEFIフォーラム](https://uefi.org/)の委員会がその大部分を管理しています。同質性の高いx86 PCの世界とは異なり、ARMの世界は
非常に多様で、[system-on-chip](https://ja.wikipedia.org/wiki/System-on-a-chip)
にはあらゆる種類のデザインがあり、その中に含まれるハードウェアを記述するための要件も異なります。つまり、新しいSoCのサポートを追加する
ためには、ほとんどの場合、これらの規格を修シてそのSoCを独自にするハードウェアのビットに対応する『バインディング』を追加する必要があります。
ACPIの場合、この作業にはコストと時間がかかるため、Windowsを搭載していない小型の組み込みシステムではACPIがほとんど使われていません。
これは私たちにとっては実行可能な選択肢ではありません。

多種多様なより小型の組み込み用ARM Linuxシステムでは、ほとんどの場合、DeviceTree規格が採用されています。例えば、ほとんどのAndroidデバイスは
この規格で起動します。DeviceTreeはACPIよりもはるかにシンプルで、DeviceTreeは純粋にハードウェアを記述するデータの集まりなのに、
ACPIテーブルがデータとコードの組み合わせです。最近DeviceTreeバインディングの権威となっているのはLinuxカーネルツリー内の
[文書](https://www.kernel.org/doc/Documentation/devicetree/bindings/)
自体です。つまり、Linuxドライバを作成すると同時にこの規格を修正することができるのです。よって、Linuxのドライバを書くのと同時に
規格を変更することができるのです。

興味深いことにAppleもApple Silicon上では、Apple Device Treeという独自のDeviceTreeを使っています！
これは、Apple Device TreeとオープンなDeviceTree規格の両方が
[より古いMac](https://en.wikipedia.org/wiki/New_World_ROM)を含む多くのPowerPCシステムのブート方法である
[Open Firmware](https://ja.wikipedia.org/wiki/Open_Firmware)仕様に基づいているからです。残念ながら、ADTは
組み込みLinuxの開発者にとっては非常に馴染み深いものですが、直接使用することはできません。バイナリ形式が異なるためデータが
何を表しているかという高レベルな情報がないと自動的に変換できないのです。その上、デバイスに使用される実際のバインディングも
大きく異なります。LinuxとmacOSはPowerPC Mac上では同じように動作し直接の互換性がありますが、LinuxはARM分野では10年以上に
わたってAppleとは異なる進化を遂げてきました。AppleとLinuxのデバイスツリーの考え方を統一しようとすると悪夢になってしまうでしょう。

Appleの世界をDeviceTreeの世界に適応させるために、私たちはApple Siliconマシン用のブートローダ『m1n1』を開発しています。
その目的は、できるだけ多くの『Apple主義』を解消し、Linuxやその他の下流のものをできるだけ簡単に使えるようにすることです。

Linuxのカーネルの前にm1n1を配置し（最小限の固定カーネルのインストールに
`cat m1n1.macho initrd.bin devicetree.dtb Image.gz > m1n1-kernel.macho`を使う）、Appleの`kmutil`ツールを使ってMacに
インストールすることでLinuxの起動に必要なすべてのことが行われます。m1n1を使ってLinuxを起動するとだいたいこんな感じになります:

- メインCPUを初期化し、正しく動作させるための[chicken bit](https://en.wiktionary.org/wiki/chicken_bit)設定を適用
- AppleのブートローダであるiBootから提供されたブート情報を読み込み、RAMの空き容量やRAM内の
[フレームバッファ](https://ja.wikipedia.org/wiki/フレームバッファ)（画面に表示されるビデオメモリ）のアドレスなど
- [メモリ管理ユニット](https://ja.wikipedia.org/wiki/メモリ管理ユニット)の初期化。
[CPUキャッシュ](https://ja.wikipedia.org/wiki/CPU_cache)の使用に必要で、これがないとすべての動作が極端に低下
- Apple ロゴに代わってAsahi Linux のロゴを画面に表示
- [ウォッチドッグタイマー](https://ja.wikipedia.org/wiki/ウォッチドッグタイマー)を無効化。しないと1分ほどでMacが自然に再起動。
Macが起動プロセスが滞っていると扱われるため
- 起動するものを把握。Linux カーネル、DeviceTree、（オプションで）起動時のアプリケーションが含まれるinitramfs
ラムディスクが追加されている場合はそれらを含めて
- 他のすべてのCPUコアを初期化し、必要なchicken bitを適用して、Linuxが引き継げるように『spin-table』で待機
- Apple DeviceTreeから情報を取得し、提供されたDeviceTreeテンプレートをそれに合わせてカスタマイズ。
マシンやAppleのiBootファームウェアのバージョンごとに変わる設定にこれを使用。メモリサイズ、フレームバッファに関する情報、
Linuxの乱数ジェネレータを初期化するためのシードなど。m1n1は存在するならspin-tableの詳細やカーネルへのコマンドライン引数
など自身の情報を追加
- Linuxにジャンプまたは次のステージに進む

『spin-table』とはARM版LinuxがDeviceTreeの世界で追加のCPUコアをオンにするために使用できる2つの規格のうちの1つです。
プラットフォーム固有のドライバに頼るのではなく、すべてのプラットフォームで使用することが期待される2つの標準的な方法が
存在します。最もシンプルなspin-tableは、ブートローダがあらかじめすべてのCPUをオンにしておき、ループの中でCPU
を待機させる（『spining』）だけのものです。このループからCPUを解放するために、Linuxはどこでカーネルにジャンプするか
伝えるためにRAMに値を書き込みます。これは単純なプラットフォームでは完璧です。唯一の制限はCPUを完全に停止させることが
できないことです。ブートローダからCPUを引き継ぐのは一度限りですから。しかし他のメカニズムを使って様々な低電力モードに
することができます。現時点ではこの方法を使っていますが、これからもこの方法が必要になる可能性があります。

『[PSCI](https://developer.arm.com/architectures/system-architectures/software-standards/psci)』はARMの規格で、
Linuxの実行中でもシステムのファームウェアが提供できる適切なサービスとして設計されており、CPU（およびその他のコンポーネント）を
実行時に制御できるようになっています。通常は『EL3』で動作するコード（セキュアなファームウェアやTrustZone）または『EL2』で
動作するVMハイパーバイザーを介して行われます。OSは通常『EL1』で動作します。しかし、EL3もEL2もARMv8-AのCPUのオプション機能で
あり、M1にはEL3の対応がないことは判明しました。EL2はありますが、Linuxで動作するVMに対応したいので、Linux自体をEL2で動作させる
必要があり、その上に他のハイパーバイザーを置くことはできません。つまり現在PSCIを使用することができません。なぜならPSCIには
標準的なインターフェースが存在しないためです。近い将来、PSCIを使用できるような代替メカニズムが開発されるかもしれません。
これはフルシステムのスリープモードに対応するために必要になるかもしれません。しかし、きめ細かな電源管理が十分であれば、
非常に良好なバッテリー寿命を得るために『真の』フルシステムのスリープは必要ないかもしれません（最近のデバイスはきめ細かな
スリープモードで非常にうまく機能します）。時間が解決してくれるでしょうし、この分野はまだ発展途上です。

さて、DeviceTreeを使うと言いましたが、UEFIを使えないわけではありません！ARM64システムはUEFI＋DeviceTreeを使って起動することができます。
これは『PCっぽい』なブート体験を得るために必要で、GRUBのようなブートローダや、カーネルのインストールやアップグレードのための典型的な
フローを使えます。しかし、m1n1はそれらを一切サポートしていないので、どうすればいいのでしょうか？ありがたいことにパズルを完成させる
もう一つのピースがあります：[U-Boot](https://ja.wikipedia.org/wiki/Das_U-Boot)です。U-BootはLinuxカーネルのように
起動できるので、m1n1からU-Bootを起動することができますし、U-Boot自体がGRUBやLinuxのための十分なUEFI環境を提供することができます。

というわけで、エンドユーザーが使うAsahi Linuxのブートチェーンはおそらく次のようになるでしょう:

m1n1 → U-Boot → GRUB → Linux

これにApple固有のブートチェーンが加わると、ブートプロセス全体は以下のようになります:

- コールドブート時にはM1 SoC内のSecureROMが起動し、NORフラッシュからiBoot1をロード
- iBoot1が内蔵SSDのブート構成を読み込み、システムブートポリシーを検証し、起動する『OS』を選択。
私たちの場合Asahi Linux / m1n1がiBoot1にとってOSパーティションのように見える
- iBoot2が『OSローダー』で起動先のOSパーティションに常駐する必要あり。内蔵デバイスのファームウェアのロード、
Apple Device Treeの設定、Mach-Oカーネル（私たちの場合はm1n1）の起動を行う
- m1n1がADTを解析し、さらにデバイスをセットアップしてLinuxらしくし、FDT（Flattened Device Tree、DeviceTreeのバイナリ形式）を
セットアップし、U-Bootを起動
- 内蔵SSD用のドライバを持つU-Bootがその設定と次のステージを読み込み、m1n1からのDeviceTreeの転送を含むUEFIサービスを提供
- ディスクパーティションから標準のUEFIアプリケーションとして起動するGRUBがPCでのGRUBのように動作。これにより
ディストリビューションが`grub-mkconfig`や`/etc/default/grub`などを使って慣れ親しんだ方法でカーネルを管理可能にする
- 最後にLinuxカーネルが起動。m1n1からあらゆる方法で渡されてきたDeviceTreeが動作に必要な情報を提供

ふぅ～！PCの世界から来た人にはちょっとクレイジーに見えるかもしれませんが、このような長いブートチェーンは組み込みシステムでは
一般的です（実際、一般的なPCの『UEFI』には複数のステージが含まれているが、エンドユーザーには見えていないだけ）。例えば、
DragonBoard 410c（Qualcommベースのプラットフォーム）のブートチェーンは以下のようになります:

[PBL → SBL → QSEE → QHEE → LK](https://discuss.96boards.org/t/documentation-on-db410c-bootloader-files/2124/2)→
[U-Boot → GRUB](https://lists.denx.de/pipermail/u-boot/2017-June/296388.html) → Linux

iBoot2を置き換えることはできませんが（Appleの署名が必要）、エンドユーザー向けのインストールプロセスでは、iBoot2と必要な
サポートファイルを含む最小限の『macOS』を自動的にセットアップし、Appleのブートプロセスが起動可能なOS
（ただし、実際のmacOSカーネル／ファイルシステムは含まない）として認識できるようにします。インストーラはまだ準備ができていないので、
当面の間、m1n1/Linuxを試す開発者は完全なmacOSを別途インストールして、そのカーネルを置き換える必要があります。
私たちは、この冒険に参加したい方のために、ステップバイステップの[クイックスタートガイド](https://github.com/asfdrwe/asahi-linux-translations/wiki/%E9%96%8B%E7%99%BA%E8%80%85%E5%90%91%E3%81%91%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88)を書きました。

今のところ、私たちの主な開発ワークフローはm1n1 から直接 Linux をロードすることですが、Mark Kettenis氏は 
[U-Boot や OpenBSDの対応](https://marc.info/?l=openbsd-arm&m=161386122115249&w=2)について
私たちと一緒に作業しています。

しかし、m1n1はLinuxを実行するためだけのものではありません。実際、本質的にはブートローダですらないのです！

## ハードウェアで遊ぶ

m1n1は、私がNintendo WiiのセキュリティCPUのために書いたミニマルな環境である
[mini](https://github.com/fail0verflow/mini)にまで遡ります。これは、実験やBootMiiのバックエンドと
して役立ちました。Wiiをお持ちの方でWiiに詳しい方は、BootMiiメニューを表示している間、miniがARM CPU上で動作します。

それがApple Siliconのブートローダと何の関係があるのか尋ねですか？miniは、外部のライブラリや依存関係なしにベアメタルの
32ビットARMシステム上で動作するとてもシンプルなソフトウェアです。ベアメタルのコードを作るのに適したシンプルなベースになるので、
AArch64とApple Siliconに移植してm1n1と改名しました。しかし、それよりも重要なのはminiとm1n1には仕掛けがあることです。メインCPUから
制御する必要のある`別のプロセッサ`上で動作するファームウェアとしてのminiの遺産と、過去のWiiハードウェア研究の実験のおかげで、miniは
シリアルポート上で動作するRPCプロキシを内蔵しています。つまり、開発用コンピュータからminiやm1n1をリアルタイムに『リモートコントロール』
することができるのです。m1n1では任意のコンピュータ上で動作するシンプルなPythonスクリプトを使ってM1ハードウェアを操作する
ことができ、[対話型シェル](https://github.com/asfdrwe/asahi-linux-translations/wiki/%E9%96%8B%E7%99%BA%E8%80%85%E5%90%91%E3%81%91%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88#%E3%83%97%E3%83%AC%E3%82%A4%E3%82%B0%E3%83%A9%E3%82%A6%E3%83%B3%E3%83%89%E3%81%AE%E3%82%B7%E3%82%A7%E3%83%AB)からも可能です。
m1n1はLinuxブートローダを搭載したハードウェア実験ツールと言っても過言ではありません。

これにより、ハードウェアについての知識を深めたりAppleのプロプライエタリな機能を発見したりするのに素晴らしいプラットフォームとなります。
例えば、[このスクリプト](https://github.com/AsahiLinux/m1n1/blob/main/proxyclient/fptest.py)では、x86 固有の浮動小数点構成
ビットのサポートを CPU に追加し、Rosetta x86 エミュレーションを高速化するために使用するApple の特別な機能をテストします。
[このスクリプト](https://github.com/AsahiLinux/m1n1/blob/main/proxyclient/find_all_regs.py)はすべてのAppleカスタム
CPUレジスタを検索しその値とアクセス制限を表示します。
[このスクリプト](https://github.com/AsahiLinux/m1n1/blob/main/proxyclient/hacr_trap_bits.py)はAppleの
プロプライエタリなハイパーバイザーの設定レジスタがアクセス制限をどのようにカスタマイズできるか自動的に表示します。
そしてもちろん[このスクリプト](https://github.com/AsahiLinux/m1n1/blob/main/proxyclient/linux.py)は
シリアルポートから直接ストリーミングでLinuxカーネルを起動します。

M1のMac Miniをm1n1で起動するのにかかる時間は約7秒で、これらのスクリプトは（マシンをクラッシュさせるまで）すべて再起動せずに
インタラクティブに実行できます。m1n1は
[自分自身をロード](https://github.com/AsahiLinux/m1n1/blob/main/proxyclient/chainload.py)することもできるので、
m1n1自体の開発サイクルも非常に高速です。

m1n1を使って、Appleのカスタム[ARM命令](https://github.com/asfdrwe/asahi-linux-translations/wiki/HW%3AApple-Instructions)、
Apple固有の[システムレジスタ](https://github.com/asfdrwe/asahi-linux-translations/wiki/HW%3AARM-System-Registers)、
[Apple Interrupt Controller](https://github.com/asfdrwe/asahi-linux-translations/wiki/HW%3AAIC)などの
ハードウェアの文書作成に頑張っています。

今後もm1n1に機能を追加し、より強力な研究ツールにしていきたいと考えています。特にエキサイティングな目標は、m1n1を非常に薄いVM
ハイパーバイザーにして、macOSを起動し、そのM1ハードウェアへのアクセスを横取りすることです。これにより、Appleのドライバーが
どのように動作するかを分解することなく調査することができます。この方法は、
[nouveau](https://nouveau.freedesktop.org/MmioTrace.html)でNvidiaのGPUのリバースエンジニアリングに
成功したのと同じやりかただと思う人もいらっしゃるでしょう。nouveauの場合はハイパーバイザーを追加する代わりにLinuxドライバを使い
カーネルを修正しただけでしたが。

でもちょっと待って。これをやるにはシリアルポートが必要です。M1 Macsのシリアルポートはどこにあるの？よくぞ聞いてくれました！

## そうだよ、UARTだよ！

新しいシステムでローレベルの立ち上げ作業を行うにはシリアルポートが必要不可欠です。シリアルポートは
[UART](https://ja.wikipedia.org/wiki/UART)ポートと
呼ばれることもありますが、実質的には最もシンプルな通信ハードウェアであり、ローレベルのデバッグツールとして
非常に便利なものです。シリアルポートを使ってメッセージを送信するには数個のCPU命令が必要なだけなので、早い段階でセットアップして
開発用のテキスト端末として利用することができます。

もちろん、モダンなPCにはRS-232シリアルポートが搭載されていましたが、それはもう昔の話です。多くの組み込みシステム（家庭用ルータなど）では
低電圧のシリアルポートが内部に存在していますが、コネクタや基板上のテストポイントにアクセスするにはケースを取り外す必要があります。
M1マックの場合は？

M1 Macの場合ケースの外側にあるUSB-Cポートの上にシリアルポートがあることが判明しました！ただし、シリアルポートを有効にするには
USB-PDで特別なコマンドを送信する必要があります。USB-PD（USB Power Delivery）はType Cポートの『Configuration Channel』
ピン上で動作するプロトコルです。USB規格の常としてこの規格は実際に電力を供給する以外にも多くのことを行う過剰に設計された巨大なものです。
電圧の設定や充電器の識別だけでなく、ケーブルの種類やドングルの識別、DisplayPortなどの代替モード、そして今回はApple独自の設定
メッセージのチャンネルとしても使用されています。これらのメッセージは、ある特定のType Cポートの2本のピンに
シリアルポートを露出させるようにMacに要求することができます。他にも、リモートでシステムを再起動したり（高速開発には欠かせない）、
[DFUリカバリーモード](https://support.apple.com/guide/apple-configurator-2/revive-or-restore-a-mac-with-apple-silicon-apdd5f3c75ad/mac)にしたり、
[I²C](https://en.wikipedia.org/wiki/I2C)などの内部バスにアクセスしたりすることができるなど、
[優れた機能](https://github.com/asfdrwe/asahi-linux-translations/wiki/HW%3AUSB-PD)を備えています。

これらのMacでシリアルポートを使えるようにするための最初の解決策は
[vdmtool](https://github.com/AsahiLinux/vdmtool)でした。それは、Arduino、USB-PD PHY（インターフェース）
チップ、そしてある種の1.2Vシリアルポートアダプターを使ったDIYケーブルです。これはDIYが得意な人にはいいかもしれませんが、自分で
ハードウェアを作ることに慣れていない人にはあまり実用的ではありません。必要なType C信号をすべて備えた優れたUSB-PD PHYブレイクアウト
ボードがない、1.2VのUARTアダプタが少ないなど、いくつかの問題点があります。

そこで、私たちは2つ目の解決策を考えました。もしあなたが`2台`のM1 Macを持っているならお喜びください。必要なのは標準のType Cケーブル
（SuperSpeed / USB 3.0タイプ）と[macvdmtool](https://github.com/AsahiLinux/macvdmtool)です。この小さなmacOSアプリを使えば、
1台のM1マシンをもう1台のシリアルデバッグ端末にすることができ、m1n1スクリプトを実行したり、LinuxカーネルをmacOSから直接起動したり
することができます。AppleのAPIにより、Mac自身のポートをシリアルモードに設定したり、リモートのMacをシリアルモードに設定するために
必要なメッセージを送信したりすることができるので、カスタムハードウェアを一切使用せずにこれらのことが可能になります。

しかし、Macをもう一台買うとなると、極めて高価な[シリアルケーブル](https://twitter.com/svenpeter42/status/1356688286199259137)に
なってしまいます。そこで私たちは、M1 Mac用のシリアルアダプターとしてだけでなく、その他の機能も充実させたUSB-PDデバッグケーブルを、
オープンハードウェアプロジェクトとして開発することにしました。実際には、Macだけでなく多くのAndroid携帯電話など他の機器の
デバッグインターフェースとしても使えるようになるでしょう。また、USB-PDの開発プラットフォームとしても機能し、一般的なソース（電源）や
シンク（電力消費）などの役割を果たすことができ、USB-PDの充電器やデバイスの実験を行うことができます。まだ
[計画段階](https://twitter.com/marcan42/status/1361936899338690561)ですが最新情報にご期待下さい！
最終的には、誰もがボタンをクリックするだけで購入できるように広くコミュニティに提供することを目標としています。

最後に、ハードウェアのシリアルポートは低レベルのデバッグや開発に最適なソリューションですが、制限があります：最高でも150kB/sと
かなり遅いのです。M1 Macは、通常のUSBデバイス（iPhoneなど）として動作することができ、ほとんどのOSでドライバーなしで動作するUSB
シリアルデバイス（CDC-ACM）として見せることができます。これにより、USBの全帯域幅を利用できるだけでなく通常のType Cケーブル
（またはType CーType Aケーブル）を使って他のコンピュータから接続できるという利便性が得られます。また、USBにはフローコントロール
機能があり、受信側がデータを受け入れる準備ができていない場合でもデータが失われることはありません。この方法の欠点は、より複雑な
ドライバーコードを必要とするため、非常にローレベルの問題を解明するのには適していないことです。 しかし、これがm1n1でサポートされれば、
残りのほとんどの作業には十分すぎるほどの効果があり、既存のシリアルポートのサポートを利用して、より複雑なドライバーコードを快適に
開発することができます。MacのType CポートはUARTシリアル信号とUSB信号の両方を同時にサポートしています。帯域幅とパフォーマンスの
向上は、前述のハイパーバイザーの開発に着手する際に非常に役立ちます。また、現在シリアル帯域幅がボトルネックになっているLinuxカーネルの
ロードも格段に速くなります。このサポートは数週間以内にm1n1に導入される予定ですのでご期待ください！

## Penguinへの道

これらのツールはどれも素晴らしいものですが、私たちの目的はとにかくLinuxを動かすことです。では新しいプラットフォームにLinuxを
移植するにはどうすればいいのでしょうか？もちろん、全体の大部分は新しいドライバを書くことですが、その前にやるべきことがあります。
これを『bring-up』と呼んでいます。

bring-upが非常に重要なのは、OSの他の部分がマシン上で動作するための基礎を作るからだけではなく、マシン固有の機能がどのように
動作するかの基準を設定することでもあります。bring-upは、OSの最も深い部分に関わるローレベルのコードであり、一般的なドライバとは
異なり、他のプラットフォームと共通するLinuxの部分に変更を加える必要があることが多いです。そのため、サブシステムを担当するLinuxの
メンテナと調整し、適切な方法でアプローチすることが必要です。

例えば、初期のM1サポートパッチセットでは、[SPARC64](https://ja.wikipedia.org/wiki/SPARC)アーキテクチャのサポートに
関連するファイルを変更しなければなりませんでした！Linux開発の特徴としてLinuxカーネルには安定したドライバAPI/ABIが
存在しないことが挙げられます。つまり、Linuxカーネルの内部設計は長い期間をかけて継続的に改善やリファクタリングが行われています。
したがって、あるアーキテクチャで何かをサポートするために他のアーキテクチャをクリーンアップしたり変更したりする必要になるのは、
そうすることが完全にうまく行く場合になったり、たびたび何かするための最良の方法となるからです。一方で、Linux のフォークや
上流のカーネルに含まれていないサードパーティのドライバを保守することは非常に難しいことでもあります。

Asahi Linuxでは、単にLinuxをApple Siliconに移植するだけでなく、コミュニティ主導のオープンなプロジェクトとして、Linux
コミュニティ全体との協力の元に私たちの作業を公式のLinuxカーネルにアップストリームすることを目指しています。というのも、
ハードウェアにLinuxを移植する企業の多くは製品開発の締め切りに追われていて、結局Linuxのフォークを作りそこですべての開発を行い、
上流のコミュニティから切り離されてしまうからです。そして、その変更を正式なLinuxカーネルにアップストリームしようと思ったときには、
2つのフォークが大きく乖離していて、マージするのは悪夢のような状態になっているのです。また、このような設計上の決定は、Linux全体の
理念に反しており、アップストリームでは受け入れられないかもしれません。結果、多くのコードが書き直され、長期的な持続性よりも短期的な
結果を追求することによって、多くの開発時間が無駄になってしまいます。

このような事態は絶対に避けたいので、私たちは早い段階でアップストリームをして初日からコミュニティ全体と協力していくという
アプローチをとっています。そのために、私たちは上流のLinuxメンテナと一緒に仕事をしていますし、実際、Linuxの主要な人たちが
Asahi LinuxのIRCチャンネルに集まっています！

Linuxがどのようなシステムでも起動できるようにするには、正しく動作するために絶対に必要な5つの要素があります:

- CPU
- メモリ管理ユニット（MMU）
- 割り込みコントローラ
- システムタイマー
- ある種のコンソール（この場合シリアルコンソール)

ほとんどのAArch64システムでは最初の4つは非常に標準的なものです。Linuxは基本的なコンソールが使えるようになるまで
実質的に何の変更も必要ありません。しかし、AppleのSoCは独自のやり方を好むので、私たちはかなりの作業を強いられました！

## 電源を切ってもう一度入れる

現在のCPUは80年代や90年代の設計と比べると技術的に驚異的です。当時のCPUの仕事は単純な演算やメモリの読み書きや分岐を1つ1つ順番に
止まることなく行うことだけでした。電源管理もキャッシュもマルチコアもなく浮動小数点数の対応もほとんどありませんでした。

時代は変わり、現在のCPUはますます高性能になる一方で同時に消費電力は少なくなってきています。どうやってそれを実現しているのでしょうか？
半分はもちろん[ICの製造技術の向上](https://ja.wikipedia.org/wiki/%E3%83%A0%E3%83%BC%E3%82%A2%E3%81%AE%E6%B3%95%E5%89%87)によるものです。もう半分は
CPUの設計が大幅に進歩したことです。最近のシングルCPUコアは、複数の命令を同時に実行したり、未来を予測して物事を先に進めたり、
予測が間違っていたら元に戻したり、最近使用したデータやすぐに使われると予測されるデータのコピーを保持したり、さらには電力を
節約するために自分自身の一部を動的にオン/オフすることもできます。

しかし、このような複雑さには2つの問題があります。それは予期しない機能と明らかなバグです。最近のOSではOSを実行するこのようなCPUの細かい
部分まで管理する必要があり、アプリケーションソフトでもCPUが壊れてもいいという前提条件をつけないように注意する必要があります。

90年代にパソコンを使っていた方はWindows 95やWindows 98の特徴を覚えているかもしれません。これらのOSを新品（当時）のパソコンで
使うと、全くパソコンを使わなくてもCPUの温度がかなり上昇し、その状態が続いていました。これは、これらのOSが何もしないでいるとCPUを
無限ループさせてしまうからです。何もしていなくても、CPUの100％が常に『使用』されていたのです！昔のCPUには『アイドル』という概念が
ありませんでした。有用な仕事をするためにCPUを使っていない場合、時間を無駄にするためにCPUを使っていたのです。電源管理も
ありませんでしたから、CPUにしばらく何もしないように指示しても電力は節約できませんでした。

もちろん、今日、私たちはアイドル状態のCPUがビジー状態のCPUよりも電力を節約できるという考えに馴染んでいます。これは、何もすることが
ないときにはOSがCPUにある程度の動作停止を指示して、外界からのイベント（何かをしなければならないという信号）を待つことができるからです。
Windows 95時代には『[HLT](https://en.wikipedia.org/wiki/HLT_(x86_instruction))』(Halt)を無限ループで実行する
『CpuIdle』というプログラムがあり、使用していないときにCPUを低電力モードにしてエネルギーを節約しCPUの温度を下げることができました。
最近のOSにはこれが組み込まれており、ARMのCPUは『WFI』（Wait For Interrupt）というCPU命令を使って同じ仕組みを実装しています。

最近のCPUは、HLTやWFIを呼び出すと単に命令の実行を停止するだけでなく、実際にコアの一部をパワーダウンさせてさらに電力を節約することが
できます。クロックを停止させることを『[クロックゲーティング](https://ja.wikipedia.org/wiki/CPU#%E3%82%AF%E3%83%AD%E3%83%83%E3%82%AF%E3%82%B2%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0)』、
パワーダウンさせることを『[パワーゲーティング](https://ja.wikipedia.org/wiki/CPU#%E3%83%91%E3%83%AF%E3%83%BC%E3%82%B2%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0)』といいます。しかし、
パワーゲーティングを行うと、CPUは電源を切った部分に保存されているデータを失ってしまうという問題があります。重要なデータは電源が
入っている回路に置くか、電源が入っているバックアップストレージに移す必要があります。通常、これらの命令によって目に見える形でデータが
失われることはありません。CPUは必要のないデータを捨てることはあっても、ソフトウェアが作業しているデータが失われないように注意します。

M1でLinuxが少し起動してるような状態になった時点では、起動プロセスが終わるとすぐにクラッシュしてしまいました。実際、WFI命令を実行した
直後にクラッシュしたようです。正しく呼び出した関数に戻るのではなくゼロアドレスにジャンプしていました。何が起こっているのでしょうか？

結論から言うと、M1はデフォルトでWFIがクロックゲートとパワーゲートのどちらかを行うモードで動作します。実際にはある種の自動
ヒューリスティック（気まぐれ！）な手法を用いてどちらを使用するかを選択します。残念なことに、パワーゲートに決定されるると、
[スタックポインタ](https://ja.wikipedia.org/wiki/%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF\)と
[プログラムカウンタ](https://ja.wikipedia.org/wiki/%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF)を除くすべての
[CPUレジスタ](https://ja.wikipedia.org/wiki/%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF))の内容が失われます。Linuxはこのような事態を想定していません。
他のすべてのAArch64 CPUはこのようなことをしないので、これはLinuxに追加するにはかなり厄介なパッチになります。Linuxには
特定のSoCがWFIアイドルループを別のものに置き換える仕組みがありません。

ありがたいことに、私たちはCPUの[Appleのプロプライエタリなレジスタ](https://github.com/asfdrwe/asahi-linux-translations/wiki/HW%3AARM-System-Registers)を文書化し、
CPUを正しく動作させるために必要な[chicken bit列](https://github.com/AsahiLinux/m1n1/blob/main/src/chickens.c)に取り組んだ結果、
この動作を無効にしてWFIをパワーゲートさせないようにしLinuxを正しく動作させるために使用できる
[特定のレジスタ](https://github.com/asfdrwe/asahi-linux-translations/wiki/HW%3AARM-System-Registers#sys_apl_cyc_ovrd_el1)
があることがわかりました。このレジスタをm1n1で正しい値に設定するだけで問題は解決しました。これは最高の修正方法です。
m1n1が問題を解決しLinuxのパッチは必要ありません。

これがシステムの電力効率に影響するかどうか気になるかもしれません。心配する必要はありません！M1のパワーゲーティング機能を
利用できないわけではありません。Linuxは[cpuidle](https://lwn.net/Articles/384146/)と呼ばれるサブシステムがより深い
CPU省電力モードに対応しています。このサブシステムのドライバはCPUの状態を失わせてもそれを回復する方法を知っていれば問題ありません。
したがって、私たちがすべきことは、M1 をパワーゲーティングモードに戻す cpuidle ドライバを書き(Linux内部アルゴリズムがよりよい仕事を
するならおそらくヒューリスティックをバイパスする)、ドライバ内で直接 WFI を実行し、CPU の状態を回復してからLinux のコアコードに
戻ることです。Linux流のCPUパワーセーブです。

これは私たちの開発アプローチの重要な部分を浮き彫りにしてくれます。文書化されていないデバイスを扱う場合、オリジナルのソフトウェア（macOS）と
同じことをするのは簡単です。しかし、他のOSやファームウェアの動作方法が必ずしもLinuxに最適なモデルであるとは限りません。代わりに、
システムの細かい部分を理解することを優先し、その上でLinuxでの活用方法を決めていきたいと考えています。もし、関連するCPUレジスタを
調査せずにmacOSと同じこと（メインCPUのアイドルループでパワーゲーティングモードをサポート）をしていたら、より厄介なLinuxパッチに
なっていたでしょうし、よりクリーンな方法で行う機会を逃していたでしょう。時間はかかりますがそれだけの価値があると思います。

Linuxを起動している間に見つけたCPUの驚きはこれだけではありませんでしたが、残念ながらその話は後回しにすることにしましょう...では、
次のパートに移りましょう：メモリ管理です。

## 未配達のポストが送信者に返送される

Linuxを最初にbring-upするとき、起動プロセスのフィードバックを早期に得られるようにすることはデバッグのために非常に重要となります
（私たちはハードウェア・デバッグ機能を持っていません - Appleの製品デバイスでは利用できないのです）。前述のシリアルポートはこの点で
優れていて、数個のCPU命令つまりUARTハードウェアのレジスタに書き込むだけで文字を送信できるからです。Linuxは*earlycon*という機能があって、
メインのシリアルポートドライバが立ち上がる前に通常のLinuxの`printk()`関数を動作させることで、この問題を解決することができますが、
残念ながら、最初のテストではそこまではいきませんでした。この状況は、Linuxの一番最初の
[ARM64起動コード](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/kernel/head.S)
（アセンブリで書かれている）にパッチを当てて特定のポイントで文字を出力するようにして、どこが壊れているのかを見つけ出すゲームになります。

その結果、シリアルポートがメモリ管理ユニットをオンにするところまでは動作することがわかりました。これはかなり残念な状況です。
メモリ管理ユニットはUARTデバイスへのアクセスを含めメモリへのアクセス方法を変更するからです。また、このような問題のデバッグは
非常に困難です。MMUが設定されたら最終的に一度でオンになるからです。その時に問題が発生してもどこに問題があるのか分からないのです。

しかし、非常に長いデバッグセッションの間に（最終的に代替のフィードバックメカニズムとしてLinuxカーネルブートの進捗状況を示すために、
ディスプレイフレームバッファの上部を異なる色で塗るコードを追加）、Linuxが実際にはブートし続けており、すべてのアセンブリコードを
通り越して、Cコードの実行に入り、さらには`earlycon`シリアルポートドライバにまで実行していることが明らかになりました。
しかしシリアルポートからは何も送られてきません。まるで...我々が投げかけたものを全て無視しているかのようでした。アドレスは正しく
メモリのマッピングも正しいのですが、何も出てきませんでした。

結局M1がデバイスのメモリ管理に異常にうるさいからだと判明しました。

メモリ管理ユニットは現代のどのOSカーネルでも行うことの中心となるものです。実行中のプロセス同士の隔離、仮想メモリ
（スワップファイル／パーティション）の管理、ディスク上のファイルのメモリへのマッピング、スレッドやプロセス間のデータ共有などを
可能にするCPUの一部です。複数の仮想メモリアドレス空間（アプリケーションやカーネルが持つメモリアドレスの概念）を物理アドレス空間
（システム内のハードウェアの実際のメモリアドレス）にマッピングする役割を担っています。ここでいう『メモリ』は実際のRAMだけでなく
[MMIO](https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%9E%E3%83%83%E3%83%97%E3%83%89I/O)（Memory-Mapped I/O）として扱われるデバイスも含まれます。
UARTはMMIOデバイスです。

ほとんどのプラットフォームでは通常のメモリとMMIOが区別されています。通常のメモリ（すなわちRAM）は、書き込まれたデータを後で
読み返したときに必ず戻ってくるなどある種の合理的な振る舞いをすることが想定できます。しかし、デバイスはMMIOを使ってコマンドを受け取り、
ステータスやデータをソフトウェアに返すので、通常のRAMのようには振る舞いません。CPUは、通常のメモリアクセスの順番を変えたり、
キャッシュしたりすることができますが、MMIOのアクセスにそれをしてしまうとすべてが壊れてしまいます。ドライバーはデバイスとの
データの送受信を正確にコントロールすることに依存しているからです。MMUはこの区別を担当しています。カーネルはメモリの一部分を
通常のメモリとして設定したりデバイスメモリとして設定したりします。

しかし、最近ではもっと複雑になっています。アクセスパーミッションがあったり、キャッシュモードが違ったり、デバイスメモリの種類が
違ったりします。AArch64ではデバイスメモリのマッピングに4つのモードがあります。*GRE*、*nGRE*、*nGnRE*、*nGnRnE*です。
G、R、Eは、システムができることとできないこと(**n**)を表しています。

- **Gather** 複数の書き込みを1つの書き込みに統合。例えば、CPUは隣接する2つの8ビットの書き込みを1つの16ビットの書き込みに統合可能
- **Re-order** 書き込みの順序を変更。異なるアドレスに2つの値を連続して書き込んだ場合、CPUはそれらを逆の順序で書き込むと決めることが可能
- Complete write **early** 書き込みの早期完了。システムはデータがターゲットデバイスに到達する前にCPUにメモリへの書き込みが完了
したと伝えられ、CPUは完了を待たずにコードを実行することが可能に。これはx86の世界では
『[posted write](https://en.wikipedia.org/wiki/Posted_write)』とも呼ばれる

(訳注: 
- GRE→Gather(統合)、Re-oder(順序変更)、Complete wirte Early(早期完了)すべて可
- nGRE→Gather(統合)不可、Re-oder(順序変更）可、Complete wirte Early(早期完了)可
- nGnRE→Gather(統合)不可、Re-oder(順序変更）不可、Complete wirte Early(早期完了)可
- nGnRnE→Gather(統合)、Re-oder(順序変更）、Complete wirte Early(早期完了)すべて不可
)

ほとんどのドライバーやデバイスはwrite-gatheringやre-orderingを有効にすると壊れてしまうため、これらのモードは非常に特殊な
ドライバーを除いてほとんど使用されていません。しかし、早期書き込み完了はPCIの仕様で義務付けられているため、実際にはPCの標準と
なっています。そのため、ほとんどすべてのドライバがこれを考慮して書かれています。このため、AArch64 Linuxでもデフォルトでは
すべてのI/OメモリをnGnREとしてマッピングして早期完了を有効にしています。他のデバイスはこれで問題ありません。
そのようなデバイスの多くはposted writeに対応していないかもしれませんが、その場合は単にアクセスをnGnRnEとして扱います。
デバイスはソフトウェアが要求する*よりも厳しい*保証を提供することが常に許されており、少なくともソフトウェアが要求するのと
同等にデバイスが厳密に動作するのであれば問題はありません。

調べてみると、M1の内部バスファブリックはすべてのアクセスがnGnRnEモードで行われることを積極的に強制していることがわかりました。
nGnREモードを使おうとすると、書き込みは中止され、代わりにシステムがSError（System Error）を通知します。当初この*SErrors*は
表示されていませんでしたが、これは別のプロジェクトから不注意に持ち込まれたCPUの設定によりエラー報告が誤って無効になっていた
ためです（ただし、UARTが壊れていたため私たちもエラーを確認することはできませんでしたが、少なくともUARTの書き込み後に
無表示でドロップして続行する代わりにシステムが動作を停止する原因とはならなかったでしょう)

賢明な読者の皆様はここで興味深い内容にお気づきかもしれません。M1 SoCにはPCIeが搭載されているのです！実際、いくつかの内部デバイスは
PCIeデバイスであり（Mac MiniのEthernetなど）、ThunderboltのおかげでM1 MacはあらゆるPCIeデバイスに接続することができます。
posted writeは使用しないのですか？その通りです。実際、M1ではPCIデバイスに*nGnRE*マッピングを必要とし*nGnRnEでの書き込みを拒否します。

ここに難問があります。Linux にはメモリを *nGnRnE* としてマッピングするためのフレームワークがありません。*nGnRE*モードの
代わりにどこでもnGnRnEを使用するような一回限りの特別なコードを導入することはできますが、そうすると*nGnRE*を必要とするPCIeデバイスに
対応することができなくなります。 これはアップストリームと対話する最初の本格的なテストになりました。私たちは、*nGnRnE*としてメモリを
マッピングするための完全に特注のメカニズムを開発し、Apple Siliconプラットフォーム上の非PCIデバイスにそれを使用するようにし
PCIドライバはnGnREモードを使用すること許可するようLinuxに指示する方法を開発しなければなりませんでした。そして、既存のコードの
邪魔せず、他のApple以外のデバイスに潜在的に役立つようにし、これらのサブシステムを担当するメンテナと合意できるような
クリーンでよくできた方法でそれを行う必要がありました。

最終的に、複数のサブシステムと複数のパッチリビジョンにまたがるカーネルのメンテナと数週間にわたって議論を重ねた結果、ほぼこの方法に落ち着きました:

- `ioremap_np()`を導入。Linuxは通常すべてのアーキテクチャにおいてMMIOデバイスのメモリをマッピングするために汎用の`ioremap()`関数を
使用する。`ioremap_wt()`のようにそれほど厳密ではない他のモードのための特別なバリアントが存在する。私たちは**n**on-**p**osted
(ポストされない)メモリ・マッピングを特に要求する新しいバリアントを追加した
- `ioremap_np()`を実装。 ARM64でnGnRnEモードを使用するためた（他のアーキテクチャでは今のところこのバリアントは未実装、
便利だと思うなら実装しても可)
- `nonposted-mmio` DeviceTreeプロパティを導入。 これを使ってDeviceTreeの特定のバスに`ioremap_np()`が必要だとを示せる
- LinuxのDeviceTreeサブシステムがデバイスを検索するときに`nonposted-mmio`モードを自動的にピックアップして、MMIOリソースを
記述する構造体内にフラグ（`IORESOURCE_MEM_NONPOSTED`）を導入
- このフラグを自動的に解釈して`ioremap_np()`を『アップグレード』する2つの高レベルAPIを作成: `devm_ioremap_resource()`と`of_iomap()`
- M1 SoCで使用する必要のある既存のドライバがまだ使用していない場合は、生の`ioremap()`の代わりにこれらのAPIのいずれかを使用するように調整

`ioremap()`を直接使用しているドライバについては若干のドライバのリファクタリングが必要ですが、これはM1に組み込まれているハードウェアに
対してのみ必要なので、変更が必要なドライバはごくわずかです。最近はPCIドライバの大部分が生の`ioremap()`を使用しており、その全てが
Thunderboltアダプタを介してM1コンピュータで使用することができます。これらのドライバを変更する必要はなく、nGnREモードを要求する
デフォルトの`ioremap()`が適切に動作します。

この変更の中でLinuxの様々な`ioremap()`モードに関するドキュメントが非常に不足していることに気がつきました。
[Arnd Bergmann氏](https://www.linuxfoundation.jp/blog/2017/11/linux-kernel-developer-arnd-bergmann/)と協力して
これらの不足しているドキュメントを追加したので、
[こちら](https://github.com/AsahiLinux/linux/blob/upstream-bringup-v3/Documentation/driver-api/device-io.rst#__iomem-pointer-tokens)
をご覧ください（変更がアップストリームにマージされたら[こちら](https://www.kernel.org/doc/html/latest/driver-api/device-io.html)にも
追加されます）。

興味深いことにこの変更は一般的な『simple-bus』デバイスに適用されるため、
[DeviceTreeのコア仕様](https://github.com/devicetree-org/devicetree-specification/pull/40)
とその[スキーマ](https://github.com/devicetree-org/dt-schema/pull/52)にパッチを提供しなければ
なりませんでした。ありがたいことにDeviceTreeはコミュニティ主導のオープンなプロジェクトなので、必要なのはGitHub PRを2つほど作成する
ことだけです。

## ほらAICだから

現代のCPUの仕事は、命令を順番に実行するだけでなく、環境の変化に対応して、実行していることをやめて別のことをしなければならないこともあります。
これは『例外(exception)』と呼ばれます。高レベルのプログラミング言語ではこれらはある種のエラーとして知られているかもしれませんが、
CPUでは外部からの注意の必要性を示すためにも使用されます（POSIXユーザースペースプログラムのSIGCHLDやSIGALRMなどのシグナルに類似）。

その中でも最も重要なのが[割り込み要求(interrupt request)](https://ja.wikipedia.org/wiki/%E5%89%B2%E3%82%8A%E8%BE%BC%E3%81%BF_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF))（IRQ）で、
ハードウェア周辺機器が[CPUの注意(attention)を喚起](https://www.youtube.com/watch?v=seKaU-qQuts)するために使われます。
CPU は OS コードを実行してどの周辺機器がattentionを必要としているかを判断して要求を処理します。

AArch64のCPUではIRQの入力は1つです。つまり、システム内のすべてのデバイスからの割り込み要求をまとめて、（OSが設定した）正しいCPUコアに
分配し、IRQが発生したときにどの基本デバイスに注意が必要かOSに伝える必要があるのです。これはLinux用語で『irqchip』と
呼ばれる割り込みコントローラの仕事です。

複数のコアを持つシステムでは、IRQコントローラーにはプロセッサ間割り込み（IPI）を処理するという別の仕事もあります。あるコアで動作している
ソフトウェアが、別のコアの注意を得たい場合があります。IPIによって可能となります。割り込みコントローラは、あるコアが割り込みコントローラに
要求を送り、その要求を割り込みとして別のコアに転送するようなメカニズムを提供します。IPIがなければマルチコアシステムは正常に動作しません。

ほとんどのAArch64システムでは
[Generic Interrupt Controller(GIC)](https://developer.arm.com/ip-products/system-ip/system-controllers/interrupt-controllers)
と呼ばれる標準的な割り込みコントローラを使用しています。
これはかなり複雑で割込みの優先順位や仮想化などの高度な機能を備えた割込みコントローラです。これはとても便利で、LinuxはほとんどのAArc64
システムでメインの割り込みコントローラとして独自のirqchipsを実装する必要がありません。

もうお分かりだと思いますが、Appleは独自の道を歩むことにしました。独自のカスタムApple Interrupt Controller (AIC)を持ちました。
私たちはこのハードウェアをリバースエンジニアリングし、それをサポートするためにLinux用の独自のirqchipドライバを構築しなければなりませんでした！
ありがたいことにAICは非常にシンプルなものです。macOS/iOSのオープンソース部分(XNU)に存在する
[数少ない古い文書](https://opensource.apple.com/source/xnu/xnu-7195.81.3/pexpert/pexpert/arm/AIC.h.auto.html)
を利用し、試行錯誤しながらハードウェアを調査することで、割り込みを動作させるために必要なことをすべて把握してLinuxドライバを書くことができました。

しかし、そこにはもう一つの問題がありました。Linuxが正常に動作するためにはIPIが必要です。具体的にはLinuxは7種類のIPIを使用しています。
つまり、7種類の独立した要求をあるCPUコアから別のCPUコアに送信し、それらを区別したイベントとして扱うことができることを想定しています。
AArch64システムで使用されている他のIRQコントローラはこのような細かいIPIの分離をサポートしています。残念ながら、AICは
そうではありません。AICは`2つ`のIPIしか対応しておらず、実際これらを異なる方法で使用するように設計されています（1つは他のCPUに
送信するためのもの、もう1つはあるコアから自分自身への『セルフIPI』のためのもので必要となる場合あり）。これをLinuxで動かせるように
するためには『仮想』割り込みコントローラを実装する必要がありました。AICドライバは、任意のCPUコアで保留されている最大32種類のイベントを
内部で管理し、そのコアの単一のハードウェアIPIを介してすべてのイベントを伝達します。IPIがそのコアに到着すると、どのイベントが保留されているかを
チェックし、あたかも別々のIPIのようにLinuxに配信します。Linuxの残りの部分は、ハードウェアが2つしかサポートしていないにもかかわらず、CPUあたり
最大32個のIPIを処理できる割り込みコントローラとして扱います（そして私たちは1つしか使いません）。ふぅ！

AICのような単純な割り込みコントローラのドライバを書くのは複雑です。割り込み処理には多くの微妙な箇所があり、コードが少しでも間違っていると
稀なイベントの連続の時にのみ現れるイライラさせる
[ハイゼンバグ(Heisenbugs)](https://ja.wikipedia.org/wiki/%E7%89%B9%E7%95%B0%E3%81%AA%E3%83%90%E3%82%B0#%E3%83%8F%E3%82%A4%E3%82%BC%E3%83%B3%E3%83%90%E3%82%B0_(Heisenbugs))を発生させ、OS全体をハングアップさせてデバッグをほぼ不可能にしてしまいます。
割り込みハンドラからデバッグ情報を出力することは厄介で、タイミングを変更することでバグが消えてしまったり、すべての処理が遅すぎて
使いものにならなくなってしまうからです。ソフトウェアIPIマルチプレクサを追加するとさらに複雑になります。通常はハードウェアで処理されるものを
ソフトウェアでエミュレートしなければならないからです。これを間違えると競合状態によるIPIの欠落などを引き起きします。

## 2021/11/10一時中断

AICのコードが正しいことを確認するためにこれらの詳細を理解しようとしている間に、私はAArch64の
[メモリオーダリング](https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%AA%E3%83%BC%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0)と
[メモリバリア](https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%90%E3%83%AA%E3%82%A2)の詳細を調べているとウサギの穴に入り込んでしまい、
ARM64 Linuxの[アトミック操作](https://www.kernel.org/doc/html/v5.10/staging/index.html#atomic-types)
の実装に[微妙なバグ](https://lore.kernel.org/linux-arm-kernel/90ea3e27-b2ef-41ac-75c7-5f0686603b2a@marcan.st/)
を発見しました！
このテーマについて話すと全体が複数のパートに分かれてしまいますが、
もっと知りたいという勇気のある方にはWill Deacon氏の講演、[こちら](https://www.youtube.com/watch?v=i6DayghhA8Q)や
[こちら](https://www.youtube.com/watch?v=6ORn6_35kKo)をお勧めします。特にこの
[コメント](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=22ec71615d824f4f11d38d0e55a88d8956b7e45f)
では多くの疑問が解消され、Will氏により自身の残りの疑問も解消されました。メモリモデルやAICコードの健全性に自信を持つことで
将来的にデバッグ作業でイライラすることがなくなるでしょう。もし、ゲーム中に特定の操作をしたときにだけ発生する微妙なGPUハングの問題
（ただしたまにしか発生せず再現には1時間かかる）を、AICドライバーの競合状態にまで遡って解明しなければならないとしたらと
想像してみてください！

良くも悪くも、M1はこういった微妙なバグを明らかにするのに好都合です。他のCPUでは決して起こらないような競合状態をくすぐるような、
非常に[out-of-orderなマシン](https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%A6%E3%83%88%E3%83%BB%E3%82%AA%E3%83%96%E3%83%BB%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC%E5%AE%9F%E8%A1%8C)です。
以前のM1n1の問題をデバッグしていたとき、M1n1が（合法的に）割り込みハンドラから
[投機的に](https://ja.wikipedia.org/wiki/%E6%8A%95%E6%A9%9F%E7%9A%84%E5%AE%9F%E8%A1%8C)
抜け出そうとしているのを見たことがあります...
コードからは、まだハンドラの途中でデバッグ情報を表示しているように見えました！この問題は結局MMUの微妙な設定ミスが原因であると
判明し、これらのコアシステムがどれほど密接に結びついているか、また、どれほどデバッグが難しいかがわかると思います。

面白いことにM1チップには標準的なGICが少しだけ搭載されています。具体的には、GICのローレベルビットをVMゲストに対してネイティブに
*仮想化*することに対応しています！こうすることで割り込み処理がはるかに高速化し、VMのハイパーバイザは割り込みコントローラを
ほとんどエミュレートせずにすみます。割り込みのたびにハイパーバイザのコードを何度も呼び出す必要があるからです。奇妙なことに...
macOSの[Hypervisor Framework](https://developer.apple.com/documentation/hypervisor/apple_silicon)はこの機能に
対応しておらず（記事執筆時点）、VMハイパーバイザーはソフトウェアで完全なGICエミュレーションを行う必要があります！私たちは
すでにこれをテストして動作していて、私はMarc Zyngier氏とともにこれらのチップ上でVMを実行する際の特殊性について研究しています。
Marc氏はすでにM1 Mac上のAsahi Linuxカーネル上で動作するKVMの上でLinuxの仮想マシンを起動しています。ベンチマークを
するにはまだ早いですが、macOSでサポートされていなくても、他の部分が整備されれば、特にIPIを多用するワークロードでは、
ネイティブのLinux-on-Linux VMがLinux-on-macOS VMよりも速くなると期待しています。

## 小うるさいFIQ

次に、すべてのOSが動作するためにはシステムタイマーが必要です。コンピュータで複数のアプリケーションを実行する場合、マルチタスクを
実現するため、OSは同じCPUコア上でアプリケーションを切り替えられるようになっている必要があります。また、特定のタイミングで何かを
実行するようにスケジューリングする機能も必要で、バッファリングされたデータをディスクに書き込んだり、YouTubeの動画の次のフレームを
表示したり、タスクバーの時計を進めたりするなどに使われます。これらはすべて、ある種のタイマーハードウェアによって実現されており、
OSは将来のある時点でIRQを送出するようプログラムすることができます。

AArch64にはシステムタイマーの仕様が含まれており、M1はこれらの標準的なタイマーを期待通りに実装しています。しかし、プラットフォーム
固有のビットがあります。タイマーはIRQコントローラ経由で割り込みを配信する必要があります。GICシステムではもちろんGICを経由します
（ただし、使用される具体的な割り込み番号はシステムごとに異なります）。Apple SiliconではAICを経由することになるでしょう。

しかし、タイマーを作動させAICに保留中の割り込みについて尋ねても...何も出てきません。どうしたものか。Appleはまた驚かせてくれます。
実はM1のタイマーはIRQを全く送れません。代わりにFIQだけが送られてきます。

AArch64のCPUにはIRQラインが1本しかないと言ったとき、よく無視される姉妹ラインであるFIQラインについては言及しませんでした。FIQ
(Fast Interrupt Requests、高速割り込み要求)とは二次的な割り込みメカニズムです。『高速』というのは古いAArch32システムでは
もっと効率的に動作していたことを意味していますが、AArc64では廃止されています。FIQとIRQは事実上同等です。GICシステムでは
OSは個々の割り込みをIRQとFIQのどちらを経由するかを設定できますが、ほとんどのAArch64システムではFIQはセキュアモニタ
（TrustZone）で使用するために確保されているので、Linuxでは使用できません。なので、LinuxはFIQを使いません。全くです。
AArch64 LinuxはFIQを期待していないので、FIQを受け取るとパニックになります。

FIQに対応していないと、M1にはタイマーがないので対応しない選択肢はありません。これは、Apple Siliconが必要としているLinux 
AArch64サポートへのもう一つの大きな変更となりました。FIQに対応するのは簡単ですが（簡単に言えばIRQの扱い方を機械的に
コピーしてFIQも同じように扱うだけ）、FIQを必要と*しない*システムではFIQをどう扱うか、FIQをどこでも有効にしておくのか、使わない
システムでは無効にするのかなど、細かい部分で色々な方法が存在しています。

最終的には、いくつかの選択肢を検討しいくつかのアプローチを繰り返した後、Linux ARM64チームのMark Rutland氏が
[ボランティアで](https://lore.kernel.org/linux-arm-kernel/20210302101211.2328-1-mark.rutland@arm.com/)
このパズルの一部を引き継ぎ、FIQ対応をLinuxに導入することになりました。

FIQを配信するものは他にもあります。実際にFIQベースの『Fast IPI』メカニズムがありますが、これはまだ使っていません。また、FIQを
利用したハードウェアのパフォーマンスカウンターもあります。実質的には、FIQは個々のCPUコアやコアクラスタに内蔵されたハードウェアで
使用され、IRQは全CPUで共有されるハードウェアを管理する単一の共有AICペリフェラルで使用されます。しかし、もう一つの痛い点として、
FIQコントローラが存在しないことが挙げられます。AICはIRQコントローラの役割を果たしていますが、これらのFIQソースはすべて1つの
FIQに『混ぜられて(mixed together)』（ORされて）おり、それらを集中的に見分ける方法がありません。その代わり、FIQ処理コードは
これらのFIQソースを1つ1つチェックし（特定のデバイス・レジスタを覗く必要があるためそれぞれに固有の方法で）、どれが注意を必要と
するかを把握してそのデバイスのドライバに割り込みを配信しなければなりません。これは非常に醜いことであり、アップルがなぜ些細な
『FIQコントローラ』を搭載しようと考えなかったのかはよくわかりません。各FIQソースのステータスを1ビットで示す1つのレジスタ
だけでも十分だったはずです。私たちはCPUの全レジスタを徹底的に探しましたが、残念ながら存在しないようです。

M1には、VMゲストのタイマー割り込みを処理するための
[特別な機能](https://github.com/asfdrwe/asahi-linux-translations/wiki/HW%3AARM-System-Registers#sys_apl_vm_tmr_lr_el2)
があります（ありがたいことにこれはVMを正常に動作させるための必要条件なのです）。
私たちはこれらの機能をリバースエンジニアリングし、Marc氏がKVMを立ち上げる作業の一部として使用しています。

コアのFIQサポートパッチに加えて、将来的にこれらのパスの間でより密接な結合を可能にするために、（厳密にはAICの一部ではないにもかかわらず）
AICドライバでダウンストリームのデバイスドライバにFIQを配布することを選択しました。これは、将来的にIRQを介したAIC IPIからFIQを介した
『Fast IPI』に切り替える際に必要になるかもしれません。

## 歴史を振り返る

デバイス上でLinuxを動かすことは素晴らしいことですが、実際に操作できなければ何の役に立つのでしょうか？`dmesg`ログを取得したり、
Linuxコンソールと対話するためには、M1用のUARTドライバが必要です。UARTにはさまざまな種類がありますが、最も人気があるのはPC標準の
[16550 UART](https://ja.wikipedia.org/wiki/16550_UART)で、最近ではあらゆる種類のARM SoCに組み込まれています。
もちろん、AppleはAppleで代わりに独自のものを開発したのでしょう...本当？

そうじゃないです！しかし16550ではありません。M1は...SamsungのUARTを採用しています？

Appleの最初のiPhoneは[Samsung製のSoC](https://www.theiphonewiki.com/wiki/S5L8900)を搭載していました。Appleが
[自社設計](https://ja.wikipedia.org/wiki/Apple_A4)に切り替えると発表したのは有名な話ですが、実際には複数のチップ世代に
わたってSamsungからの移行が遅々として進んでいませんでした。『Apple Silicon』チップは、他のSoCと同様に、
多くの企業からライセンスされた[IPコア](https://ja.wikipedia.org/wiki/IP%E3%82%B3%E3%82%A2)を
搭載しています。例えば、M1に搭載されているUSBコントローラーは[シノプシス社製](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%8E%E3%83%97%E3%82%B7%E3%82%B9)ですが、
同じハードウェアはRockchip社、TI社、NXP社のチップにも搭載されています。Appleが製造をSamsungからTSMCに変更しても、チップには
Samsungらしさが残っていました...そして、UARTのデザインは今でも残っています。これがサムスンの知的財産がM1内にも存在していることを
意味しているのか、それともアップルが単にソフトウェア互換性を保つためにインターフェースをクローンしただけなのかはわかりませんが
（UARTの設計は全く難しくない）、いずれにしても今日のExynosチップとApple Siliconにはまだ共通点が残っていることを意味しています。

というわけで、LinuxにはすでにSamsungのUART用のドライバが用意されています。しかし、そこには問題があります（当然ですが）。
『Samsung UART』は1つではありません。Appleが使用しているものはLinuxのSamsung UARTドライバでは対応していません。

同じハードウェアの多くの種類をサポートするドライバは非常に厄介で、このドライバのように古いドライバの場合はなおさらです。
さらに、Linuxのシリアルポートサブシステムは初期のバージョンにまでさかのぼり、別の次元の厄介さをもたらしています：
[この先を読む方はご注意ください。](https://www.kernel.org/doc/html/latest/driver-api/serial/tty.html)
そこで課題となるのは、コードを*悪化*させることなく、この新しいタイプのUARTのサポートを統合する方法を見つけることです。これは
リファクタリングとクリーンアップを意味します！例えば、Linux にはユーザースペースに公開されている
[シリアルポートタイプ](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/serial_core.h)の古い概念がありますが（つまり、*ユーザースペース*API は後方互換性を維持しなければならないため、これらのタイプは
追加は可能だが削除は不可能）、これは現代の Linux でのデバイスの処理方法とは完全に矛盾しています。ユーザースペースが
シリアルポートのタイプを気にする理由はまったくありませんし、もし気にするのであればハードコードされた定義リストを持つ不便な
TTY APIを使用すべきではありません（そのために[sysfs](https://ja.wikipedia.org/wiki/Sysfs)が存在）。既存のSamsung UARTの
各バリアントにはそれぞれ独自のポートタイプが定義されていましたが（実装されなかった未使用のものもあります）、さらに別のものを追加するのは
問題外でした...そこで私たちはドライバをリファクタリングし、ユーザースペースに公開されるポートタイプとは無関係に、UARTバリアントの内部
プライベートな概念を持つようにしました。Apple Silicon UARTは、このレガシーAPIに対して16550であることを示すだけで、誰も何にも
使っていません。

もう1つの課題はこのバリアントでの割り込みの処理方法です。Samsungの旧式のUARTには送信用と受信用に2つの独立した割り込み出力
があり、システムの割り込みコントローラで別々に処理されていました。新しいExynos製品ではこれを内部で処理しており、UARTの中に
小さな割り込みコントローラを設けてさまざまな種類の割り込みを処理し、それらを1つにまとめてシステムのIRQコントローラに渡しています。
Apple社の製品でもこれを行っていますが、異なるレジスタを使用した互換性のない方法で行われているため、別のコードパスを記述する必要がありました。

その上、このUARTバリアントはエッジトリガー割り込みしかサポートしていません。
[エッジトリガ割り込み](https://en.wikipedia.org/wiki/Interrupt#Edge-triggered)とは、特定の*イベント*が発生したときに、
そのイベントが発生した瞬間にのみ発生する割り込みのことで、例えば、UARTの送信バッファが空に*なった*ときなどに発生します。
逆に、[レベルトリガー割り込み](https://en.wikipedia.org/wiki/Interrupt#Level-triggered)は、ある*条件*が真である限り発生し、
その条件がクリアされるまで発生し続ける割り込みです：例えば、送信バッファが空の*まま*ならです。様々な理由からレベルトリガー割り込みは
扱いやすく、最近のシステムでは好まれています。AIC自体はレベルトリガー割り込みを使用しており、UART自体からの割り込みもレベルトリガーですが、
それを駆動する内部イベント（送信バッファや受信バッファが空になったり満杯になったり）はエッジトリガー方式でのみ動作します！Samsungの
他の UART タイプは両方のモードをサポートしており、Linux はそれらをレベルトリガーモードで使用します。これがUART経由でデータを
送信するLinuxのコードに問題を引き起こしました。既存のコードは送信機をオンにするだけで何もしないで動作していました。
すべてがレベルトリガーモードで構成されている場合、送信バッファが空になると直ちに割り込みが発生し、ドライバ内の割り込みハンドラが最初に
送信するデータでバッファを埋めます。エッジトリガーモードでは、バッファが空に*なる*のではなく*すでに*空になっているので、これは
機能しません。何も起こらず、ドライバーはデータを送信しません。そこで、データをデバイスに送信できる状態になったら、すぐに
ドライバが送信バッファを『プライム』するようにしなければなりません。なぜなら、最初のデータの塊が送信されて初めて、割り込みが
発生してデータの追加を要求するからです。

実験にはm1n1を使用していましたが、m1n1自体がUARTで制御されているため、UARTのこのようなクセを理解するのは二重に混乱しました。
デバッグ用の通信チャネルがデバイスそのものである場合にデバイスの動作を理解しようとすると非常に混乱してしまいます！ありがたいことに、
今ではこれがすべて完了してm1n1を使ってハードウェアの他の部分を操作するのがより快適になりました。

同じ処理をしなければならないドライバーがもう一つありますが、その系統は全く異なります。M1チップの
[I²C](https://ja.wikipedia.org/wiki/I2C)ハードウェアの由来は...
[P.A.Semi](https://en.wikipedia.org/wiki/P.A._Semi)です！M1のI²Cペリフェラルは
[AmigaOne X1000](https://en.wikipedia.org/wiki/AmigaOne_X1000)をはじめとする
[PWRficient](https://en.wikipedia.org/wiki/PWRficient)のチップに搭載されているものをベースにしています。
Linuxはこのプラットフォームに対応していますが、既存のドライバは非常に素っ気ないものです。幸いなことに、ドライバの作者に連絡を
取ったところ、彼はまだ機能するX1000を所有しており、パッチをテストできることが判明しました。そのチップのハードウェアドキュメントを
入手できたので、ドライバを改良し、X1000で動作するであろう欠けていた機能（割り込み対応など）を追加したり、M1への対応に必要な変更を
加えたりすることができました。このドライバーはUSB Type-Cポートを完全に動作させるために必要なものなので、この作業はまもなく
開始される予定です。

## 最後のペンギン

拍子抜けするほどLinuxのbring-upの話を終わらせるために、LinuxのフレームバッファコンソールをM1で動作させるために必要なことを
話しましょう。ここでさらに2000字を期待していた方は残念ながら失望することになるでしょう。

PCではUEFIファームウェアがフレームバッファを設定し、`efifb`というドライバを使うことで適切なディスプレイドライバを一切使わずに
Linuxを動かすことができます。AppleのシリコンMacもほぼ同様です。iBootでフレームバッファを設定してOSが使えるようにしています。
必要なことは一般的な`simplefb`というLinuxドライバを使うことだけで、コードを全く変更せずに動作します。DeviceTree
バインディングの変更を文書化する必要があったのは、必要なのに文書化されていない機能にコードが既に対応していたからです。

そして、すべての作業の後DeviceTreeに数行加えるだけで、真っ白な画面がこのように変わりました:

![image](https://asahilinux.org/img/blog/2021/03/penguins.png)

m1n1は、iBootから渡されたフレームバッファの情報（幅、高さ、ピクセルフォーマット、ストライド、ベースアドレス）を、Linuxが
使えるようにDeviceTreeに貼り付けて、これを適切に行うようになりました。

もちろん、これはあくまでもファームウェアが提供するフレームバッファです。ちゃんとしたディスプレイドライバではないので、
解像度の変更やディスプレイのホットプラグに対応する方法はなく、ディスプレイをスリープさせることもできません。
開発やデモには十分ですが、いずれは適切な
[ディスプレイコントローラドライバ](https://en.wikipedia.org/wiki/Video_display_controller)を書かなければなりません。

そしてもちろん、ディスプレイコントローラ*ではなく*、論理的に独立したハードウェアである
[GPU](https://ja.wikipedia.org/wiki/Graphics_processing_unit)もあります。PCユーザはこの2つをよく融合します。
『グラフィックカード』として一つのちっ日にパッケージされてやってくるからです...しかし、論理的にはまったく
別のものであり、M1のようなSoCでは、ディスプレイコントローラとGPUの関係はUSBコントローラとGPUと同じくらいの関係があります。
GPUへの対応は独自の道を歩むことになるので、今後の情報を楽しみにしてください！

## まだまだありますよ！

深い話をすればあと1万字はかかるでしょうけど、残念ながらこの記事はもう長すぎます。しかし、この2ヶ月間にコミュニティで
起こったことをもっとチェックしたいという方のために、見逃せないものをリストアップしてみました:

- [Alyssa氏](https://rosenzweig.io/)によるM1 GPUのリバースエンジニアリング
（[パート1](https://rosenzweig.io/blog/asahi-gpu-part-1.html)、[パート2](https://rosenzweig.io/blog/asahi-gpu-part-2.html)）
- [Dougall氏](https://twitter.com/dougallj)の
[GPU ISA文書](https://dougallj.github.io/applegpu/docs.html)、
[CPUマイクロアーキテクチャ文書](https://dougallj.github.io/applecpu/firestorm.html)、
[AMX命令セット文書](https://gist.github.com/dougallj/7a75a3be1ec69ca550e7c36dc75e0d6f)
- [Iris氏](https://twitter.com/modwizcode)による
[QEMUのM1対応導入](https://twitter.com/modwizcode/status/1360308258519605254)作業
- Mark氏の[U-Boot](https://github.com/kettenis/u-boot/commits/apple-m1) と 
[OpenBSD](https://marc.info/?l=openbsd-arm&m=161386122115249&w=2) の M1 への移植作業。すでにPCIe対応済み！
- [Sven氏](https://twitter.com/svenpeter42)の
[DART](https://github.com/AsahiLinux/m1n1/pull/33/files) と Apple の IOMMU のリバースエンジニアリング作業

私たちの現在の Linux bring-upシリーズは
[第3版](https://lore.kernel.org/linux-arm-kernel/20210304213902.83903-1-marcan@marcan.st/#t)で、アップストリームに含めるためにレビューされています。
この記事の内容がどのようにコードに反映されているかを知りたい方はパッチをチェックしてみてください。プロセスがどのように
進むか見たいならば、[第1版](https://lore.kernel.org/linux-arm-kernel/20210204203951.52105-1-marcan@marcan.st/#t)や
[第2版](https://lore.kernel.org/linux-arm-kernel/20210215121713.57687-1-marcan@marcan.st/#t)のスレッドをご覧ください。
すべてがうまくいき、新たな障害がなければ、これは Linux 5.13 にマージされる予定です。ご期待下さい！

Asahi Linuxは、組み込み開発初心者からハードウェアエンジニアやベテランのカーネル担当者まで、プロジェクトを前進させるために
参加してくれた人々のコミュニティ全体なしでは実現できませんでした。もし貢献することに興味があるならば、私たちの
[コミュニティ](https://asahilinux.org/community)ページをチェックして、IRCチャンネルに参加してください！

個人的な話になりますが、私はAsahi Linuxをフルタイムの仕事にしようとしています。もしあなたが私のやっていることを気に入って
くださり、プロジェクトにもっと時間を割きたいと思ってくださるのであれば、
[Patreon](https://www.patreon.com/marcan)や
[GitHub](https://github.com/sponsors/marcan)で私をサポートしてください。これまでに寄付をしてくださった皆様に感謝します。
皆様なしではこのプロジェクトは実現できませんでした！

この記事を校正してくださったJMC47氏、[David氏](https://twitter.com/david_rysk)、
[Ridley氏](https://twitter.com/11rcombs)に感謝します。

#### marcan · 2021-03-11
