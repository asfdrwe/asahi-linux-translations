[Tales of the M1 GPU](https://asahilinux.org/2022/11/tales-of-the-m1-gpu/)の非公式日本語訳です。

訳注
- まだDeepLの結果を貼っただけ
- Githubのmarkdownで使えないiframeでのtwitterやMastodonへの埋め込みをリンクに置き換え
- Asahi Linuxブログへのリンクは対応する日本語訳へのリンクに変更

---
# M1 GPU物語

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202211.md)

みなさんこんにちは、朝日リナです！✨。

marcanさんから、M1 GPUの記事を書いてほしいと頼まれたので、書いてみました〜! この数ヶ月の道のりは長く、
取り上げたいこともたくさんあるので、ぜひ楽しんでくださいね！

![Apple M2上で動作するXonotic](https://asahilinux.org/img/blog/2022/11/m2gpu.png)

## GPUって何？

GPUが何であるかは知っているとは思いますが、内部でどのように機能しているかはご存知でしょうか？
では、見てみましょう！最近のGPUはほとんどすべて同じメインコンポーネントを持っています:

- `シェーダコア`の集まり: ユーザー定義のプログラムを実行することで、三角形（頂点データ）とピクセル（断片データ）を処理します。これらは GPU ごとに異なるカスタム命令セットを使用します。
- `ラスタライズユニット、テクスチャサンプラー、レンダー出力ユニット`: シェーダーと一緒に動作するその他のビットが、アプリからの三角形を画面上のピクセルに変換します。これが正確にどのように動作するかはGPU によって異なります！
- `コマンドプロセッサ`: アプリから描画コマンドを受け取り、コマンドを処理するためにシェーダコアをセットアップします。これには、どの三角形のリストを描画するか、どのグローバル属性を使用するか、どのテクスチャを使用するか、どのシェーダプログラムを使用するか、最終的な画像はメモリ内のどこに格納されるか、などのデータが含まれます。そして、このデータをシェーダーコアなどのユニットに送り、実際にレンダリングを行うようGPUをプログラムします。
- `メモリ管理ユニット`（Memory Management Unit, MMU）:GPUを使用する特定のアプリに属するメモリ領域へのアクセスを制限し、異なるアプリがクラッシュしたり、互いに干渉したりしないようにする役割を担っています。

(これはすべて非常に単純化されたもので、実際には GPU によって異なる部分がもっとたくさんあります。が、これらは最も重要な部分です!)

これらすべての可動部を十分安全に処理するために、最近の GPU ドライバは`ユーザースペースドライバ`と`カーネルドライバ`の 2 つに分かれています:
ユーザースペースドライバはシェーダプログラムのコンパイルと API 呼び出し（OpenGL や Vulkan など）を特定のコマンドリストに翻訳する役割を
担い、コマンドプロセッサがシーンのレンダリングに使用します。一方、カーネルドライバは、MMU を管理し、異なるアプリからのメモリ割り当て/解放を
処理する役割を担い、コマンドプロセッサにコマンドを送信する方法とタイミングを決定する役割を担っています。最近の GPU ドライバはすべて、
すべての主要 OS でこのように動作します！

ユーザースペースドライバとカーネルドライバの間には、各 GPU ファミリ用にカ スタマイズされた何らかのカスタム API が存在します。
これらの API は通常ドライバごとに異なります！ Linux ではこれを UAPI と呼びますが、どの OS も似たようなものを持っています。
この UAPI は、ユーザースペースドライバがカーネルドライバにメモリの割り当て/解 放を依頼したり、コマンドリストを GPU に
送信したりするためのものです。

つまり、Asahi LinuxでM1 GPUを動かすには2つの要素が必要です: カーネルドライバとユーザースペースドライバです！ 🚀

## Alyssaさんがプロジェクトに参加

Asahi Linuxがスタートした2021年にさかのぼります。Alyssa Rosenzweigさんがプロジェクトに参加し、M1 GPUのリバース
エンジニアリングの作業を開始しました。[Dougall Johnsonさん](https://mastodon.social/@dougall)（GPUシェーダー
アーキテクチャの文書化に注力）と共に、シェーダーやレンダリングの設定に必要なすべてのコマンドリスト構造を含む、すべての
ユーザースペースビットのリバースエンジニアリングを開始しました。これは大変な作業ですが、1ヵ月も経たないうちに、
[すでに最初の三角形を描いていたのです](https://rosenzweig.io/blog/asahi-gpu-part-2.html)！ 素晴らしいです。
もしまだM1 GPUを解剖するシリーズをチェックしていないなら、Alyssaさんの[ウェブサイト](https://rosenzweig.io/)
を訪れて見てみてください ✨✨

でも、カーネルドライバもないのに、どうやってユーザースペースドライバに取り組んだのでしょうか？簡単です、macOSで行いました! 
AlyssaさんはmacOSのGPUドライバのUAPIをリバースエンジニアリングして、メモリを割り当てたり、GPUに自分のコマンドを
送信できるようにしました。これは超クール！ Alyssaさんは、Linuxのユーザー空間グラフィックススタックである
[Mesa](https://www.mesa3d.org/)用のM1 GPU OpenGLドライバを書き始め、わずか数ヶ月後には、もう
[OpenGL ES 2適合性テストの75%:(https://rosenzweig.io/blog/asahi-gpu-part-4.html)を、
すべてmacOS上でパスしていたのです！

今年の初めにAlyssaさんの成果は完全にオープンソースのMesa OpenGLスタックでmacOS上のAppleのカーネル
ドライバの上で動作する[ゲーム](https://rosenzweig.io/blog/asahi-gpu-part-6.html)を走らせるまでになりました！
しかし、Linuxカーネルドライバはまだありません...この部分を手助けする時が来ました! ✨

## 謎のGPUファームウェア

今年の4月、M1 GPUのカーネルドライバの書き方を調べ始めることにしました！開始したころには、
[Scott Mansellさん](https://github.com/phire)がすでにその方面でちょっとした調査をしていて…
これが普通のGPUでないことが明らかになっていました。最初の数ヶ月間、GPU 用の 
[m1n1 ハイパーバイザー](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202108.md#m1n1%E3%83%8F%E3%82%A4%E3%83%91%E3%83%BC%E3%83%90%E3%82%A4%E3%82%B6%E3%81%AB%E3%82%88%E3%82%8B%E3%83%8F%E3%83%BC%E3%83%89%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%83%AA%E3%83%90%E3%83%BC%E3%82%B9%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0)トレーサーを書き改良することに取り組みましたが、見つけたものはGPU の世界ではとてもとても珍しいものでした。

通常、GPU ドライバは、GPU 上の作業のスケジューリングと優先順位付け、およびアプリが GPU を公平に使用できるよう、
実行に時間がかかりすぎるジョブのプリエンプトといった事柄を担っています。電源管理はドライバが担当することもありますし、
電源管理コプロセッサ上で動作する専用のファームウェアが担当することもあります。また、コマンド処理の詳細を引き受けている
他のファームウェアがある場合もありますが、それはほとんどカーネルドライバからは見えません。つまり、特に ARM Mali の
ような単純な『モバイルスタイル』GPU では、GPU に何かをレンダリングさせるための実際のハードウェアインタフェースは、
通常かなり単純になっています。標準的な CPU MMU または IOMMU のように動作する MMU があり、コマンドプロセッサは通常、
ある種のレジスタまたはリングバッファでユーザースペースのコマンドバッファへのポインタを直接取ります。Linux カーネルの 
DRM (Direct Rendering Manager) サブシステムは、ドライバを簡単に書けるように、すでに多くのヘルパーを提供しています。
プリエンプションのようなトリッキーな部分はありますが、は真新しいドライバで GPU を動作させるために重要なものではありません。
しかし、M1 GPU は違います…

M1チップの他の部分と同様に、GPUには 『ASC』と呼ばれるコプロセッサがあり、Appleファームウェアを実行し、GPUを管理します。
このコプロセッサは、RTKitと呼ばれるApple独自のリアルタイムOSを実行する完全なARM64 CPUで…すべてを管理しています！
電源管理や、コマンドのスケジューリングとプリエンプション、障害回復、さらにはパフォーマンスカウンタや統計、温度測定と
いったものまで扱えるのです！ 実は、macOSのカーネルドライバは、GPUハードウェアとまったく通信しません。GPU との通信は
すべてファームウェアを介して行われ、共有メモリ内のデータ構造を使ってGPU に何をすべきかを指示します。そして、
そのような構造体がたくさん存在しています…

- ``初期化データ``:ファームウェアの電源管理設定やその他のGPUグローバル設定データに使用され、なんらかの理由で色空間変換テーブルも含まています？！ これらのデータ構造には1000近いフィールドがありますが、まだすべて把握できていません。
- ``サブミッションパイプ``： GPUの作業をキューイングするためのリングバッファです。
- ``デバイスコントロールメッセージ``：GPU のグローバルなオペレーションを制御するために使用されます。
- ``イベントメッセージ``：何かが起こったとき、ファームウェアがドライバに送り返します （コマンドの完了や失敗など）。
- ``統計、ファームウェアログ、トレースメッセージ``: GPU の状態情報とデバッギングに使われます。
- ``コマンドキュー`` : 一つのアプリの保留中の GPU 作業のリストを表します。
- ``バッファ情報、統計、およびページリスト構造`` : [タイル化頂点バッファ(Tiled Vertex Buffer)](https://rosenzweig.io/blog/asahi-gpu-part-5.html)の管理に使われます。
- ``コンテキスト構造体`` およびその他のビット: GPU ファームウェアが何が起こっているのかを追跡できます。
- ``頂点レンダリングコマンド``: ユーザースペースからのコマンドとシェーダをどのように処理してレンダリングパス全体の頂点部分を実行するかをGPUの頂点処理やタイリングパートに指示します。
- ``フラグメントレンダリングコマンド``：、頂点処理から実際のフレームバッファにタイル化された頂点データをレンダリングする方法をGPUのラスタライズとフラグメント処理パートに指示します。

もっと複雑です！頂点とフラグメントのレンダリングコマンドは、実際に本当に複雑な構造で、その中に多くの入れ子構造があり、
さらに各コマンドは、実際には、カスタム仮想 CPU のように GPU ファームウェアによって解釈される小さなコマンドの
『マイクロシーケンス』へのポインタを持っています！ 通常、これらのコマンドはレンダリングパスを設定し、完了するのを待ち、
クリーンアップします…しかし、タイムスタンプコマンドや、ループ、演算などにも対応しています！ すごい！
そして、これらの構造にはすべて何がレンダリングされるのかについて関連する詳細を記入する必要があります。
たとえば、深度バッファとステンシルバッファへのポインタ、フレームバッファのサイズ、MSAA（Multisample Anti-Aliasing）が
有効かどうかとその設定、特定のヘルパーシェーダプログラムへのポインタ、などなどです！

実際、GPU ファームウェアは GPU MMU と奇妙な関係を持っています。同じページテーブルを使うんです！ ファームウェアは
文字通り、GPU MMU が使用する同じページテーブルベースのポインタを取り、それを ARM64 ページテーブルとして構成します。
つまり、GPU のメモリがファームウェアのメモリになるのです！ すごい！ 共有の『カーネル』アドレス空間（Linuxの
カーネルアドレス空間に類似）が存在し、ファームウェアが自分自身とドライバとの通信の大部分に使います。そして、
いくつかのバッファはGPUハードウェア自身と共有し、GPUを使う各アプリ用に別のアドレス空間にある『ユーザ空間』のアドレスを
保持しているのです。

では、この複雑なものをすべてユーザースペースに移動して、頂点／フラグメントのレンダリングコマンドをすべてセットアップ
させることができるでしょうか？いいえ、できません！これらの構造体はすべて、ファームウェア自身と一緒に共有カーネルアドレス空間にあり、
互いに大量のポインタを持っているので、GPU を使う異なるプロセス間で分離されていないのです！ なのでアプリに
直接アクセスさせることを諦めました。互いのレンダリングを壊してしまう可能性がありますので。これがAlyssaさんがmacOS UAPIにある
レンダリングの詳細を見つけられた理由です。

## PythonでGPUドライバ？！

GPUが動作し、ファームウェアがクラッシュしないためには、これらすべての構造を正しく取得することが重要です。
なので、リバースエンジニアリングしながら、素早く実験する方法が必要でした。ありがたいことに、Asahi Linuxプロジェクトには、
すでにこのためのツールがあります。m1n1 Python フレームワークです。すでにm1n1ハイパーバイザー用のGPUトレーサを書き、
Pythonで構造体定義を記述していたので、それをひっくり返して、同じ構造体定義を使って、Python GPUカーネルドライバを
書き始めることにしました。Pythonは、繰り返し使うのがとても簡単なので、これには最適です！さらに良いことに、Pythonは
すでに基本的なRTKitのプロトコルを話すことができ、クラッシュログを解析することができます。USB経由でM1マシンに接続した
開発マシン上でスクリプトを実行することでこれらが行われます。そのため、何かをテストするたびに簡単に再起動でき、
テストサイクルは非常に高速になっています！

最初に、ドライバのほとんどが[ハードコードされた構造体の集まり](https://github.com/AsahiLinux/m1n1/blob/main/proxyclient/experiments/agx_1tri.py)でしたが、最終的にはそれらを正しく動作させ、三角形をレンダリングすることに成功しました!

[埋め込みツイート1](https://twitter.com/LinaAsahi/status/1532028228189458432) (訳注: 三角形を表示させています)

このデモは、ただ単に作り込まれたものですが…Linuxカーネルドライバに取りかかる前に、ドライバを適切に設計するために、
すべてを本当によく理解していることを確かめたかったのです。ただ1つのフレームをレンダリングするのは簡単ですが、
私は複数のフレームをレンダリングできるようにしたかったし、コンカレンシーやプリエンプションといったことも
テストしたかったのです。だから、本当の意味での『カーネルドライバ』が必要だったのですが…それはPythonでは不可能ですよね？！

Mesa には [drm-shim](https://gitlab.freedesktop.org/mesa/mesa/-/tree/main/src/drm-shim) と呼ばれるものが
存在することがわかりました。これはLinuxのDRMカーネルインターフェイスをモックして、ユーザースペースの
ダミー処理に置き換えるライブラリです。通常、これはシェーダーCI(訳注: Continuous Integration、継続的インテグレーション)
などに使われますが、もっとおかしなことにも使えます…つまり、drm_shimの中にPythonインタプリタを突っ込んで、
そこからPythonドライバのプロトタイプ全体を呼び出してみたらどうでしょうか？

drm-shimの上で、AlyssaのMesa M1 GPUドライバを使って[Inochi2D](https://inochi2d.com/)を実行し、
Pythonインタプリタを組み込み、m1n1開発フレームワークの上でPythonプロトタイプドライバにコマンドを送り、
本物のM1マシンとUSBで通信してすべてのデータをやり取りして、GPUファームウェアと自分のレンダリングを
ドライブすることなんてできるでしょうか？そんなバカげたことありえますかの？

バカバカしいからこそうまくいきました！ ✨

[埋め込みツイート2](https://twitter.com/LinaAsahi/status/1537828477352615936) (訳注: M1GPUを外部GPU(eGPU)として動作させています)

## Linuxカーネルのための新しい言語

エルドリッチホラー(訳注:　ボードゲーム)な Mesa+Python ドライバスタックが動いたので、最終的なカーネルドライバがどのように動作し、
何をしなければならないかについて、より良いアイディアがうまれはじめました。そして、そのためにたくさんのことをしなければなりませんでした！
100以上のデータ構造を扱うのはどうしようもないです…もし何か間違いがあれば、すべてが壊れてしまいます！ ファームウェアは
（おそらく性能のため）何もサニティチェックをせず、もし悪いポインタやデータに遭遇したら、ただクラッシュするか、やみくもにデータを
上書きしてしまいます！さらに悪いことに、ファームウェアがクラッシュした場合、回復する唯一の方法はマシンを完全に再起動することです！ 😱

Linux カーネルの DRM ドライバは C 言語で書かれており、C 言語は複雑なデータ構造管理を書くのに最適な言語ではありません。
すべてのGPUオブジェクトの寿命を手動で追跡する必要があり、何か間違いがあれば、ランダムなクラッシュやセキュリティ脆弱性の
原因になる可能性もあります。どうやってこれをやりとげればいいでしょうか？間違えそうなことが多すぎるし、C言語は
全然助けてくれないですし！

その上、複数のファームウェアのバージョンに対応しなければならないのですが、Appleはファームウェアの構造定義をバージョンごとに
安定させてはくれません！ 実験的に第2版に対応したのですが、結局、データ構造に100以上の変更を加えなければなりませんでした。
Pythonのデモでは、構造体のフィールドをバージョン番号で条件付けするような凝ったメタプログラミングで対応できましたが…
Cにはそういうのがないんです。ドライバ全体を異なる``#define``で何度もコンパイルするようなハックを使う必要があるんです！

しかし、新しい言語が現れました…

ちょうど同じ頃、RustがもうすぐLinuxカーネルに正式採用されるという噂が出始めました。[Rust for Linux](https://github.com/Rust-for-Linux)プロジェクトは、数年前から公式に対応を追加するための作業を行っており、その作業はもうすぐ統合されそうでした。
GPUドライバをRustで書けそう？

Rustの経験はあまりありませんでしたが、読んだ限りでは、GPUドライバを書くにはずっと良さそうな言語に見えました！
特に気になったのは次の2点です：
GPUファームウェアの構造体のライフタイムのモデル化に役立つかどうか（これらの構造体はGPUポインタとリンクしていますが、
CPUから見ると本物のポインタではありません）と、Rustマクロがマルチバージョンアップの問題を処理できるかどうかです。
そこで、カーネル開発に入る前にRustの専門家に助けを求め、シンプルなユーザ空間のRustでGPUオブジェクトモデルの[おもちゃのプロトタイプ](https://github.com/asahilina/gpu-rust-playground)を作りました。Rust コミュニティはとてもフレンドリーで、
何人かの人がすべての工程を案内してくれました。Rustコミュニティはとても親切で、何人かの人がすべてを教えてくれました！
皆さんの助けなしには、実現できませんでした！❤

うまくいきそうな感じでした！ しかし、RustはまだメインラインのLinuxに受け入れられておらず…そして、誰もこのようなことを
したことがなかったので、未知の領域に入ることになりました。しかし、考えれば考えるほど、私の心はRustが行くべき道で
あることを告げていました。Linux DRM メンテナや他の人たちとこの件について話をしましたが、彼らは熱心で、少なくとも
このアイデアを受け入れているようだったので…

それで、実行することにしました！

# ここまで作業完了(2022/12/3)

## Rust の始まり

これは最初の Linux Rust GPU カーネルドライバになるので、たくさんの仕事が待っていました! ドライバそのものを書くだけでなく、Linux DRM グラフィックスサブシステム用の Rust 抽象化も書かなければなりませんでした。RustはCの関数を直接呼び出すことができますが、その場合、Rustの安全性が保証されません。そのため、RustからCのコードを安全に使うには、まず安全なRustライクなAPIを提供するラッパーを書かなければなりません。結局、抽象化のためだけに1500行近くのコードを書くことになり、安全で良い設計を考え出すのに何度も書き直しました

8月18日、Rustドライバを書き始めました。当初はMMUの処理にCのコード（Panfrostドライバから部分的にコピー）を使っていましたが、その後、すべてをRustで書き直すことにしました。その後、数週間かけて、以前プロトタイプしたRust GPUオブジェクトシステムを追加し、Pythonデモドライバの他の部分をすべてRustで再実装しました。

Rustを使えば使うほど、Rustの魅力に取り付かれていきました。Rustのデザインは、良い抽象化とソフトウェアデザインに導いてくれるように感じます。コンパイラは非常にうるさいですが、一度コードがコンパイルされれば、確実に動作するという確信を与えてくれます。時には、使おうとしている設計にコンパイラが満足せず、その設計に根本的な問題があることに気づくこともありましたよ。

ドライバは徐々に完成し、9月24日、ついにkmscubeが私の真新しいRustドライバで最初のキューブをレンダリングするようになりました!

[埋め込みツイート3](https://twitter.com/LinaAsahi/status/1573488347250536449) (訳注: Linux上のRustドライバで立方体を表示)


そして、魔法のようなことが起こりました。

[埋め込みツイート4](https://twitter.com/LinaAsahi/status/1575345368018997248) (訳注: GNOME Waylandが動作)


その数日後、私は完全な GNOME デスクトップ・セッションを実行することができたのです!

## Rust は魔法のようです。

通常、これほど複雑な新しいカーネルドライバを書くと、単純なデモアプリから、複数のアプリが同時にGPUを使用するフルデスクトップに移行しようとすると、あらゆる種類の競合状態、メモリリーク、ユースアフターフリー問題など、あらゆる悪条件が引き起こされることになります。

でも、そんなことは起きなかったんです。いくつかのロジックバグと、メモリ管理コードのコアにある1つの問題を修正するだけで、あとはすべてが安定的に動作するようになりました Rustは本当に魔法のようです。Rustの安全機能は、安全でない部分に問題がない限り、ドライバの設計がスレッドセーフとメモリセーフであることを保証してくれるのです。安全なだけでなく、良い設計に導いてくれるのです。

もちろん、安全でない部分もありますが、Rustは安全な抽象化されたコードで考えるので、バグの可能性のある部分を非常に少なくすることができるのです。それでも安全性に問題はありました。例えば、DRMメモリ管理の抽象化には、アロケータがそのすべての割り当てを解放する前に解放されてしまうというバグがありました。しかし、この種のバグはある特定のコードに特有のものなので、ドライバ全体に及ぶ捕捉困難な競合状態やエラーケースではなく、明白な（監査やコードレビューで捕捉できる）主要なものになる傾向があります。結局、他のすべてのものとの相互作用ではなく、特定のコードモジュールや安全に関連する部分について個別に考えるだけでよいので、心配するバグの可能性をごくわずかな数に減らすことができるのです。Rustを試したことがないと説明しにくいのですが、これは大きな違いです。

さらに、エラーとクリーンアップの処理もあります。C言語ではリソースをクリーンアップするために、エラーを起こしやすいgoto cleanupスタイルのエラーハンドリングが、Rustではすべて...消え去りました。それだけでも価値があります。さらに、本物のイテレータを手に入れ、参照カウントも自動化されました。❤

[埋め込みツイート5](https://twitter.com/LinaAsahi/status/1575345368018997248) (訳注: Rustでのkernelコード)

## 力を合わせること

カーネルドライバが正しい軌道に乗ったので、Alyssaと力を合わせて一緒に仕事を始める時が来ました! macOS でのテストに縛られることなく、彼女は Mesa ドライバに大きな改良を加え始めました! 私も少しばかりお手伝いしました^^。

私たちはXDC 2022で共同講演を行い、そのとき私たちのドライバを使って講演全体をM1で実行したんです! それ以来、私たちは新機能の追加、バグフィックス、パフォーマンスの改善を双方で行っています。私は、M1 Pro/Max/Ultra ファミリーと M2 のサポートをカーネル側に追加し、より良いデバッグ・ツールやメモリ割り当て性能の改善も行いました。彼女は、GL conformace を着実に改善し、OpenGL ES 2.0 conformance は事実上完了し、3.0 conformance は 96% 以上を達成しました！彼女は、OpenGL ES 2.0 と 3.0 conformace の両方をサポートしました。また、多くの新機能とパフォーマンスの改善も行い、現在では Xonotic や Quake のようなゲームを 4K でプレイすることができます!

[埋め込みMastodon1](https://social.treehouse.systems/@alyssa/109311591472543702/) (訳注: 3DゲームがLinux上のApple GPUで4kで動作)
[埋め込みMastodon2](https://vt.social/@lina/109405566112910885/) (訳注: KDEが動作)

また、GPUの電源管理はファームウェアによって行われるため、これらすべてがうまく機能します。GNOME セッションで Xonotic を 1080p でテストしたところ、バッテリーの推定駆動時間は 8 時間以上でした! 🚀

Vulkanのサポートはどうなっていますか？心配しないでください...Ellaはそれに取り組んでいます! ✨

[埋め込みツイート6](https://twitter.com/EllaStanforth/status/1584316751591878656) (訳注: VulkanのVKCUBEが動作)


## 次はどうする？

まだ長い道のりが待っています! 今使っているUAPIはまだプロトタイプで、将来的に完全なVulkanドライバをサポートするために追加または再設計が必要な新機能がたくさんあるんだ。Linuxは、（macOSとは異なり）UAPIの安定性とバージョン間の後方互換性を維持する必要があるため、GPUレンダリングパラメータをより完全に理解し、Vulkanが必要とする新しい設計機能をすべて実装するまで、カーネルドライバは何ヶ月もアップストリームに向かうことがない、ということです。現在のUAPIにはパフォーマンス上の制限もあり、GPUレンダリングをCPU処理と同時に実行することもまだできません

そしてもちろん、ユーザースペース側には、コンフォーマンスとパフォーマンスを改善し、より多くのGL拡張と機能のサポートを追加するという、やるべきことがまだたくさんあるのです! テッセレーションやジオメトリシェーダのようないくつかの機能は、（部分的または完全にエミュレートする必要があるため）実装が非常に難しいので、かなり長い間、完全なOpenGL 3.2+を期待しないでください。

しかし、そのような制限があっても、ドライバは今日、安定したデスクトップを動かすことができ、パフォーマンスは毎週向上しています! Wayland は現在これらのマシン上で美しくスムーズに動作し、まるでネイティブの macOS デスクトップのようです! Xorg も、私が数日前にディスプレイドライバに行ったいくつかの改良でうまく動きますが、Xorg の設計上の制限により、テアリングと vsync の問題が予想されます。Wayland は新しいプラットフォームでは本当に未来なのです! 💫

で、どこで手に入れるの？私たちはまだそこに到達していません! 現在、ドライバスタックのビルドとインストールは複雑になっています (カスタム m1n1、カーネル、および mesa ビルドが必要です) ので、もう少しだけお待ちください! まだまだ未完成ですが...年内にはAsahi Linuxのオプトインテストビルドとして提供できればと思います! ✨✨

もし、私のGPUでの作業に興味があれば、@lina@vt.social で私をフォローするか、私のYouTubeチャンネルを購読してください! 明日はM1 Pro/Max/UltraとM2の消費電力計算を解明する予定です！！よろしくお願いします。✨

私の仕事を応援したい方は、GitHub SponsorsにあるmarcanのAsahi Linuxサポートファンドに寄付するか、Patreonに寄付すると、私も助かりますよ。そして、もしあなたがVulkanドライバを楽しみにしているなら、EllaのGitHub Sponsorsのページをチェックしてみてください Alyssaは自分では寄付を受け付けていませんが、代わりにSoftware Freedom Conservancyのような慈善団体に寄付してくれるとうれしいです。(いつか彼女を説得してM2を買わせてもらうかもしれませんが...^^;;)

#### Asahi Lina 2022-11-29
