`Energy Aware Scheduling <https://docs.kernel.org/scheduler/sched-energy.html>`_  の非公式日本語訳です。
ライセンスは原文のライセンス(GPL-2.0のはず)に従います。

訳注: 

* DeepLの結果を貼っただけ(2024/3/8)

=======================
Energy Aware Scheduling(エネルギーを反映したスケジューリング)
=======================

1. はじめに
----------

エネルギー・アウェア・スケジューリング(EAS)は、スケジューラに、その決定がCPUの消費エネル ギーに与える影響を予測する能力を与える。
EASは、スケジューラの決定がCPUの消費するエネルギーに与える影響を 予測する能力を与える。EASは
EASは、各タスクに対してエネルギー効率の良いCPUを選択するために、CPUのエネルギーモデル(EM)に依存します、
を選択する。このドキュメントの目的は
EASがどのように動作するのか、その背後にある主な設計上の決定とは何か、そしてEASを動作させるために必要なことは何かについて紹介する。
EASを実行するために必要なことの詳細を説明する。

先に進む前に、執筆時点では以下のことに注意してください：

   /EASは対称的なCPUトポロジーを持つプラットフォームをサポートしていません。

EASは異種CPUトポロジー（Arm big.LITTLEなど）でのみ動作します。
EASは異種CPUトポロジー(Arm big.LITTLEなど)でのみ動作します。
最も高いからです。

EASが実際に使用するEMは、スケジューラではなく、専用のフレームワークによって管理されます。
専用のフレームワークによって管理される。このフレームワークとそれが提供するものの詳細については、そのドキュメントを参照してください、
Documentation/power/energy-model.rstを参照）。

2. 背景と用語
-----------

最初から明確にしておく：
 - エネルギー = [ジュール] (動力機器のバッテリーのような資源)
 - 電力 = エネルギー/時間 = [ジュール/秒] = [ワット］

EASの目標は、仕事をこなしながらエネルギーを最小限に抑えることです。つまり
を最大化することである::


	パフォーマンス [インスタンス/秒］
	---------------------------
	    電力 [W］

を最小化することと等価である::

	エネルギー [J］
	---------------------------
	命令

を最小化することに相当する。これは本質的に代替最適化目標である。この代替目的は、エネルギー効率と性能という2つの目的を考慮する。

EMの導入の背景には、スケジューラがやみくもに省エネルギーを適用するのではなく、その決定の意味を評価できるようにするという考えがある。
一部のプラットフォームでのみプラスの効果をもたらす可能性のある省エネ技術をやみくもに適用するのではなく、スケジューラがその決定の意味を評価できるようにすることである。同時に、EMはスケジューラの待ち時間を最小にするために、できるだけ単純でなければならない。

つまり、EAS は CFS タスクの CPU への割り当て方法を変更する。スケジューラがタスクの実行場所を決定する時（ウェイクアップ時）、EM
を使用し、複数の CPU 候補の中から、最も効率が良いと予測される CPU を選びます。
システムのスループットを損なうことなく、最良のエネルギー消費をもたらすと予測されるものを選ぶ。EASが行う予測は、プラットフォームのトポロジーに関する特定の知識要素に依存しています。
EASによる予測は、プラットフォームのトポロジーに関する特定の要素に依存する、とそれぞれのエネルギーコストです。

3. トポロジー情報
---------------

EASは（スケジューラの他の部分と同様に）、「キャパシティ」という概念を使用して、計算スループットの異なるCPUを区別する。
を使用します。CPUの「キャパシティ」とは
の「容量」とは、そのCPUが最高周波数で動作しているときに吸収できる仕事量を表します。
CPUの「キャパシティ」は、そのCPUが最も高い周波数で動作しているときに吸収できる仕事量を表します。容量値は
1024の範囲で正規化され、タスクとCPUの使用率信号と比較可能です。
タスクとCPUの使用率信号と同等です。容量と利用値のおかげで
容量と利用率の値により、EAS はタスク/CPU がどの程度大きいか/忙しいかを推定することができます。
タスク/CPUがどの程度使用されているかを推定し、性能とエネルギーのトレードオフを評価する際にこれを考慮することができます。
エネルギーのトレードオフを評価する際に考慮することができます。CPUのキャパシティはアーカイブ固有のコードで提供される。
を通して提供される。

EASが使用する残りのプラットフォーム知識は、Energy Model (EM)フレームワークから直接読み込まれる。
モデル（EM）フレームワークから直接読み込まれる。プラットフォームの EM は、システム内の「性能ドメイン」ごとの電力コスト表
プラットフォームのEMは、システムの「パフォーマンス・ドメイン」ごとの電力コスト・テーブルで構成される（パフォーマンス・ドメインの詳細については、Documentation/power/energy-model.rstを参照）。
を参照）。

スケジューラは、スケジューリングドメインが構築されたとき、または再 構築されたときに、トポロジーコード内のEMオブジェクトへの参照を管理する。
スケジューリングドメインが構築されたとき、または再構築されたときに、トポロジーコード内のEMオブジェクトへの参照を管理する。各ルートドメイン(rd)に対して
各ルートドメイン(rd)に対して、スケジューラは現在のrd->spanに交差するすべてのパフォーマンスドメインの単一リンクリストを保持する。
を保持する。リスト内の各ノードには、em_perf_domain構造体へのポインタが含まれる。
へのポインタを含む。

リストは、排他的なcpuset構成に対応するために、ルート・ドメインに添付される。
cpusetコンフィギュレーションに対応するためです。排他的cpusetの境界は必ずしもパフォーマンス・ドメインの境界と一致しないので
の境界は必ずしもパフォーマンス・ドメインの境界と一致しないため、異なるルート・ドメイン
のリストには重複した要素が含まれる可能性があります。

例1.
    3つのパフォーマンス・ドメインに分割された12個のCPUを持つプラットフォームを考えてみましょう。
    (pd0、pd4、pd8)に分割され、以下のように構成されている::

	          CPU：   0 1 2 3 4 5 6 7 8 9 10 11
	          PD   |--pd0--|--pd4--|---pd8---|
	          RD   |----rd1----|-----rd2-----|

    ここで、ユーザー空間がシステムを2つの
    つの排他的なCPUセットでシステムを分割することにしたとする。
    それぞれ6個のCPUを含む。2つのルートドメインは上図ではrd1とrd2と示されている。
    とする。pd4はrd1とrd2の両方と交差しているため、リンクリスト'->pd1'と'->pd2'に存在することになる。
    に存在する::

       * rd1->pd: pd0 -> pd4
       * rd2->pd: pd4 -> pd8

    スケジューラはpd4に対して2つの重複したリスト・ノードを作成することに注意してください。
    pd4に対して、スケジューラは2つの重複したリスト・ノードを作成することに注意してほしい（各リストに1つずつ）。しかし、どちらもEMフレームワークの共有データ構造へのポインターを保持するだけです。
    EMフレームワークの共有データ構造へのポインタを保持するだけです。

これらのリストへのアクセスは、hotplugや他のものと同時に発生する可能性があるため、RCUによって保護されている。
これらのリストへのアクセスは、hotplugや他のものと同時に発生する可能性があるため、スケジューラが操作する他のトポロジー構造と同様に、RCUによって保護されている。
によって保護されている。

EASは静的キー(sched_energy_present)も保持している。これらの条件はセクション6にまとめられている。

4. エネルギーを考慮したタスク配置
------------------------------

EAS は CFS タスク・ウェイクアップ・バランシング・コードをオーバーライドする。EASはプラットフォームのEMと
プラットフォームと PELT 信号を使用し、ウェイクアップバランシング中にエネルギー効率の良いターゲット CPU を選択します。
を選択します。EAS が有効な場合、select_task_rq_fair() は以下を呼び出します。
find_energy_efficient_cpu() を呼び出して配置を決定します。この関数は
この関数は、各パフォーマンス・ドメインで最も高い予備容量（CPU 容量 - CPU 使用率）を持つ CPU を探します。
を探す。
周波数を最も低く保つことができるものだからです。次に、この関数は、その CPU にタスクを配置することで以下のことが可能かどうかをチェックします。
タスクをprev_cpu、つまりタスクが前回の起動時に実行されたCPU
すなわち、タスクが以前の起動時に実行されたCPUである。

find_energy_efficient_cpu()は、compute_energy()を使用して、タスクが前回起動したCPUで実行された場合にシステムで消費されるエネルギーを推定します。
compute_energy()は、起床タスクが移行された場合にシステムで消費されるエネル ギーを推定する。
は、CPUの現在の使用状況を調べ、タスクの移行を "シミュレート "するためにそれを調整します。
タスクの移行を「シミュレート」する。EMフレームワークは、em_pd_energy() APIを提供します。
を提供します。
を計算するAPIを提供します。

エネルギー最適化されたタスク配置決定の例を以下に詳述する。

例2.
    それぞれ2つのCPUで構成される2つの独立したパフォーマンス・ドメイン
    それぞれ2つのCPUで構成される。CPU0とCPU1は小さなCPUで、CPU2とCPU3は大きなCPUである。
    は大きい。

スケジューラは、util_avg = 200でprev_cpu = 0のタスクPをどこに置くかを決めなければならない。
    でprev_cpu = 0であるタスクPをどこに置くかを決めなければならない。

    CPUの現在の使用状況をグラフに示す。
    に描かれている。CPU 0～3はそれぞれutil_avgが400、100、600、500である。
    各パフォーマンス・ドメインには3つのオペレーティング・パフォーマンス・ポイント（OPP）があります。
    各OPPに関連するCPU容量と電力コストは、エネルギーモデルの表に記載されている。
    エネルギーモデルの表に記載されている。Pのutil_avgは、以下の図に示されている。
    Pのutil_avgは、以下の図に「PP」として示されている::


     CPU util.
      1024                 - - - - - - -              Energy Model
                                               +-----------+-------------+
                                               |  Little   |     Big     |
       768                 =============       +-----+-----+------+------+
                                               | Cap | Pwr | Cap  | Pwr  |
                                               +-----+-----+------+------+
       512  ===========    - ##- - - - -       | 170 | 50  | 512  | 400  |
                             ##     ##         | 341 | 150 | 768  | 800  |
       341  -PP - - - -      ##     ##         | 512 | 300 | 1024 | 1700 |
             PP              ##     ##         +-----+-----+------+------+
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3

      Current OPP: =====       Other OPP: - - -     util_avg (100 each): ##

find_energy_efficient_cpu()は、まず、2つの性能領域で最大の予備能力を持つCPUを探す。
    を探します。この例では
    CPU1とCPU3である。次に、PがCPU1とCPU3のどちらかに配置された場合のシステムのエネル ギーを推定します。
    をそれらのいずれかに配置した場合のシステムのエネル ギーを見積もり、PをCPU0に配置したままにしておくよりもエネルギーが節約できるかどうかを調べます。
    をチェックする。EASは、OPPが利用率に従うと仮定している。
    (に従うと仮定する（これはschedutil CPUFreq
    ガバナーの動作と首尾一貫している。）

    **ケース 1. PはCPU1に移行する**::


      1024                 - - - - - - -

                                            Energy calculation:
       768                 =============     * CPU0: 200 / 341 * 150 = 88
                                             * CPU1: 300 / 341 * 150 = 131
                                             * CPU2: 600 / 768 * 800 = 625
       512  - - - - - -    - ##- - - - -     * CPU3: 500 / 768 * 800 = 520
                             ##     ##          => total_energy = 1364
       341  ===========      ##     ##
                    PP       ##     ##
       170  -## - - PP-      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3

    **ケース 2. PはCPU3に移行する**::

      1024                 - - - - - - -

                                            Energy calculation:
       768                 =============     * CPU0: 200 / 341 * 150 = 88
                                             * CPU1: 100 / 341 * 150 = 43
                                    PP       * CPU2: 600 / 768 * 800 = 625
       512  - - - - - -    - ##- - -PP -     * CPU3: 700 / 768 * 800 = 729
                             ##     ##          => total_energy = 1485
       341  ===========      ##     ##
                             ##     ##
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3


    **Case 3. Pは以前のCPU / CPU 0にとどまる**::

      1024                 - - - - - - -

                                            Energy calculation:
       768                 =============     * CPU0: 400 / 512 * 300 = 234
                                             * CPU1: 100 / 512 * 300 = 58
                                             * CPU2: 600 / 768 * 800 = 625
       512  ===========    - ##- - - - -     * CPU3: 500 / 768 * 800 = 520
                             ##     ##          => total_energy = 1437
       341  -PP - - - -      ##     ##
             PP              ##     ##
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3

これらの計算から、ケース1が最も総エネルギーが低い。つまり、CPU 1
    がエネルギー効率の観点から最良の候補となる。

一般に、大きなCPUは小さなCPUよりも電力を消費するため、主にタスクが小さなCPUに合わない場合に使用される。
主にタスクがリトルCPUに合わない場合に使用されます。しかし、小さなCPUは必ずしも
必ずしも大きなCPUよりもエネルギー効率が高いとは限らない。システムによっては
システムによっては、リトルCPUの高いOPPはビッグCPUの低いOPPよりもエネルギー効率が低い場合があります。
システムによっては、小さなCPUの高いOPPが大きなCPUの低いOPPよりもエネルギー効率が悪くなることがある。そのため、特定の時点でたまたま小さなCPUの使用率が十分であった場合
つまり、ある特定の時点でたまたま小さなCPUに十分な使用率がある場合、その時点で起動した小さなタスクは、大きなCPU側で実行したほうがよい可能性がある。
その瞬間に目覚めた小さなタスクは、小さなCPU側で実行した方が、エネルギーを節約できる。
で実行したほうがよい。



上記の例は、一般的な方法で、そしてすべてのプラットフォームで正しく実行することはほぼ不可能である。
システムのすべてのCPUで異なるOPPで実行した場合のコストを知ることなく、汎用的な方法で、そしてすべてのプラットフォームで正しく実行することはほぼ不可能である。
システムのすべてのCPUで異なるOPPで実行する場合のコストを知らなければ。EMベースの設計のおかげで、EASはそれらに正しく対処できるはずです。
に正しく対処できるはずです。しかし
高稼働シナリオのスループットへの影響を最小限に抑えるため、EASは「オーバーユーティライゼーション」と呼ばれる別のメカニズムも実装しています。
オーバーユーティライゼーション」と呼ばれるメカニズムも実装している。

上記の例は、一般的な方法で、そしてすべてのプラットフォームで正しく実行することはほぼ不可能である。
システムのすべてのCPUで異なるOPPで動作させた場合のコストを知ることなく、すべてのプラットフォームについて、汎用的な方法で、そしてすべてのプラットフォームについて、正しくすることはほぼ不可能である。
システムのすべてのCPUで異なるOPPで実行する場合のコストを知らなければ。EMベースの設計のおかげで、EASはそれらに正しく対処できるはずです。
に正しく対処できるはずです。しかし
高稼働シナリオのスループットへの影響を最小限に抑えるため、EASは「オーバーユーティライゼーション」と呼ばれる別のメカニズムも実装しています。

5. オーバーユーティライゼーション
----------------------------

一般的な観点から、EASが最も役立つユースケースは、以下のようなものである。
軽い/中程度のCPU使用率を伴うものである。長時間のCPU負荷タスクが実行される場合は常に
長時間のCPU負荷タスクが実行される場合、利用可能なCPU容量のすべてを必要とします。
スループットを著しく損なうことなくエネルギーを節約するために、スケジューラができることはあまりない。
スループットを著しく損なうことなくエネルギーを節約するために、スケジューラができることはあまりない。EASによってパフォーマンスが損なわれるのを避けるため、CPUは次のようなフラグが立てられる。
EASで性能を損なわないようにするため、CPUはその計算能力の80%以上で使用されるとすぐに「使用過多」のフラグが立てられます。
としてフラグが立てられます。ルートドメインでCPUが使用されすぎていない限り、ロードバランシングは無効化され、EASがオーバーライドする。
が無効になり、EASがウェイクアップバランシングコードをオーバーライドする。EASはおそらく
EASは、スループットを損なうことなく実行できるのであれば、システムの中で最もエネルギー効率の高いCPUに他のCPUよりも負荷をかける可能性が高い。
スループットを損なうことなく行えるのであれば。そのため、ロードバランサーを無効にして、エネルギー効率のよい
ロードバランサーは、EASが見つけたエネルギー効率の良いタスク配置を壊さないように、無効化されている。これは
というのも、80%のティッピング・ポイントを下回っているからである。
であることを意味する::

  a. すべてのCPUにアイドル時間があるため、EASが使用する使用率信号は、さまざまなタスクの「サイズ」を正確に表している可能性が高い。
  b.すべてのタスクは、そのナイス値にかかわらず、十分なCPU能力をすでに提供されているはずである；
  c. 予備容量があるので、すべてのタスクは定期的にブロック／スリープしているはずであり、ウェイクアップ時のバランシングで十分である。

1つのCPUが80％のティッピングポイントを超えると、上記の3つのうち少なくとも1つが不正確になる。
のうち少なくとも1つが不正確になる。このシナリオでは、ルートドメイン全体に対して「overutilized」フラグが立つ。
フラグが立ち、EASが無効になり、ロードバランサーが再び有効になる。
を再度有効にする。このようにすることで、スケジューラは、CPU-buffer環境下でのウェイクアップとロードバラン スのために、ロードベースのアルゴリズムにフォールバックする。これにより提供する。

オーバーユーティライゼーションの概念は、システム内にアイドル時間があるかどうかの検出に大きく依存している。
過使用の概念は、システム内にアイドル時間があるかどうかの検出に大きく依存するため、（CFSより）高いスケジューリングクラスによって
(CFSよりも)高いスケジューリングクラス(IRQと同様)によって「奪われる」CPU容量を考慮しなければならない。そのため
このように、過剰使用の検出は、CFSタスクだけでなく、他のスケジューリングクラスやIRQによっても使用される容量を考慮する。


6. EAS の依存関係と要件
--------------------

エネルギー・アウェア・スケジューリングは、システムのCPUが特定のハードウェア特性を持ち、カーネルの他の機能が有効になっていることに依存する。このセクションでは、これらの依存関係を列挙し、それらを満たすためのヒントを提供します。

6.1 - 非対称CPUトポロジー
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


冒頭で述べたように、EAS は以下のプラットフォームでのみサポートされています。
でしかサポートされていない。この要件は、実行時に
この要件は、スケジューリングドメインが構築されるときに SD_ASYM_CPUCAPACITY_FULL フラグがあるかどうかを調べることによって実行時にチェックされます。
フラグがあるかどうかを調べることで実行時にチェックされます。

スケジューリングドメインを構築するときに SD_ASYM_CPUCAPACITY_FULL フラグがあるかどうかを調べることで、 実行時にこの要件がチェックされます。を参照してください。

EASはSMPと基本的に互換性がないわけではありませんが、SMPプラットフォームでの大きな節約はありません。
SMPプラットフォームでの大幅な節約はまだ観測されていない。この制限は、将来的に修正される可能性がある。

6.2 - エネルギーモデルの存在
^^^^^^^^^^^^^^^^^^^^^^^^^^^

EASは、プラットフォームのEMを使用して、スケジューリング決定がエネル ギーに与える影響を推定します。
エネルギーに与える影響を推定します。そのため、EASを起動させるためには、プラットフォームがEMフレームワークに電力コストテーブルを提供する必要があります。
を提供する必要があります。そのためには、Documentation/powerにある独立したEMフレームワークのドキュメントを参照してください。
を参照してください。

また、EASを起動させるためには、EMが登録された後に、スケジューリング・ドメインを再構築する必要があることに注意してください。
EASを起動するためには、EMが登録された後にスケジューリング・ドメインを再構築する必要があることにも注意してください。

EASは、エネルギー使用量の予測決定を行うためにEMを使用します。
そのため、タスク配置の可能な選択肢をチェックする際には、その違いに重点を置く。
配置する。EASにとって、EMの電力値がミリ・ワット単位で表されるか、ミリ・ワット単位で表されるかは重要ではありません。
ミリワットで表されるか、「抽象的な尺度」で表されるかは問題ではない。

6.3 - エネルギーモデルの複雑性
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EAS は、PD/OPP/CPU の数に複雑さの制限を課さないが、CPU の数を以下のように制限する。
CPU 数を EM_MAX_NUM_CPUS に制限し、エネルギー推定中のオーバーフローを防ぎます。
に制限します。

6.4 - Schedutilガバナー
^^^^^^^^^^^^^^^^^^^^^^^^

EASは、近い将来にCPUがどのOPPで動作するかを予測しようとします。
を予測する。そのためには、CPU の OPPは CPU の使用率に従うと仮定します。

実際には、この仮定の精度について厳密な保証を提供することは非常に困難であるが、
schedutilは、他のCPUFreqガバナーとは対照的に、少なくとも次のことを行います。
他のCPUFreqガバナーとは対照的に、schedutilは少なくとも利用率信号を用いて計算された周波数を要求します。
その結果、EASと一緒に使うべきまともなガバナーはschedutilしかない、
なぜなら、周波数要求とエネルギー予測の間にある程度の一貫性を提供する唯一のものだからです。

schedutil以外のガバナーでEASを使用することはサポートされていません。

6.5 スケール不変利用率シグナル
^^^^^^^^^^^^^^^^^^^^^^^^^^

CPU間およびすべての性能状態に対して正確な予測を行うために、EASは周波数非可 変な使用率信号を必要とします。
を正確に予測するために、EAS は周波数不変および CPU 不変の PELT 信号を必要とします。これらは
アーキテクチャで定義されている arch_scale{cpu,freq}_capacity()
コールバックを使って得ることができる。

これら2つのコールバックを実装していないプラットフォームでのEASの使用はサポートされていません。

6.6 マルチスレッド（SMT）
^^^^^^^^^^^^^^^^^^^^^

現在の EAS は SMT を意識していないため、マルチスレッド・ハードウェアを活用し てエネルギーを節約することができない。
マルチスレッド・ハードウェアを活用してエネルギーを節約することはできません。EAS はスレッドを独立した
を独立した CPU と見なしますが、これは性能とエネルギーの両方にとって逆効果になる可能性があります。

SMT上のEASはサポートされていません。
