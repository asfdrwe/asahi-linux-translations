`Energy Aware Scheduling <https://docs.kernel.org/scheduler/sched-energy.html>`_  の非公式日本語訳です。
ライセンスは原文のライセンス(カーネル付属文書だからGPL-2.0のはず)に従います。

訳注:

* Linuxの従来のスケジューラ CFS関連文書

	* `カーネル文書 CFS Scheduler <https://docs.kernel.org/scheduler/sched-design-CFS.html>`_
	* `上記文書の和訳 <https://hiraku-wfs.hatenablog.com/entry/20141214/1418572909>`_
	* `CFS Scheduler の解説 <https://atmarkit.itmedia.co.jp/flinux/rensai/watch2009/watch09c.html>`_

* LinuxでのIntelのハイブリッド・アーキテクチャーへの対応への解説

	* https://www.coelacanth-dream.com/posts/2022/01/02/intel-hfi/
	* https://www.coelacanth-dream.com/posts/2022/09/10/linux-kernel-intel-itd/


=====================================================================
Energy Aware Scheduling
=====================================================================

1. はじめに
----------

Energy Aware Scheduling(エネルギーを考慮したスケジューリング、EAS)は、スケジューラの決定がCPUの消費エネルギーに与える影響を予測する能力をスケジューラに与えます。
EASは、各タスクに対してエネルギー効率の良いCPUを選択するために、CPUのEnergy Model(エネルギーモデル、EM)に依存し、
スループットへの影響を最小限にします。この文書は、EASがどのように動作し、その背後にある主な設計上の決定が何であるか、
EASを実行するために必要な詳細について説明します。

先に進む前に執筆時点で以下のことに注意してください::

   /!\ EASは対称的なCPUトポロジーを持つプラットフォームに非対応 。 /!\/

EASは異種(heterogeneous)CPUトポロジー（Arm big.LITTLEなど）でのみ動作します。
スケジューリングによる省エネの可能性が最も高いのはここだからです。

EASが実際に使用するEMは、スケジューラではなく、専用のフレームワークによって管理されます。
このフレームワークの詳細と提供するものの詳細については対応する文書を参照してください
( https://docs.kernel.org/power/energy-model.html を参照）。

2. 背景と用語
-----------

はじめに明確化:
 - エネルギー = [ジュール(J)] (電力機器でのバッテリーのような資源)
 - 電力 = エネルギー/時間 = [ジュール(J)/秒] = [ワット(W)］

EASの目標は、仕事をこなしながらエネルギーを最小限に抑えることです。つまり次のものを最大化します::

	　　性能 [命令/秒］
	------------------
	    電力 [W］

これは次のものと等価です::

	　　エネルギー [J］
	--------------
	　　命令


『良好な』性能を維持しつつです。これは基本的に現在のスケジューラの性能のみを目的とする最適化目標に代わるものです。
代わりの目的はエネルギー効率と性能という2つの目的を考慮します。

EMの導入の背後にあるアイディアは、スケジューラが一部のプラットフォームでのみプラスの効果をもたらす可能性のある
省エネ技術をやみくみにを適用するのではなく、スケジューラがその決定の意味を評価できるようにすることです。
同時に、EMはスケジューラの待ち時間を最小にするために、できるだけ単純でなければなりません。

つまり、EAS は CFS タスクの CPU への割り当て方法を変更します。スケジューラがタスクの実行場所を決定する時（タスク起床時）、
EMを使って、複数の CPU 候補の中から、システムのスループットを損なうことなく、最もエネルギー効率が良いと予測される CPU を選びます。
EASが行う予測EASによる予測は、プラットフォームのトポロジーに関する特定の知識要素に依存し、CPUの『容量(capacity)』と
対応するエネルギーコストを含みます。

3. トポロジー情報
---------------

EASは（スケジューラの他の部分と同様に）、『容量』という概念を使用して、計算スループットの異なるCPUを区別します。
CPUの『容量』とは、そのCPUが最高周波数で動作しているときに吸収できる仕事量を表します。
容量は1024の範囲で正規化されており、PELT（Per-Entity Load Tracking、エンティティ単位での負荷追跡）機構によって計算された、
要求とCPU稼働量信号(utilization signal)に対して比較可能になっています。
容量と稼働量の値により、EAS はタスクがどのくらい大きいかやCPUがどれくらい忙しいかを推定でき、
性能とエネルギーのトレードオフを評価する際にこれを考慮することができます。
CPUの容量は　arch_scale_cpu_capacity() コールバック経由でアーキテクチャ固有のコードを通して提供されます。

EASが利用する残りのプラットフォーム知識は、Energy Model (EM)フレームワークから直接読み込まれます。
プラットフォームの EM は、システム内の『性能ドメイン(performance domain)』ごとの電力コスト表で構成されます
（性能ドメインの詳細については、https://docs.kernel.org/power/energy-model.html  を参照）。

スケジューラは、スケジューリングドメインが構築されるときや再構築されるときに、トポロジーコード内の
EMオブジェクトへの参照を管理します。各ルートドメイン(rd)に対して、スケジューラは現在のrd->spanに交差する
すべての性能ドメインの単一リンクリストを保持します。リスト内の各ノードには、em_perf_domain 構造体へのポインタを含みます。

リストは、排他的な cpuset 構成に対応するために、ルートドメインに添付されます。排他的 cpuset の境界は必ずしも
性能ドメインの境界と一致するとは限らないので、異なるルートドメインのリストには重複した要素が含まれる可能性があります。

例1.
    3つの性能ドメインに分割された12個のCPUを持つプラットフォームを考えてみましょう。
    (pd0、pd4、pd8)に分割され、以下のように構成されています(訳注:性能ドメイン→PD、ルートドメイン→RD)::

	          CPU：  0 1 2 3 4 5 6 7 8 9 10 11
	          PD:   |--pd0--|--pd4--|---pd8--|
	          RD:   |----rd1-----|----rd2----|

    ここで、ユーザー空間がシステムを2つの排他的なCPUセットでシステムを分割することにしたとしましょう。
    2つの独立したルートドメインを作成し、それぞれ6個のCPUを含みます。2つのルートドメインは上図では
    rd1とrd2と示されています。pd4はrd1とrd2の両方と交差しているため、それぞれリンクリスト'->'に対応づけされます::

       * rd1->pd: pd0 -> pd4
       * rd2->pd: pd4 -> pd8

    スケジューラはpd4に対して2つの重複したリスト・ノードを作成することに注意してください(各リストに1つずつ）。
    しかし、どちらもEMフレームワークの共有データ構造へのポインタを保持するだけです。
    
これらのリストへのアクセスはhotplugや他のものと同時に発生する可能性があるため、スケジューラが操作する他のトポロジー構造と
同様に、RCU(訳注: `Read-Copy-Update <https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%89%E3%83%BB%E3%82%B3%E3%83%94%E3%83%BC%E3%83%BB%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88>`_ )によって保護されています。

EASは静的キー(sched_energy_present)も保持しており、少なくとも1つのルートドメインEASが起動するための
すべての条件を満たしたときにこのキーが有効になります。これらの条件は6節にまとめられています。


4. エネルギーを考慮したタスク配置
------------------------------

EAS は CFSのタスク起床負荷分散コード(task wake-up balancing code)を上書きします。EASはプラットフォームのEMと
プラットフォームと PELT 信号を使用し、起床負荷分散中にエネルギー効率の良い対象 CPU を選択します。
EAS が有効な場合、select_task_rq_fair() はfind_energy_efficient_cpu() を呼び出して配置を決定します。
この関数は、各性能ドメインで最も高い予備容量（CPU 容量 - CPU 稼働量）を持つ CPU を探します。
周波数を最も低く保つことができるものだからです。次に、タスクをそこに配置することで、タスクをprev_cpu、つまり
前回の起動時にタスクを実行したCPUに残すことに比べてエネルギーを節約できるか、この関数が検証します。

find_energy_efficient_cpu()は、compute_energy()を使用して、起床タスクが移行された場合にシステムで
消費されるエネルギーを推定します。
compute_energy()は、CPUの現在の稼働状況を調べ、タスク移行を『シミュレート』するように調整します。
EMフレームワークは、em_pd_energy() APIを提供し、与えられた利用状況に対する各性能ドメインの
予想エネルギー消費量を計算します。

エネルギー最適化されたタスク配置決定の例を以下詳しく説明します。

例2.
    それぞれ2つのCPUで構成される2つの独立した性能ドメインを持つ(偽の)プラットフォームを考えてみましょう。
    CPU0とCPU1はlittle CPUで、CPU2とCPU3はBIG CPUです。

　　 スケジューラは、util_avg = 200でprev_cpu = 0のタスクPをどこに置くかを決めなければなりません。

    CPUの現在の稼働状況は以下のグラフで示されています。
    CPU 0～3はそれぞれutil_avg(訳注:稼働平均)が400、100、600、500です。
    各性能ドメインには3つのOperating Performance Points(制御性能基準、OPP）があります。
    各OPPに関連するCPU容量と電力コストは、エネルギーモデルの表に記載されています。
    Pのutil_avgは以下の図に『PP』として示されています::


     CPU 稼働
      1024                 - - - - - - -              エネルギーモデル
                                               +-----------+-------------+
                                               |  Little   |     Big     |
       768                 =============       +-----+-----+------+------+
                                               | 容量 | 電力 | 容量 | 電力 |
                                               +-----+-----+------+------+
       512  ===========    - ##- - - - -       | 170 | 50  | 512  | 400  |
                             ##     ##         | 341 | 150 | 768  | 800  |
       341  -PP - - - -      ##     ##         | 512 | 300 | 1024 | 1700 |
             PP              ##     ##         +-----+-----+------+------+
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3

      現在の OPP: =====       他のOPP: - - -     util_avg (100ごと): ##

find_energy_efficient_cpu()は、まず、2つの性能ドメインで最大の予備能力を持つCPUを探します。
この例ではCPU1とCPU3です。次に、PがCPU1とCPU3のどちらかに配置された場合のシステムのエネルギーを見積もり、
PをCPU0に残したままにしておくよりもエネルギーが節約できるかどうかを調べます。
EASはOPPが稼働率に従うと仮定します(これはschedutil CPUFreq governorの動作と整合します。これに関して詳細は6節を参照してください)。

    ** ケース 1. PがCPU1に移行**::


      1024                 - - - - - - -

                                            エネルギー計算:
       768                 =============     * CPU0: 200 / 341 * 150 = 88   
                                             * CPU1: 300 / 341 * 150 = 131
                                             * CPU2: 600 / 768 * 800 = 625
       512  - - - - - -    - ##- - - - -     * CPU3: 500 / 768 * 800 = 520
                             ##     ##          => 総消費電力 = 1364
       341  ===========      ##     ##
                    PP       ##     ##
       170  -## - - PP-      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3
       (訳注: CPU0はPとP以外の合計が400だったから、Pを他に移すと400-200=200になる。CPU1は元々100でPが移ってきたから100+200=300)  

    ** ケース 2. PがCPU3に移行**::

      1024                 - - - - - - -

                                            エネルギー計算:
       768                 =============     * CPU0: 200 / 341 * 150 = 88
                                             * CPU1: 100 / 341 * 150 = 43
                                    PP       * CPU2: 600 / 768 * 800 = 625
       512  - - - - - -    - ##- - -PP -     * CPU3: 700 / 768 * 800 = 729
                             ##     ##          => 総消費電力 = 1485
       341  ===========      ##     ##
                             ##     ##
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3
        (訳注: CPU0はPとP以外の合計が400だったから、Pを他に移すと400-200=200になる。CPU3は元々500でPが移ってきたから500+200=700) 

    ** ケース 3. Pは以前の CPU 0のまま**::

      1024                 - - - - - - -

                                            Energy calculation:
       768                 =============     * CPU0: 400 / 512 * 300 = 234
                                             * CPU1: 100 / 512 * 300 = 58
                                             * CPU2: 600 / 768 * 800 = 625
       512  ===========    - ##- - - - -     * CPU3: 500 / 768 * 800 = 520
                             ##     ##          => 総消費電力 = 1437
       341  -PP - - - -      ##     ##
             PP              ##     ##
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3

 
  これらの計算から、ケース1が最も総消費電力が低いです。つまり、CPU 1がエネルギー効率の観点から最良の候補となります。

一般に、big CPUはlittle CPUよりも電力を消費するため、主にタスクがlittle CPUに合わない場合に使用されます。しかし、
little CPUは必ずしもbig CPUよりもエネルギー効率が高いとは限りません。システムによっては、little CPUの高いOPPは
big CPUの低いOPPよりもエネルギー効率が低い場合があります。そのため、特定の時点でたまたまlittle CPUの稼働率が
十分高い場合、その時点で起動した小さなタスクは、エネルギーを節約するためにはlittle CPU側で実行できたとしても
big CPU側で実行したほうがよい可能性があります。

また、big CPUのすべてのOPPがlittle CPUのOPPよりもエネルギー効率が悪い場合でも、小さなタスクにbig CPUを使えば、
特定の条件下ではエネルギーを節約できる可能性があります。実際、小さなCPUにタスクを配置すると、性能ドメイン全体の
OPPが上昇し、そこですでに実行しているタスクのコストが増加してしまう場合があります。

起床タスクがbig CPUに配置された場合、そのタスク自身の実行コストはlittle CPUで実行された場合よりも高くなるかもしれませんが、
little CPUのより低いOPPのまま実行している他のタスクには影響しません。そのため、CPUが消費する総エネルギーを考えると、
その1つのタスクをbig コアで実行する余分なコストは、他のすべてのタスクのためにlittle CPUのOPPを上げるコストよりも
小さくなる可能性があります。

上記の例は、システムのすべてのCPUで異なるOPPで実行した場合のコストを知ることなく汎用的な方法ですべてのプラットフォームで
正しく実行することはほぼ不可能です。EMベースの設計のおかげで、EASはそれらに正しく対処できるはずです。
しかし高稼働シナリオでのスループットへの影響を最小限に抑えるため、EASは『過剰稼働(over-utilization)』と呼ばれる
別のメカニズムも実装しています。

5. 過剰稼働(over-utilization)
----------------------------

一般的な観点から、EASが最も役立つユースケースは軽い/中程度のCPU稼働率に関するものです。長時間のCPU負荷タスクが実行される
場合は常に利用可能なCPU容量のすべてを必要とします。スループットを著しく損なうことなくエネルギーを節約するために、
スケジューラができることはあまりありません。EASで性能を損なわないようにするため、CPUはその計算能力の80%以上で使用されると
すぐに『over-utilization』のフラグが立てられます。ルートドメインでCPUが過剰稼働されていない限り、負荷分散機能
(load balancing)は無効化され、EASが起床負荷分散コードを上書きします。EASは、スループットを損なうことなく実行できるのであれば、
システムの中で最もエネルギー効率の高いCPUに他のCPUよりも負荷をかける可能性が高いです。
そのため、EASが見つけたエネルギー効率の良いタスク配置を壊さないように、負荷分散機能は無効化されます。
システムが過剰稼働されていない場合はこのようにしても安全です。、80%の転換点(tipping point)を下回っていることは
次のことを意味するからです::

  a. すべてのCPUにアイドル時間があるため、EASが使用する稼働率信号は、さまざまなタスクの『大きさ』を正確に表している可能性が高い
  b. すべてのタスクは、そのnice値にかかわらず、すでに十分なCPU容量を提供されているはず
  c. 予備容量があるので、すべてのタスクは定期的にブロックまたはスリープしているはずであり、起床時の負荷分散で十分

1つのCPUが80％の転換点を超えると、上記の3つのうち少なくとも1つが不正確になります。
この状況のとき、ルートドメイン全体に対して『overutilized』フラグが立ち、EASが無効になり、負荷分散機能が再び有効になります。
このようにすることで、スケジューラは、CPU-buffer環境下でのタスク起床と負荷分散のために、負荷ベースのアルゴリズムに
後退します。これによりタスクのnice値をより尊重できます。

過剰稼働の概念は、システム内にアイドル時間があるかどうかの検出に大きく依存し、(IRQと同様に)（CFSより）高い
スケジューリングクラスによって『奪われる(stolen)』CPU容量を考慮しなければなりません。このように、過剰稼働の検出は、
CFSタスクだけでなく、他のスケジューリングクラスやIRQによっても使用される容量を考慮します。

6. EASの依存関係と要件
--------------------

エネルギーを考慮したスケジューリングは、システムのCPUが特定のハードウェア特性を持ち、カーネルの他の機能が有効になって
いることに依存します。この節では、これらの依存関係を列挙し、それらを満たすためのヒントを提供します。

6.1 - 非対称CPUトポロジー
^^^^^^^^^^^^^^^^^^^^^^^

冒頭で述べたように、EASは以下のプラットフォームのみ対応します。
この要件は、スケジューリングドメインが構築されるときに SD_ASYM_CPUCAPACITY_FULL フラグがあるかどうかを
調べることによって実行時にチェックされます。

sched_domainヒエラルキー内でこのフラグがセットされる要件については　https://docs.kernel.org/power/energy-model.html　
を参照してください。

EASはSMPと基本的に互換性がないわけではありませんが、SMP プラットフォームでの大幅な節約はまだ観測されていません。
この制限は将来修正される可能性があります。

6.2 - エネルギーモデルの存在
^^^^^^^^^^^^^^^^^^^^^^^^^

EASは、プラットフォームのEMを使用して、スケジューリング決定がエネルギーに与える影響を推定します。
そのため、EASを起動させるためには、プラットフォームがEMフレームワークに電力コストテーブルを提供する必要があります。
これを行うために、https://docs.kernel.org/power/energy-model.html にある独立したEMフレームワークの文書を参照してください。

また、EASを起動させるためには、EMが登録された後に、スケジューリングドメインを再構築する必要があることに注意してください。

EASは、エネルギー使用量の予測決定を行うためにEMを使用します。そのため、タスク配置の可能な選択肢をチェックする際には、
その違いに重点を置きます。EASにとって、EMの電力値がミリ・ワット単位で表されるか『抽象的な尺度』で表されるかは問題ではありません。

6.3 - エネルギーモデルの複雑性
^^^^^^^^^^^^^^^^^^^^^^^^^^^

EASは、PD/OPP/CPUの数に複雑さの制限を課しませんが、CPUの数を EM_MAX_NUM_CPUS に制限し、エネルギー推定中の
オーバーフローを防ぎます。

6.4 - schedutil governor
^^^^^^^^^^^^^^^^^^^^^^^^

EASは、エネルギー消費を推定するために近い将来にCPUがどのOPPで動作するかを予測しようとします。
そのためには、CPUのOPPはCPUの稼働率に従うと仮定します。

実際には、この仮定の精度について厳密な保証を提供することは非常に困難ですが、
他のCPUFreq governorとは対照的に、schedutil は少なくとも稼働量信号を用いて計算された周波数を要求します。
したがって、EASと一緒に使うべきまともなガバナーは schedutil しかありません。
周波数要求とエネルギー予測の間にある程度の一貫性を提供する唯一のものだからです。

schedutil 以外のgovernorでEASを使用することには対応していません。

6.5 スケール不変稼働率シグナル
^^^^^^^^^^^^^^^^^^^^^^^^^^

CPU間およびすべての性能状態に対して正確な予測を行うために、EASは周波数不変でCPU不変のPELT 信号を必要とします。
これらはアーキテクチャで定義されている arch_scale{cpu,freq}_capacity() コールバックを使用して入手できます。

これら2つのコールバックを実装していないプラットフォームでのEASの使用には対応していません。

6.6 マルチスレッド（SMT）
^^^^^^^^^^^^^^^^^^^^^

現在のEASはSMTを意識していないため、マルチスレッド・ハードウェアを活用してエネルギーを節約することはできません。
EASはスレッドを独立したCPUと見なしますが、これは性能とエネルギーの両方にとって逆効果になる可能性があります。

SMT上のEASには対応していません。
