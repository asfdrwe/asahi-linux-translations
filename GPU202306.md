[OpenGL 3.1 on Asahi Linux](https://asahilinux.org/2023/06/opengl-3-1-on-asahi-linux/)の非公式日本語訳です。

訳注: 本家ブログと本家wikiへのリンクは対応する日本語訳へのリンクに変更、まだ作業中(2023/06/10)

---
# Asahi LinuxでのOpenGL 3.1

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202303.md)

朝日リナックスのグラフィックドライバは、OpenGL 2.1からOpenGL 3.1へ、さらにOpenGL 3.1へ、大きく進化しています！同様に、OpenGL ES 2.0のサポートもOpenGL ES 3.0にアップグレードされています。つまり、よりプレイしやすいゲームや、より機能的なアプリケーションを提供することができるのです。

12月に、複数のレンダーターゲットやインスタンス化といったOpenGL ES 3.0の機能を使ったSuperTuxKartの遅延レンダラーがAsahiで動作する初期のスクリーンショットを公開しました。これで、あなたもSuperTuxKartの高度なライティングを、思い通りに楽しむことができます：
SuperTuxKartの高度なライティングによるレンダリング

SuperTuxKartレンダリング（アドバンスドライト付き

これらのドライバは実験的なもので、OpenGLやOpenGL ESの仕様にはまだ準拠していません。今のところ、バグがあるかもしれないことを理解した上で、進行中のドライバにオプトインするために、私たちの -edge パッケージを実行する必要があります。ドライバのインストール方法とバグを報告する方法については、以前の記事を参照してください。

このリリースには、OpenGL 3.0、3.1、およびOpenGL ES 3.0に多くの新機能が搭載されています。ハイライトは以下の通りです：

    複数のレンダーターゲット
    マルチサンプリング
    トランスフォームフィードバック
    テクスチャバッファオブジェクト
    などなど。

では、次に...

## マルチサンプリング
VulkanとOpenGLは、マルチサンプリング（Multisampled Anti-Aliasingの略）をサポートしています。グラフィックスにおいて、エイリアシングは、不十分な解像度でレンダリングすることにより、斜めのエッジがギザギザになることを意味します。エイリアシングの解決策として、より高い解像度でレンダリングし、スケーリングダウンする方法があります。エッジはギザギザではなく、ぼやけた感じになり、見栄えが良くなります。マルチサンプリングは、このアイデアを効率的に実現したものです。

マルチサンプリング画像は、各ピクセルに対して複数のサンプルを含んでいます。レンダリング後、マルチサンプリング画像は、通常、ピクセル内のサンプルを平均化することによって、ピクセルごとに1つのサンプルを持つ通常の画像に分解されます。

Apple GPUは、マルチサンプル画像とフレームバッファをサポートしています。プログラマが考えるマルチサンプリングを、ハードウェアが理解できる形に落とし込むには、かなりのタイピングが必要ですが、根本的な非互換性はないでしょう。

問題は、サンプルシェーディングの場合です。最近のグラフィックスでは、プログラマが指定したフラグメントシェーダを実行することで、各フラグメントの色が決定されることを思い出してください。フラグメントがピクセルであれば、そのピクセル内の各サンプルは同じ色になる。ピクセルごとに1回フラグメントシェーダを実行しても、より高品質なラスタライズによってマルチサンプリングの恩恵は受けられますが、実際に高い解像度でレンダリングするのと同じようにはいきません。代わりにフラグメントがサンプルである場合、各サンプルはユニークな色を取得し、より高い解像度でレンダリングするのと同じです（スーパーサンプリング）。VulkanとOpenGLでは、フラグメントシェーダは通常ピクセル単位で実行されますが、「サンプルシェーディング」を使用すると、アプリケーションはフラグメントシェーダをサンプル単位で実行するように強制できます。

ドライバから見たサンプルシェーディングはどのように機能するのでしょうか？典型的なGPUでは、ドライバが1つのサンプルの色を計算するフラグメントシェーダをコンパイルし、ピクセル単位ではなくサンプル単位で実行するようにハードウェアビットを設定する、というシンプルな仕組みになっています。サンプルシェーディングに関連する状態は、1ビットだけです。ハードウェアはフラグメントシェーダーをピクセルごとに複数回実行し、ピクセルの色を独立して書き出します。

簡単でしょう？

残念ながら、Appleの「AGX」GPUは典型的なものではありません。

AGXは、サンプルシェーディングをサポートしていない古いGPUのように、サンプルごとに1回ではなく、常にピクセルごとに1回シェーダーを実行する。しかし、AGXはそれをサポートしています。

どのように？AGXの命令セットでは、ピクセルシェーダーが各サンプルに異なる色を出力することができます。color1を出力するために使用される命令は、ビットマスクとしてエンコードされた、修正するサンプルのセットを取ります。デフォルトのall-1のマスクは、ピクセル内のすべてのサンプルに同じ値を書き込みますが、1ビットを設定するマスクは、対応する1つのサンプルのみを書き込みます。

このデザインは珍しく、「フラグメントシェーダー」をハードウェアピクセルシェーダーに変換するために、ドライバーのバックフリップが必要です。どうすればいいのでしょうか？

物理的には、ハードウェアは1ピクセルにつき1回シェーダを実行します。論理的には、アプリケーションのフラグメントシェーダは1サンプルに1回実行されることになっています。ピクセルあたりのサンプル数がわかっていれば、アプリケーションのシェーダを各サンプルに対するループで包むことができます。つまり、元のフラグメントシェーダーが

```
interpolated colour = interpolate at current sample(input colour);
output current sample(interpolated colour);
```

といった具合に、プログラムをピクセルシェーダに変換していきます：

```
for (sample = 0; sample < number of samples; ++sample) {
    sample mask = (1 << sample);
    interpolated colour = interpolate at sample(input colour, sample);
    output samples(sample mask, interpolated colour);
}
```

オリジナルのフラグメントシェーダは、1サンプルにつき1回、ループ内で実行されます。現在のサンプル位置で入力を補間するときは、代わりにループカウンターのサンプルで与えられた特定のサンプルで補間するように変更します。同様に、あるサンプルに対して色を出力するときは、ループカウンタで与えられた1つのサンプルに対して色を出力するように変更する。

ここで話が終わってしまうと、この仕組みはバカバカしくなってしまいます。命令セットにサンプルマスクを追加することは、他のGPUがそうであるように、シェーダーを複数回呼び出すための1ビットよりも複雑です。Apple独自のMetalドライバでさえ、このダンスを実装しなければならない。MetalはOpenGLやVulkanと同様にサンプルシェーディングにアプローチしているからだ。このような余分な複雑さがある中で、メリットはあるのでしょうか？

もし、最後にループを生成したのであれば、そうではないかもしれません。しかし、コンパイル時にサンプルシェーディングが使用されていることがわかれば、このサンプルループに対してフルオプティマイザを実行することができます。他の GPU がそうであるように、同じ値を何度も計算するのではなく、値を 1 回だけ計算し、各サンプルで再利用することができるのです2。ドライバは複雑になりますが、このサンプルシェーディングのアプローチは、Appleが手を抜いたわけではありません。もし、最後にループを追加し、何の最適化も行わなければ、出来上がったコードは、他のGPUがハードウェアで実行するものと同等になるでしょう。スレッドの数は少なくても、より多くの制御フロー命令3が実行されるため、わずかな違いはあるかもしれませんが、それは小さなことです。ループを早期に生成し、オプティマイザを実行することで、他のGPUで可能な以上の性能を実現することができます。

では、この仕組みは最適化に過ぎないのでしょうか？Appleは、他のGPUが採用すべきサンプルシェーディングの優れたアプローチに出くわしたのでしょうか？私はそうとは思いません。

幕を引いてみましょう。AGXのルーツは、iPhone向けのモバイルGPUであり、PowerVRの伝統を受け継いでいる。今日、Mac Proを動かしているとしても、モバイルの遺産を持つAGXは、デスクトップGPUが専用ハードウェアで実装する多くの機能をソフトウェアで実装することを好みます。

そう、ブレンディングの話です。

ブレンディングとは、グラフィックスAPIにおいて、フラグメントシェーダの出力色をフレームバッファの既存の色と組み合わせる操作です。通常、アルファブレンディングを実装して、半透明のオブジェクトに背景を透過させるために使用されます。

サンプルシェーディングなしでマルチサンプリングを使用する場合、フラグメントシェーダはピクセルごとに1回しか実行されませんが、ブレンドはサンプルごとに行われます。フラグメントシェーダが各サンプルに同じ色を出力しても、フレームバッファが異なるサンプルですでに異なる色を持っていた場合、フレームバッファにすでにある情報を失わないように、ブレンドはサンプルごとに行われる必要があります。

従来のデスクトップ用GPUは、専用のハードウェアと融合している。モバイル空間では、専用のハードウェアとソフトウェアが混在しています。AGXでは、ブレンドは純粋にソフトウェアで行われます。ブレンド用ハードウェアを構成するのではなく、ドライバは、希望するブレンドモードを実装する命令を含むフラグメントシェーダのバリエーションを生成する必要があります。アルファブレンディングでは、次のようなフラグメントシェーダを使用します：

```
colour = calculate lighting();
output(colour);
```
が
```
colour = calculate lighting();
dest = load destination colour;
alpha = colour.alpha;
blended = (alpha * colour) + ((1 - alpha) * dest));
output(blended);
```
になります。

どこに問題があるのか？

ブレンディングはサンプル単位で行われます。アプリケーションがピクセルごとにフラグメントシェーダを実行するつもりでも、正しいブレンディングのためには、シェーダはサンプルごとに実行されなければなりません。他のGPUと比較すると、ブレンドとマルチサンプリングが有効で、サンプルシェーディングが有効でない場合、ブレンドに対するこのアプローチはパフォーマンスを低下させるでしょう。

一方、マルチサンプルピクセルシェーダーをドライバに公開することで、この問題はすっきりと解決されます。ブレンディングとマルチサンプルの両方の状態がわかっていれば、まずブレンディングの命令を挿入し、次にサンプルループでラップすることができる。そうすると、上記のプログラムは次のようになります：

```
colour = calculate lighting();
alpha = colour.alpha;
inv_alpha = 1 - alpha;
colour_alpha = alpha * colour;

for (sample = 0; sample < number of samples; ++sample_id) {
    dest = load destination colour at sample (sample);
    blended = colour_alpha + (inv_alpha * dest);

    sample mask = (1 << sample);
    output samples(sample_mask, blended);
}
```

## 次は何でしょうか?
OpenGL ES 3.0はES 2.0より改善されていますが、まだ終わってはいません。私の仕掛かりブランチでは、OpenGL ES 3.1のサポートがほぼ終了し、コンピュートシェーダのロックが解除される予定です。

最終的なゴールは、最新のゲームを実行するVulkanドライバです。まだ先の話ですが、ベースラインのVulkan 1.0要件はOpenGL ES 3.1と並行しているので、私たちの仕事はVulkanに翻訳されます。例えば、上述のマルチサンプリングコンパイラのパスは、ドライバ間で共通のコードです。私たちはOpenGLに対してそれらをテストし、そして今、Vulkanのために準備ができているのです。

そして、そう、チームはすでにVulkanに取り組んでいるのです。

それまでは、pacman -Syu 1つでOpenGL 3.1を楽しむことができます！

1. タイルバッファとして動作するローカルメモリにフォーマットされた値を格納します。︎
2. ループがアンロールされている場合は共通部分式消去で、そうでない場合はコードモーションで行います。︎
3. サンプル数が一定なので、すべてのスレッドが同じ方向に分岐するため、通常の「GPUは分岐が苦手」というアドバイスは当てはまらない。︎

#### Alyssa Rosenzweig · 2023-06-06
