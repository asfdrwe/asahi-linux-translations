[OpenGL 3.1 on Asahi Linux](https://asahilinux.org/2023/06/opengl-3-1-on-asahi-linux/)の非公式日本語訳です。

訳注: 本家ブログと本家wikiと英語Wikipediaへのリンクは対応する日本語訳、日本語Wikipediaへのリンクに変更、まだ作業中(2023/06/10)

---
# Asahi LinuxでのOpenGL 3.1

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202303.md)

[Asahi Linux](https://asahilinux.org/)のグラフィックドライバは、OpenGL 2.1からOpenGL 3.1へ、さらにOpenGL 3.1へ、大きく進化しています！
同様に、OpenGL ES 2.0対応もOpenGL ES 3.0にアップグレードされています。つまり、よりプレイしやすいゲームや、より機能的なアプリケーションを提供することができるのです。

12月に、複数のレンダーターゲットやインスタンス化といったOpenGL ES 3.0の機能を使ったSuperTuxKartの遅延レンダラーがAsahiで動作する初期の
スクリーンショットを公開しました。これで、あなたもSuperTuxKartの高度なライティングを、思い通りに楽しむことができます：

![SuperTuxKartの高度なライティングによるレンダリング](https://asahilinux.org/img/blog/2023/06/STK-1080p.webp)
SuperTuxKartレンダリング（アドバンスドライト付き)

これらのドライバは実験的なもので、OpenGLやOpenGL ESの仕様にはまだ準拠していません。今のところ、バグがあるかもしれないことを理解した上で、
進行中のドライバにオプトインするために、私たちの -edge パッケージを実行する必要があります。ドライバのインストール方法とバグを報告する方法については、
[以前の記事](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202212.md)を参照してください。

このリリースには、OpenGL 3.0、3.1、およびOpenGL ES 3.0に多くの新機能が搭載されています。ハイライトは以下の通りです：

- 複数のレンダーターゲット
- マルチサンプリング
- [トランスフォームフィードバック](https://cgit.freedesktop.org/mesa/mesa/commit/?id=d72e1418ce4f66c42f20779f50f40091d3d310b0)
- [テクスチャバッファオブジェクト](https://social.treehouse.systems/@alyssa/109542058314148170)
- などなど

では、次に...

## マルチサンプリング(Multisampling)
VulkanとOpenGLは、`マルチサンプリング(Multisampling)`（`Multisampled Anti-Aliasing`の略）をサポートしています。グラフィックスにおいて、エイリアシングは、
不十分な解像度でレンダリングすることにより、斜めのエッジがギザギザになることを意味します。エイリアシングの解決策として、より高い解像度でレンダリングし、
スケーリングダウンする方法があります。エッジはギザギザではなく、ぼやけた感じになり、見栄えが良くなります。マルチサンプリングは、このアイデアを効率的に実現したものです。

`マルチサンプリング`画像は、各ピクセルに対して複数の`サンプル`を含んでいます。レンダリング後、マルチサンプリング画像は、通常、ピクセル内のサンプルを平均化することによって、
ピクセルごとに1つのサンプルを持つ通常の画像に`分解`されます。

Apple GPUは、マルチサンプル画像とフレームバッファをサポートしています。プログラマが考えるマルチサンプリングを、ハードウェアが理解できる形に落とし込むには、
かなりのタイピングが必要ですが、根本的な非互換性はないでしょう。

問題は、`サンプルシェーディング`の場合です。最近のグラフィックスでは、プログラマが指定した`フラグメントシェーダ(fragment shader)`を実行することで、
各`フラグメント(fragment)`の色が決定されることを思い出してください。フラグメントがピクセルであれば、そのピクセル内の各サンプルは同じ色になる。ピクセルごとに
1回フラグメントシェーダを実行しても、より高品質なラスタライズによってマルチサンプリングの恩恵は受けられますが、`実際に`高い解像度でレンダリングするのと
同じようにはいきません。代わりにフラグメントがサンプルである場合、各サンプルはユニークな色を取得し、より高い解像度でレンダリングするのと同じです（スーパーサンプリング）。
VulkanとOpenGLでは、フラグメントシェーダは通常ピクセル単位で実行されますが、『サンプルシェーディング』を使用すると、アプリケーションはフラグメントシェーダを
サンプル単位で実行するように強制できます。

ドライバから見たサンプルシェーディングはどのように機能するのでしょうか？典型的なGPUでは、ドライバが1つのサンプルの色を計算するフラグメントシェーダをコンパイルし、ピクセル単位ではなくサンプル単位で実行するようにハードウェアビットを設定する、というシンプルな仕組みになっています。サンプルシェーディングに関連する状態は、1ビットだけです。ハードウェアはフラグメントシェーダーをピクセルごとに複数回実行し、ピクセルの色を独立して書き出します。

簡単でしょうか？

残念ながら、Appleの『AGX』GPUは典型的なものではありません。

AGXは、サンプルシェーディングをサポートしていない古いGPUのように、サンプルごとに1回ではなく、常にピクセルごとに1回シェーダーを実行します。しかし、AGXはそれをサポートしています。

どのように？AGXの命令セットでは、ピクセルシェーダーが各サンプルに異なる色を出力することができます。color[^1]を出力するために使用される命令は、ビットマスクとしてエンコードされた、修正するサンプルのセットを取ります。デフォルトのall-1のマスクは、ピクセル内のすべてのサンプルに同じ値を書き込みますが、1ビットを設定するマスクは、対応する1つのサンプルのみを書き込みます。

このデザインは珍しく、「フラグメントシェーダー」をハードウェアピクセルシェーダーに変換するために、ドライバーのバックフリップが必要です。どうすればいいのでしょうか？

物理的には、ハードウェアは1ピクセルにつき1回シェーダを実行します。論理的には、アプリケーションのフラグメントシェーダは1サンプルに1回実行されることになっています。ピクセルあたりのサンプル数がわかっていれば、アプリケーションのシェーダを各サンプルに対するループで包むことができます。つまり、元のフラグメントシェーダーが

```
interpolated colour = interpolate at current sample(input colour);
output current sample(interpolated colour);
```

で、このプログラムを次のピクセルシェーダに変換します：

```
for (sample = 0; sample < number of samples; ++sample) {
    sample mask = (1 << sample);
    interpolated colour = interpolate at sample(input colour, sample);
    output samples(sample mask, interpolated colour);
}
```

オリジナルのフラグメントシェーダは、1サンプルにつき1回、ループ内で実行されます。現在のサンプル位置で入力を補間するときは、代わりにループカウンターの
``サンプル``で与えられた特定のサンプルで補間するように変更します。同様に、あるサンプルに対して色を出力するときは、ループカウンタで与えられた1つのサンプルに
対して色を出力するように変更します。

ここで話が終わってしまうと、この仕組みはバカバカしくなってしまいます。命令セットにサンプルマスクを追加することは、他のGPUがそうであるように、シェーダーを
複数回呼び出すための1ビットよりも複雑です。Apple独自のMetalドライバでさえ、このダンスを実装しなければならない。MetalはOpenGLやVulkanと同様に
サンプルシェーディングにアプローチしているからだ。このような余分な複雑さがある中で、メリットはあるのでしょうか？

もし、最後にループを生成したのであれば、そうではないかもしれません。しかし、コンパイル時にサンプルシェーディングが使用されていることがわかれば、
このサンプルループに対してフルオプティマイザを実行することができます。他の GPU がそうであるように、同じ値を何度も計算するのではなく、
値を 1 回だけ計算し、各サンプルで再利用することができるのです[^2]。ドライバは複雑になりますが、このサンプルシェーディングのアプローチは、Appleが手を
抜いたわけではありません。もし、最後にループを追加し、何の最適化も行わなければ、出来上がったコードは、他のGPUがハードウェアで実行するものと同等になるでしょう。
スレッドの数は少なくても、より多くの制御フロー命令3が実行されるため、わずかな違いはあるかもしれませんが、それは小さなことです。ループを早期に生成し、
オプティマイザを実行することで、他のGPUで可能な以上の性能を実現することができます。

では、この仕組みは最適化に過ぎないのでしょうか？Appleは、他のGPUが採用すべきサンプルシェーディングの優れたアプローチに出くわしたのでしょうか？私はそうとは思いません。

幕を引いてみましょう。AGXのルーツは、iPhone向けのモバイルGPUであり、PowerVRの伝統を受け継いでいる。今日、Mac Proを動かしているとしても、モバイルの遺産を持つAGXは、デスクトップGPUが専用ハードウェアで実装する多くの機能をソフトウェアで実装することを好みます。

そう、ブレンディングの話です。

ブレンディングとは、グラフィックスAPIにおいて、フラグメントシェーダの出力色をフレームバッファの既存の色と組み合わせる操作です。通常、
[アルファブレンディング](https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%AB%E3%83%95%E3%82%A1%E3%83%96%E3%83%AC%E3%83%B3%E3%83%89)を実装して、半透明のオブジェクトに背景を透過させるために使用されます。

サンプルシェーディングなしでマルチサンプリングを使用する場合、フラグメントシェーダはピクセルごとに1回しか実行されませんが、ブレンドはサンプルごとに行われます。フラグメントシェーダが各サンプルに同じ色を出力しても、フレームバッファが異なるサンプルですでに異なる色を持っていた場合、フレームバッファにすでにある情報を失わないように、ブレンドはサンプルごとに行われる必要があります。

従来のデスクトップ用GPUは、専用のハードウェアと融合している。モバイル空間では、専用のハードウェアとソフトウェアが混在しています。AGXでは、ブレンドは純粋にソフトウェアで行われます。ブレンド用ハードウェアを構成するのではなく、ドライバは、希望するブレンドモードを実装する命令を含むフラグメントシェーダのバリエーションを生成する必要があります。アルファブレンディングでは、次のようなフラグメントシェーダを使用します：

```
colour = calculate lighting();
output(colour);
```
が
```
colour = calculate lighting();
dest = load destination colour;
alpha = colour.alpha;
blended = (alpha * colour) + ((1 - alpha) * dest));
output(blended);
```
になります。

どこに問題があるのでしょうか？

ブレンディングはサンプル単位で行われます。アプリケーションがピクセルごとにフラグメントシェーダを実行するつもりでも、正しいブレンディングのためには、シェーダはサンプルごとに実行されなければなりません。他のGPUと比較すると、ブレンドとマルチサンプリングが有効で、サンプルシェーディングが有効でない場合、ブレンドに対するこのアプローチはパフォーマンスを低下させるでしょう。

一方、マルチサンプルピクセルシェーダーをドライバに公開することで、この問題はすっきりと解決されます。ブレンディングとマルチサンプルの両方の状態がわかっていれば、まずブレンディングの命令を挿入し、次にサンプルループでラップすることができる。そうすると、上記のプログラムは次のようになります：

```
for (sample = 0; sample < number of samples; ++sample_id) {
    colour = calculate lighting();

    dest = load destination colour at sample (sample);
    alpha = colour.alpha;
    blended = (alpha * colour) + ((1 - alpha) * dest);

    sample mask = (1 << sample);
    output samples(sample_mask, blended);
}
```

この形態では、フラグメントシェーダはループ内で実行され、不必要にサンプルごとに実行されるため、アプリケーションが望むよりも漸近的に悪化しています。

しかし、オプティマイザはここにあります。``colour``はピクセル内の各サンプルで同じであるため、サンプルIDに依存しません。コンパイラは、
元のフラグメントシェーダ全体（および関連する式）をサンプル単位のループの外に移動させることができます：

```
colour = calculate lighting();
alpha = colour.alpha;
inv_alpha = 1 - alpha;
colour_alpha = alpha * colour;

for (sample = 0; sample < number of samples; ++sample_id) {
    dest = load destination colour at sample (sample);
    blended = colour_alpha + (inv_alpha * dest);

    sample mask = (1 << sample);
    output samples(sample_mask, blended);
}
```

ブレンディングはサンプルごとに行われますが、アプリケーションのフラグメントシェーダーは1回だけ実行されるため、従来のGPUのパフォーマンス特性にマッチしています。さらに素晴らしいことに、これらすべてはコンパイラが特別な作業をすることなく実現されています。魔法のようなマルチサンプリング最適化は行われておらず、ただのループなのです。

ところで、コンパイル時にブレンドとマルチサンプルの状態がわからない場合はどうすればいいのでしょうか？希望は失われないが...。

...が、それはまた別の日の話になります。

## 次は何でしょうか?
OpenGL ES 3.0はES 2.0より改善されていますが、まだ終わってはいません。私の仕掛かりブランチでは、OpenGL ES 3.1のサポートがほぼ終了し、コンピュートシェーダのロックが解除される予定です。

最終的なゴールは、最新のゲームを実行するVulkanドライバです。まだ先の話ですが、ベースラインのVulkan 1.0要件はOpenGL ES 3.1と並行しているので、私たちの仕事はVulkanに翻訳されます。例えば、上述のマルチサンプリングコンパイラのパスは、ドライバ間で共通のコードです。私たちはOpenGLに対してそれらをテストし、そして今、Vulkanのために準備ができているのです。

そして、そう、[チーム](https://github.com/ella-0)はすでにVulkanに取り組んでいるのです。

それまでは、pacman -Syu 1つでOpenGL 3.1を楽しむことができます！

[^1]: タイルバッファとして動作するローカルメモリにフォーマットされた値を格納します。
[^2]: ループがアンロールされている場合は共通部分式消去で、そうでない場合はコードモーションで行います。
[^3]: サンプル数が一定なので、すべてのスレッドが同じ方向に分岐するため、通常の「GPUは分岐が苦手」というアドバイスは当てはまりません。

#### Alyssa Rosenzweig · 2023-06-06
