[OpenGL 3.1 on Asahi Linux](https://asahilinux.org/2023/06/opengl-3-1-on-asahi-linux/)の非公式日本語訳です。

訳注1: 本家ブログと本家wikiと英語Wikipediaへのリンクは対応する日本語訳、日本語Wikipediaへのリンクに変更

訳注2: [シェーダー](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC)、[アンチエイリアシング](https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%B3%E3%83%81%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9)、[コンパイラ最適化](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E6%9C%80%E9%81%A9%E5%8C%96)などが今回の記事の理解の参考になります(2023/6/10修正追加)。

---
# Asahi LinuxでのOpenGL 3.1

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202303.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202308.md)

[Asahi Linux](https://asahilinux.org/)をアップグレードしてください！グラフィックドライバは大きく進化しています。OpenGL 2.1からOpenGL 3.0へ、
さらにOpenGL 3.1へ！同様に、OpenGL ES 2.0対応もOpenGL ES 3.0対応にアップグレードされています。つまり、よりプレイしやすいゲームや
より機能的なアプリケーションをもたらします。

12月に複数のレンダーターゲットやインスタンス化といったOpenGL ES 3.0の機能を使ったSuperTuxKartの遅延レンダラー(deferred renderer)が
Asahiで動作する初期スクリーンショットを公開しました。今はSuperTuxKartの高度なライティングを、思い通りに楽しむことができます：

![SuperTuxKartの高度なライティングによるレンダリング](https://asahilinux.org/img/blog/2023/06/STK-1080p.webp)
SuperTuxKartレンダリング（アドバンスドライト付き)

これまで通りこれらのドライバは実験的なもので、OpenGLやOpenGL ESの仕様にはまだ準拠していません。今のところは、バグがあるかもしれないことを理解した上で、
開発中のドライバをオプトインするために、``-edge`` パッケージを実行する必要があります。ドライバのインストール方法とバグを報告する方法については、
[以前の記事](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202212.md)を参照してください。

このリリースには、OpenGL 3.0、3.1、およびOpenGL ES 3.0に多くの新機能が搭載されています。ハイライトは以下の通りです：

- 複数のレンダーターゲット
- マルチサンプリング
- [トランスフォームフィードバック](https://cgit.freedesktop.org/mesa/mesa/commit/?id=d72e1418ce4f66c42f20779f50f40091d3d310b0)
- [テクスチャバッファオブジェクト](https://social.treehouse.systems/@alyssa/109542058314148170)
- などなど

では、次に...

## マルチサンプリング(Multisampling)
VulkanとOpenGLは、`マルチサンプリング(Multisampling)`（`Multisampled Anti-Aliasing`の略）に対応しています。グラフィックスにおいて、
`エイリアシング(aliasing)`とは、不十分な解像度でレンダリングすることにより、斜めのエッジがギザギザになることを意味します。エイリアシングの
解決策として、より高い解像度でレンダリングし、スケーリングダウンする方法があります。エッジはギザギザではなく、ぼやけた感じになり、見栄えが
良くなります。マルチサンプリングは、このアイデアを効率的に実現したものです。

`マルチサンプリング`画像は、各ピクセルに対して複数の`サンプル`を含んでいます。レンダリング後、マルチサンプリング画像は、通常、ピクセル内の
サンプルを平均化することによって、ピクセルごとに1つのサンプルを持つ通常の画像に`還元`されます。

Apple GPUは、マルチサンプル画像とフレームバッファに対応しています。プログラマが考えるマルチサンプリングを、ハードウェアが理解できる形に落とし込むには、
かなりのタイピングが必要ですが、根本的な非互換性はないでしょう。

問題は、`サンプルシェーディング(sample shading)`の場合です。最近のグラフィックスでは、プログラマが指定した`フラグメントシェーダ(fragment shader)`を
実行することで各`フラグメント(fragment)`の色が決定されることを想起してください。フラグメントがピクセルであれば、そのピクセル内の各サンプルは同じ色になります。
ピクセルごとに1回フラグメントシェーダを実行しても、より高品質なラスタライズによってマルチサンプリングの恩恵は受けられますが、`実際に`高い解像度でレンダリングするのと
同じようにはいきません。代わりにフラグメントがサンプルである場合、各サンプルは単一の色を取得し、より高い解像度でレンダリングするのと同じになります
（スーパーサンプリング）。VulkanとOpenGLでは、フラグメントシェーダは通常ピクセル単位で実行されますが、『サンプルシェーディング』を使用すると、
アプリケーションはフラグメントシェーダをサンプル単位で実行するように強制できます。

ドライバからの観点ではサンプルシェーディングはどのように機能するのでしょうか？典型的なGPUでは単純な仕組みです:ドライバが1つのサンプルの色を計算する
フラグメントシェーダをコンパイルし、ピクセル単位ではなくサンプル単位で実行するようにハードウェアビットを設定しています。サンプルシェーディングに
関連する状態は、1ビットだけです。ハードウェアはフラグメントシェーダーをピクセルごとに複数回実行し、ピクセルの色を独立して書き出します。

簡単?本当?

残念ながら、Appleの『AGX』GPUは典型的なものではありません。

AGXは、サンプルシェーディングに対応していない古いGPUのように、サンプルごとに1回ではなく、常にピクセルごとに1回シェーダーを実行します。
ですが、AGXはサンプルシェーディングに対応しています。

どうやって?AGXの命令セットでは、ピクセルシェーダーが各サンプルに異なる色を出力することができます。color[^1]を出力するために使用される命令は、
ビットマスクとしてエンコードされた、修正するサンプルの`セット`を取ります。デフォルトのall-1のマスクは、ピクセル内のすべてのサンプルに同じ値を
書き込みますが、1ビット設定するマスクは、対応する1つのサンプルのみを書き込みます。

このデザインは珍しく、『フラグメントシェーダー』をハードウェアピクセルシェーダーに変換するために、ドライバーの後方宙返りが必要です。
どうすればいいのでしょうか？

物理的には、ハードウェアは1ピクセルにつき1回シェーダを実行します。論理的には、アプリケーションのフラグメントシェーダは1サンプルに1回実行されることになっています。
ピクセルあたりのサンプル数がわかっていれば、アプリケーションのシェーダを各サンプルに対するループで包むことができます。つまり、元のフラグメントシェーダーが

```
interpolated colour = interpolate at current sample(input colour);
output current sample(interpolated colour);
```

ならば、プログラムを次のピクセルシェーダに変換します：

```
for (sample = 0; sample < number of samples; ++sample) {
    sample mask = (1 << sample);
    interpolated colour = interpolate at sample(input colour, sample);
    output samples(sample mask, interpolated colour);
}
```

オリジナルのフラグメントシェーダは、1サンプルにつき1回、ループ内で実行されます。現在のサンプル位置で入力を補間するときは、代わりにループカウンターの
``sample``で与えられた特定のサンプルで補間するように変更します。同様に、あるサンプルに対して色を出力するときは、ループカウンタで与えられた1つのサンプルに
対して色を出力するように変更します。

ここで話が終わってしまうと、この仕組みはバカバカしくなってしまいます。命令セットにサンプルマスクを追加することは、他のGPUがそうであるように、シェーダーを
複数回呼び出すための1ビットよりも複雑です。Apple独自のMetalドライバでさえ、このダンスを実装しなければなりません。MetalはOpenGLやVulkanと同様に
サンプルシェーディングにアプローチしているからです。このような余分な複雑さがあるのにメリットはあるのでしょうか？

もし、最後にループを生成したのであれば、そうではないかもしれません。しかし、コンパイル時にサンプルシェーディングが使用されていることがわかれば、
このサンプルループに対して全面的な最適化を実行することができます。他の GPU がそうであるように、同じ値を何度も計算するのではなく、
値を 1 回だけ計算し、各サンプルで再利用することができるのです[^2]。ドライバは複雑になりますが、このサンプルシェーディングのアプローチは、Appleが手を
抜いたわけではありません。もし、最後にループを追加し、何の最適化も行わなければ、出来上がったコードは、他のGPUがハードウェアで実行するものと同等になるでしょう。
スレッドの数は少なくても、より多くの制御フロー命令[^3]が実行されるため、わずかな違いはあるかもしれませんが、それは小さなことです。ループを早期に生成し、
オプティマイザを実行することで、他のGPUで可能な性能以上の性能を実現すできます。

では、この仕組みは最適化に過ぎないのでしょうか？Appleは他のGPUが採用すべきサンプルシェーディングの優れたアプローチに出くわしたのでしょうか？私はそうとは思いません。

幕を引いてみましょう。AGXのルーツは、iPhone向けの`モバイル`GPUであり、PowerVRの伝統を受け継いでいます。今日、Mac Proを動かしているとしても、
モバイルの遺産を持つAGXは、デスクトップGPUが専用ハードウェアで実装する多くの機能をソフトウェアで実装することを好みます。

そう、ブレンディング(blending)の話です。

ブレンディングとは、グラフィックスAPIにおいて、フラグメントシェーダの出力色をフレームバッファの既存の色と組み合わせる操作です。通常、
[アルファブレンディング](https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%AB%E3%83%95%E3%82%A1%E3%83%96%E3%83%AC%E3%83%B3%E3%83%89)を実装して、
半透明のオブジェクトに背景を透過させるために使用されます。

サンプルシェーディング`なし`でマルチサンプリングを使用する場合、フラグメントシェーダはピクセルごとに1回しか実行されませんが、ブレンドはサンプルごとに行われます。
フラグメントシェーダが各サンプルに同じ色を出力しても、フレームバッファが異なるサンプルですでに異なる色を持っていた場合、フレームバッファにすでにある情報を
失わないように、ブレンドはサンプルごとに行われる必要があります。

従来のデスクトップ用GPUは、専用のハードウェアと融合しています。モバイル空間では、専用のハードウェアとソフトウェアが混在しています。AGXでは、
ブレンドは純粋にソフトウェアで行われます。ブレンド用ハードウェアを構成するのではなく、ドライバは、希望するブレンドモードを実装する命令を含む
フラグメントシェーダの`バリアント`を生成する必要があります。アルファブレンディングでは、次のようなフラグメントシェーダ:

```
colour = calculate lighting();
output(colour);
```
が
```
colour = calculate lighting();
dest = load destination colour;
alpha = colour.alpha;
blended = (alpha * colour) + ((1 - alpha) * dest));
output(blended);
```
になります。

どこに問題があるのでしょうか？

ブレンディングはサンプル単位で行われます。アプリケーションがピクセルごとにフラグメントシェーダを実行しようとしても、正しいブレンディングのためには、
シェーダはサンプルごとに実行されなければなりません。他のGPUと比較すると、ブレンドとマルチサンプリングが有効で、サンプルシェーディングが有効でない場合、
ブレンドに対するこのアプローチはパフォーマンスを低下させるでしょう。

一方、マルチサンプルピクセルシェーダーをドライバに公開することで、この問題はすっきりと解決されます。ブレンディングとマルチサンプルの両方の状態が
わかっていれば、まずブレンディングの命令を挿入し、次にサンプルループでラップすることができる。そうすると、上記のプログラムは次のようになります：

```
for (sample = 0; sample < number of samples; ++sample_id) {
    colour = calculate lighting();

    dest = load destination colour at sample (sample);
    alpha = colour.alpha;
    blended = (alpha * colour) + ((1 - alpha) * dest);

    sample mask = (1 << sample);
    output samples(sample_mask, blended);
}
```

この形態では、フラグメントシェーダはループ内で実行され、不必要にサンプルごとに実行されるため、アプリケーションが望むよりも漸近的に悪化します。

しかし、最適化がここに存在します。``colour``はピクセル内の各サンプルで同じであるため、サンプルIDに依存しません。コンパイラは、
元のフラグメントシェーダ全体（および関連する式）をサンプル単位のループの外に移動させることができます：

```
colour = calculate lighting();
alpha = colour.alpha;
inv_alpha = 1 - alpha;
colour_alpha = alpha * colour;

for (sample = 0; sample < number of samples; ++sample_id) {
    dest = load destination colour at sample (sample);
    blended = colour_alpha + (inv_alpha * dest);

    sample mask = (1 << sample);
    output samples(sample_mask, blended);
}
```

ブレンディングはサンプルごとに行われますが、アプリケーションのフラグメントシェーダーは1回だけ実行されるため、従来のGPUのパフォーマンス特性に適合します。
さらに素晴らしいことに、これらすべてはコンパイラが特別な作業をすることなく実現されています。魔法のようなマルチサンプリング最適化は存在していません。
ただのループなのです。

ところで、コンパイル時にブレンドとマルチサンプルの状態が`わからない`場合はどうすればいいのでしょうか？希望は失われていませんが...

...が、それはまた別の日の話になります。

## 次は何でしょうか?
OpenGL ES 3.0はES 2.0より改善されていますが、まだ作業は終わってはいません。作業用ブランチでは、OpenGL ES 3.1対応作業がほぼ終了し、
コンピュートシェーダのロックが解除される予定です。

最終的なゴールは、最新のゲームを実行するVulkanドライバです。まだ先の話ですが、ベースラインのVulkan 1.0要件はOpenGL ES 3.1と並行しているので、
成果はVulkanに翻訳されます。例えば、上述のマルチサンプリングコンパイラのパスは、ドライバ間で共通のコードです。私たちはOpenGLに対してそれらをテスト
しました。そして今、Vulkanのために準備ができています。

そう、[チーム](https://github.com/ella-0)はすでにVulkanに取り組んでいるのです。

それまでは、`pacman -Syu` 1つでOpenGL 3.1を楽しんでください!

[^1]: タイルバッファとして動作するローカルメモリにフォーマットされた値を格納します。
[^2]: [ループがアンロール](https://ja.wikipedia.org/wiki/%E3%83%AB%E3%83%BC%E3%83%97%E5%B1%95%E9%96%8B)されている場合は[共通部分式消去](https://ja.wikipedia.org/wiki/%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86%E5%BC%8F%E9%99%A4%E5%8E%BB)で、そうでない場合は[コード移動](https://en.wikipedia.org/wiki/Code_motion)(訳注:一対一対応する日本語Wikipediaのページがないので日本語資料としては[ループ不変量コード移動](https://ja.wikipedia.org/wiki/%E3%83%AB%E3%83%BC%E3%83%97%E4%B8%8D%E5%A4%89%E9%87%8F%E3%82%B3%E3%83%BC%E3%83%89%E7%A7%BB%E5%8B%95)を参照)行います。
[^3]: サンプル数が一定なので、すべてのスレッドが同じ方向に分岐するため、通常の『GPUは分岐が苦手』というアドバイスは当てはまりません。

#### Alyssa Rosenzweig · 2023-06-06
