.. SPDX-License-Identifier: GPL-2.0

`Utilization Clamping <https://docs.kernel.org/scheduler/sched-util-clamp.html>`_  の非公式日本語訳です。
ライセンスは原文のGPL-2.0に従います。

訳注: 

* まだDeepLの結果を貼っただけ(2024/3/7)
  

==============================
Utilization Clamping(稼働率固定)
==============================

1.はじめに
=========

Utilization Clamping (util clampまたはuclampとも呼ばれる）はスケジューラ機能の１つで、タスクの
性能要件を管理するのに役立ちます。v5.3 リリースで導入されました。CGroupでの対応は v5.4 で統合されました。

uclampは、スケジューラがタスクの性能要件と制約を理解できるようにするヒンティング機構で、スケジューラがより良い判断を
下すのに役立ちます。また、schedutil cpufreqガバナーが使用されていると、util clampはCPUの周波数選択にも影響を与えます。

スケジューラとschedutilはともにPELT
(訳注: `Per Entity Load Tracking <https://docs.kernel.org/scheduler/schedutil.html#pelt-per-entity-load-tracking>`_)（util_avg）信号によって駆動されるので、util clamp は、その信号をあるポイントにclamp(固定)することで
目的を達成します。これが名前の由来です。つまり、utilization(稼働率)をclamp(固定)することでシステムをある性能ポイントで
動作させるということになります。

util clampの正しい見方は、性能制約の要求やヒントを出すための機構であるということです。
2つの調整変数で構成されています::

        * UCLAMP_MIN、下限を設定
        * UCLAMP_MAX、上限を設定

この2つの境界がタスクがこの性能範囲内で動作することを保証します。UCLAMP_MINはタスクを加速することを意味し、
UCLAMP_MAXはタスクに上限を設定することを意味します。

システム（スケジューラ）に対して、望ましいユーザー体験を提供するためにあるタスクが最小限の
性能ポイントを必要としていることを示すことができます。あるいは、システム（スケジューラ）に対して、あるタスクは
リソースを消費し過ぎないように制限されるべきで、ある性能ポイント以上になるべきではないと示すこともできます。
uclampの値を、稼働率ではなく性能ポイントとして見ることは、ユーザー空間の観点からはより良い抽象化になります。

例として、ゲームは uclamp を利用して、認識可能なFPS（Frames Per Second）とフィードバックループを形成することができます。
フレームがドロップしないように、ディスプレイパイプラインが必要とする最小性能ポイントを動的に上げることができます。
また、数百ミリ秒後に計算負荷の高いシーンが発生することがわかっている場合、これらのタスクを動的に『盛る(prime up)』ことも
できます。

機器の能力が多様なモバイルハードウェアでは、この動的なフィードバックループが大きな柔軟性を提供し、
あらゆるシステムの能力を考慮した上で、最高のユーザー体験を保証します。

もちろん静的コンフィギュレーションも可能です。システムやアプリケーションそして望む結果によって正しい使い方が決まります。

別の例として、Androidでは、タスクはバックグラウンド、フォアグラウンド、トップアプリなどに分類されます。
util clampを使用すると、バックグラウンドタスクが実行できる性能ポイントに上限を設定することで、バックグラウンドタスクが
消費するリソースの量を制限できます。この制約は、現在アクティブなアプリ（トップアプリグループ）に属するような重要なタスクの
リソースを確保するのに役立ちます。また、消費電力の制限にも役立ちます。これは、ヘテロジニアスシステム（Arm big.LITTLEなど）
ではより顕著になります。この制約によってバックグラウンドタスクが little コアにとどまるように方向づけできます::

  1. bigコアはトップアプリタスクを即座に実行可能。トップアプリタスクは、ユーザーが現在操作しているタスクであり、システムで最も重要なタスク
  2. たとえCPU負荷の高いタスクであっても、電力消費の激しいコアで実行されてバッテリーを消耗することはない

.. note::
  **little コア**:
    CPUs with capacity < 1024

  **big コア**:
    CPUs with capacity = 1024

(2024/4/6 一旦保存)

このようなuclampのパフォーマンス要求というかヒントを出すことで、ユーザースペースは以下のことができる。
システムリソースが最適に使用され、可能な限り最高のユーザーエクスペリエンスが提供されるようにする。
体験を提供できる。

もう1つの使用例は、**スケジューラ利用シグナルの計算方法に継承されるランプアップレイテンシの克服**を支援することです。
スケジューラ利用シグナルの計算方法**に継承される立ち上がり待ち時間の克服を支援することです。

一方、例えば、最大のパフォーマンスポイントで実行する必要があるビジーなタスクは、以下のような遅延に悩まされます。
を必要とするビジーなタスクは、スケジューラがそれを認識するのに200ms(PELT HALFIFE = 32ms)の遅延を被ることになります。
の遅延が発生する。これは、以下のようなモバイル機器でのゲームのようなワークロードに影響することが知られている。
のような作業負荷に影響を与えることが知られている。
タスクが時間内に作業を終えるために必要な高い周波数を選択するための応答時間が遅いため、フレームが低下する。設定
UCLAMP_MIN=1024 を設定すると、そのようなタスクが実行を開始したときに、常に最高のパフォーマン
レベルが表示されます。

目に見える全体的な効果は、知覚されるユーザーエクスペリエンスやパフォーマンスが向上するだけではありません。
目に見える全体的な効果は、知覚されるユーザーエクスペリエンス/パフォーマンスを向上させるだけでなく、効果的に使用された場合、より良い全体的なパフォーマンス/ワット
を達成するのに役立ちます。

ユーザー・スペースは、サーマル・サブシステムともフィードバック・ループを形成し、以下のことを保証します。
デバイスがスロットルするほど熱くならないようにするためです。

SCHED_NORMAL/OTHERもSCHED_FIFO/RRも、uclampのリクエスト/ヒントを尊重します。

SCHED_FIFO/RRの場合、uclampはRTタスクを任意のパフォーマンスポイントで実行するオプションを与える。
常にMAX周波数に縛られるのではなく、どのパフォーマンスポイントでもRTタスクを実行できる。これは
は、バッテリー駆動のデバイスで動作する汎用システムで有用です。

設計上、RTタスクはタスクごとのPELT信号を持たず、常に一定の周波数で実行しなければならないことに注意してください。
を常に一定の周波数で実行しなければならないことに注意してください。

schedutilを使用すると、RTタスクがウェイクアップするときに、周波数を変更するために常に1回の遅延が発生することに注意してください。
RTタスクがウェイクアップするときに このコストはuclampを使っても変わりません。uclampは
は、schedutilが常に全てのRTタスクに対して
MAXを要求する。

デフォルト値については 
:ref:`3.4節 <uclamp-default-values>` を参照してください。
RTタスクのデフォルト値を変更する方法については 
:ref:`3.4.1 <sched-util-clamp-min-rt-default>` を参照してください。

2. 設計
=======

ユーティリティ・クランプは、システム内のすべてのタスクのプロパティである。その利用信号の境界を設定する。
スケジューラ内の特定の決定に影響を与えるバイアスメカニズムとして機能する。
スケジューラ内の決定に影響を与えるバイアスメカニズムとして働く。

タスクの実際の利用率信号がクランプされることは現実にはありません。もし
PELT シグナルを検査すれば、そのままのシグナルが表示されるはずである。
そのままである。クランピングは必要な時にだけ行われる。
例えば、タスクが起動し、スケジューラがそのタスクに適したCPUを選択する必要があるときなどです。

utilクランプの目的は、タスクが実行するための最小性能点と最大性能点を要求できるようにすることです。
utilクランプの目的は、タスクが実行するための最小性能点と最大性能点を要求できるようにすることなので、周波数選択とタスク配置に影響を与えることができなければなりません。
周波数選択だけでなく、タスクの配置にも影響を与えることができなければなりません。どちらも
どちらもCPUランキュー（略してrq）レベルの利用率に影響を与える。
レベルの利用率に影響する。

タスクがrq上でウェイクアップするとき、rqの使用率信号はuclamp設定の影響を受けます。
そのrqの利用率信号は、そのrqにキューイングされているすべてのタスクのuclamp設定に影響されます。例えば
あるタスクがUTIL_MIN = 512での実行を要求した場合、rqのutilシグナルは、この要求と同様に
のutilシグナルは、この要求だけでなく、すべてのキューイングされたタスクからの他の要求も尊重する必要がある。
を尊重する必要がある。

にアタッチされた全てのタスクのutil clamp値を集約することができる。
uclampはenqueue/dequeueごとにハウスキーピングを行う必要があります。
スケジューラのホットパスである。したがって、速度低下は多くのユースケースに大きな影響を与えるので、注意が必要である。
uclampは、enqueue/dequeueごとにハウスキーピングを行わなければならない。
したがって、注意が必要である。

これを処理する方法は、利用範囲をバケットに分割することである。
(構造体uclamp_bucket）に分割することである。
rq上のすべてのタスクから、一番上のバケット上のタスクのサブセットだけに探索空間を縮小することができます。

タスクがエンキューされると、マッチするバケットのカウンタがインクリメントされる、
デキュー時にはデクリメントされる。これにより、rqでの実効
uclamp値の追跡が非常に簡単になる。

タスクがエンキューされたりデキューされたりする際に、rqレベルの実効uclamp値を追跡する。
uclamp値を追跡する。この仕組みの詳細については :ref:`section 2.1 <uclamp-buckets>` を参照してください。
を参照のこと。

後でrqの有効なuclamp値を特定したいパスは、この有効なuclamp値を読み取るだけでよい、
rqの有効なuclamp値を特定したいパスでは、単にそのrqの有効なuclamp値を読み取る必要がある。
を読み取る必要がある。

タスク配置の場合、今のところ、エネルギー・アウェアとキャパシティ・アウェア・スケジューリング(EAS/CAS)のみがuclampを利用している。
(EAS/CAS）のみがuclampを使用する。
ヘテロジニアスシステムにのみ適用される。
タスクがウェイクアップすると、スケジューラは各rqの現在の有効なuclamp
値を見て、そのタスクがそこでエンキューされた場合の新しい値と比較する。
と比較する。最もエネルギー効率の良い組み合わせになるrqを優先する。

同様にschedutilでは、頻度の更新が必要な場合、rqの現在の有効なuclamp値を調べ、
その値は現在そこにキューイングされているタスクセットの影響を受け、リクエストからの制約を満たす適切な頻度を選択します。

過使用状態の設定（これは事実上EASを無効にする）のようなのような他のパスも同様にuclampを使用する。
このようなケースは、上記の2つの主なユースケースを可能にするために必要なハウスキーピングと考えられ、
実装の詳細によって変わる可能性があるため、ここでは詳しく説明しない。実装の詳細によって変更される
可能性があるからである。

.. _uclamp-buckets:

2.1. Buckets
-------------

::

                           [struct rq]

  (bottom)                                                    (top)

    0                                                          1024
    |                                                           |
    +-----------+-----------+-----------+----   ----+-----------+
    |  Bucket 0 |  Bucket 1 |  Bucket 2 |    ...    |  Bucket N |
    +-----------+-----------+-----------+----   ----+-----------+
       :           :                                   :
       +- p0       +- p3                               +- p4
       :                                               :
       +- p1                                           +- p5
       :
       +- p2


.. note::
  上の図は、内部データ構造を忠実に描写したものではなく説明図である。

タスクがエンキュー/ディキューされるときにrqの有効なuclamp値を決定しようとするときの探索空間を縮小するため
の有効なuclamp値を決定しようとするときの探索空間を小さくするために、タスクがエンキュー／ディキューされるときの全利用範囲を
Nはコンパイル時に
config_uclamp_buckets_count によってコンパイル時に設定される。デフォルトでは5に設定されている。

rqはuclamp_idごとにバケットを持ちます： [uclamp_min, uclamp_max]。

各バケットの範囲は1024/Nである。例えば、デフォルト値の
5の場合、5つのバケツがあり、それぞれのバケツは以下の範囲をカバーする：

::

        DELTA = round_closest(1024/5) = 204.8 = 205

        Bucket 0: [0:204]
        Bucket 1: [205:409]
        Bucket 2: [410:614]
        Bucket 3: [615:819]
        Bucket 4: [820:1024]


以下の調整可能なパラメータを持つタスクpの場合

::

        p->uclamp[UCLAMP_MIN] = 300
        p->uclamp[UCLAMP_MAX] = 1024

がrqにエンキューされると、バケット1がUCLAMP_MINでインクリメントされ、バケット4がUCLAMP_MAXでインクリメントされる。
4がインクリメントされる。
をインクリメントする。

その後、rqはuclamp_idごとに現在の有効なuclamp値を記録する。
uclamp_idの現在の有効uclamp値を追跡する。

タスクpがエンキューされると、rqの値は次のように変化する：

::

        // update bucket logic goes here
        rq->uclamp[UCLAMP_MIN] = max(rq->uclamp[UCLAMP_MIN], p->uclamp[UCLAMP_MIN])
        // repeat for UCLAMP_MAX

同様に、pがデキューされると、rqの値は次のように変化する：

::

        // update bucket logic goes here
        rq->uclamp[UCLAMP_MIN] = search_top_bucket_for_highest_value()
        // repeat for UCLAMP_MAX

すべてのバケットが空になると、rq uclamp 値はシステムのデフォルト値にリセットされる。
デフォルト値の詳細については :ref:`section 3.4 <uclamp-default-values>` を参照してください。

2.2. 最大集約
------------
  
Util clamp は、最も高い性能点を必要とするタスクのリクエストを尊重するように調整される。
を必要とするタスクのリクエストを尊重するように調整される。
を必要とするタスクのリクエストを尊重するように調整される。

複数のタスクが同じrqにアタッチされている場合、util clampは
複数のタスクが同じrqにアタッチされている場合、util clampは、最も高いパフォーマンスポイントを必要とするタスクが
他のタスクがそれを必要としなかったり、そのポイントへの到達が禁止されていてもです。

例えば、次のようなrqに複数のタスクがアタッチされている場合
値を持つ：

::

        p0->uclamp[UCLAMP_MIN] = 300
        p0->uclamp[UCLAMP_MAX] = 900

        p1->uclamp[UCLAMP_MIN] = 500
        p1->uclamp[UCLAMP_MAX] = 500


p0とp1の両方が同じrqにキューイングされていると仮定すると、UCLAMP_MINとUCLAMP_MAXの両方が次のようになります。
とUCLAMP_MAXの両方になります：

::

        rq->uclamp[UCLAMP_MIN] = max(300, 500) = 500
        rq->uclamp[UCLAMP_MAX] = max(900, 500) = 900
:ref:`section 5.1 <uclamp-capping-fail>` で説明するように、このmax集約はutil clampを使用する際の制限の一つです。
特に、ユーザースペースが電力を節約したいときに、UCLAMP_MAXヒントを使用するときの制限の1つです。

2.3. 階層的集約
-------------

先に述べたように、利用クランプはシステム内のすべてのタスクの特性である。しかし
しかし、実際に適用される(有効な)値は、タスクまたはタスクの代理の別のアクター(ミドルウェアライブラリ)が行ったリクエストだけではありません。
しかし、実際に適用される(有効な)値は、タスクまたはタスクに代わって別のアクター(ミドルウェアライブラリ)が行うリクエストだけではありません。

どのタスクのutil clampの実効値も次のように制限される：

  1. タスクがアタッチされている cgroup CPU コントローラで定義されている uclamp 設定。
     によって定義される。
  2. (1)で制限された値は、システム全体のuclamp設定によってさらに制限される。
     uclamp設定によってさらに制限される。

:ref:`3章 <uclamp-interfaces>` ではインターフェースについてさらに詳しく説明します。

今のところ、タスクがリクエストをした場合、その実際の実効値
タスクがリクエストをした場合、その実際の実効値は cgroup とシステム全体の設定による
設定による制限に従わなければならない。

システムはたとえ実効値が制約を越えてもリクエストを受け入れる。
しかし、タスクが別の cgroup に移動したり、システム管理者が
がシステム設定を変更すると、リクエストは
新しい制約の範囲内である場合にのみ、リクエストは満たされます。

言い換えると、この集約は、タスクがuclamp値を変更したときにエラーを発生させません。
タスクがuclampの値を変更してもエラーにはなりません。
を満たすことができないかもしれない。

2.4. 範囲
--------

Uclampパフォーマンス要求は、0から1024の範囲を持っています。

cgroup インタフェースではパーセンテージが使用されます (0 から 100 を含む)。
他のcgroupインターフェイスと同様に、100の代わりに「max」を使用できます。

.. _uclamp-interfaces:

3. インターフェイス
================

3.1. タスクごとのインターフェース
----------------------------
  
sched_setattr() syscall が拡張され、2つの新しいフィールドを受け付けるようになった：

* sched_util_min: このタスクが実行されているとき、システムが実行すべき最小パフォーマンス・ポイントを要求する。
  sched_util_min: このタスクが実行されているときにシステムが実行すべき最小性能点を要求する。または、性能の下限。
* sched_util_min: このタスク実行時にシステムが実行すべき最小性能点を要求する。
  sched_util_max: このタスク実行時にシステムが実行すべき最大のパフォーマンスポイントを要求する。または上限。

例えば、以下のシナリオには40%から80%の利用制約がある：

::

        attr->sched_util_min = 40% * 1024;
        attr->sched_util_max = 80% * 1024;

タスク@pが実行されているとき、**スケジューラは、タスク@pが40%の性能レベルで開始されるように最善を尽くす**べきである。
が40%のパフォーマンスで開始するように最善を尽くすべきである。タスクが十分長い時間実行され、実際の使用率が
タスクが長時間実行され、実際の利用率が80%以上になると、利用率、つまり性能レベルには上限が設けられる。
レベルに上限が設定される。

特別な値-1は、uclamp設定をシステムのデフォルトにリセットするために使われる。
デフォルトにリセットする。

1を使用してuclamp値をシステムデフォルトにリセットすることは、uclamp値を手動で
uclamp値を手動でシステムデフォルトに設定することとは異なる。この違いは
システム・インターフェースで見るように、RTのデフォルト値は変更可能である。
のデフォルト値を変更することができるからである。SCHED_NORMAL/OTHERも、将来同様のノブを持つようになるかもしれない。
将来、同様のノブが追加されるかもしれない。

3.2. cgroupインターフェース
-------------------------

CPU cgroupコントローラには、uclamp関連の値が2つある：

* cpu.uclamp.min
* cpu.uclamp.max

タスクがCPUコントローラにアタッチされると、そのuclamp値は次のように影響を与えます：

* cpu.uclamp.min は cgroup の :ref:`section 3-3 of cgroup v2 documentation <cgroupv2-protections-distributor>` で説明されている保護です。

  タスクの uclamp_min 値が cpu.uclamp.min より小さい場合、タスクは cgroup cpu_min を継承します。
  タスクは cgroup cpu.uclamp.min 値を継承します。

  cgroup 階層では、実効 cpu.uclamp.min は (child、
  親）の最大値です。

* cpu.uclamp.max は cgroup v2 の :ref:`section 3-2 of cgroup v2 documentation <cgroupv2-limits-distributor>` で説明されている制限値です。

  タスクの uclamp_max 値が cpu.uclamp.max より大きい場合、タスクは cgroup cpu_max を継承します。
  タスクは cgroup cpu.uclamp.max 値を継承します。

  cgroup 階層では、実効 cpu.uclamp.max は (child、
  親）の最小値です。

例えば、次のようなパラメータがあるとします：

::

        p0->uclamp[UCLAMP_MIN] = // system default;
        p0->uclamp[UCLAMP_MAX] = // system default;

        p1->uclamp[UCLAMP_MIN] = 40% * 1024;
        p1->uclamp[UCLAMP_MAX] = 50% * 1024;

        cgroup0->cpu.uclamp.min = 20% * 1024;
        cgroup0->cpu.uclamp.max = 60% * 1024;

        cgroup1->cpu.uclamp.min = 60% * 1024;
        cgroup1->cpu.uclamp.max = 100% * 1024;                                
                                   
p0とp1がcgroup0にアタッチされている場合、値は次のようになる：
  
::

        p0->uclamp[UCLAMP_MIN] = cgroup0->cpu.uclamp.min = 20% * 1024;
        p0->uclamp[UCLAMP_MAX] = cgroup0->cpu.uclamp.max = 60% * 1024;

        p1->uclamp[UCLAMP_MIN] = 40% * 1024; // intact
        p1->uclamp[UCLAMP_MAX] = 50% * 1024; // intact

p0とp1がcgroup1にアタッチされている場合、値は次のようになる：
  
::

        p0->uclamp[UCLAMP_MIN] = cgroup1->cpu.uclamp.min = 60% * 1024;
        p0->uclamp[UCLAMP_MAX] = cgroup1->cpu.uclamp.max = 100% * 1024;

        p1->uclamp[UCLAMP_MIN] = cgroup1->cpu.uclamp.min = 60% * 1024;
        p1->uclamp[UCLAMP_MAX] = 50% * 1024; // intact

cgroupインターフェースでは、cpu.uclamp.maxの値がcpu.uclamp.minの値より小さくなることに注意してください。
cpu.uclamp.minより小さくすることができる。他のインターフェースでは許可されていない。

3.3. システムインターフェース
-------------------------

3.3.1 sched_util_clamp_min
--------------------------

システム全体で許容されるUCLAMP_MINの範囲。デフォルトでは1024に設定されています、
つまり、有効な UCLAMP_MIN の範囲は [0:1024] です。
例えば512に変更すると[0:512]になります。これは
タスクが獲得できるブースト量を制限するのに便利です。

タスクからのこのノブ値を超えるリクエストは成功しますが、ノブ値が0になるまでそのリクエストは満たされません。
p->uclamp[UCLAMP_MIN]以上でなければなりません。

この値はsched_util_clamp_max以下でなければなりません。

3.3.2 sched_util_clamp_max
--------------------------

システム全体で許容されるUCLAMP_MAXの範囲。デフォルトでは1024に設定されています。
つまり、有効な UCLAMP_MAX 範囲は [0:1024] です。

例えば512に変更すると、有効な許容範囲は次のようになります。
[0:512]. これは、512以上のタスクは実行できないことを意味します。
rqも制限される。つまり、システム全体の性能は半分に制限される。

これは、システム全体の最大性能点を制限するのに便利である。
たとえば、バッテリー残量が少ないときや、システムがアクセスを制限したいときに、パフォーマンスを制限するのに便利だ。
へのアクセスを制限したい場合などに便利です。
レベルへのアクセスを制限したい場合に便利です。

タスクがこのノブ値を超えてもリクエストは成功しますが、ノブ値が0になるまでリクエストは満たされません。
p->uclamp[UCLAMP_MAX]以上でなければなりません。

この値はsched_util_clamp_min以上でなければならない。

.. _uclamp-default-values:

3.4. デフォルト値
---------------

デフォルトでは、すべてのSCHED_NORMAL/SCHED_OTHERタスクは初期化されます：

::

        p_fair->uclamp[UCLAMP_MIN] = 0
        p_fair->uclamp[UCLAMP_MAX] = 1024

つまり、デフォルトでは、ブート時または実行時に変更された最大パフォーマ ンス・ポイントで実行されるようにブーストされる。
つまり、デフォルトでは、ブーストされ、ブート時またはランタイム時に変更された最大性能ポイントで実行される。なぜこれを提供しなければならないかについては、まだ議論されていない。
しかし、将来的に追加することは可能である。

SCHED_FIFO/SCHED_RRタスクの場合：

::

        p_rt->uclamp[UCLAMP_MIN] = 1024
        p_rt->uclamp[UCLAMP_MAX] = 1024

つまり、デフォルトではシステムの最大性能ポイントで実行されるようにブーストされる。
で実行されるようにブーストされる。

RTタスクのデフォルトのuclamp_min値は、ブート時または実行時に
で変更できます。以下のセクションを参照してください。

.. _sched-util-clamp-min-rt-default:

3.4.1 sched_util_clamp_min_rt_default
-------------------------------------

最大性能ポイントでRTタスクを実行することは、バッテリー駆動のデバイスでは高価であり、必要ではありません。
デバイスでは高価であり、必要ではない。システム開発者が、RTタスクの性能保証を
を提供できるようにするためである。
このsysctlノブにより、システム要件に対応する最適なブースト値を調整することができます。
このsysctlノブにより、常に最大性能で動作させて電力を消費させることなく
ブースト値を調整することができます。

アプリケーション開発者は、タスクごとのutil clampインターフェイスを使用することが推奨される。
理想的には、システム設計者は、このノブを0に設定し、パフォーマンス要件を管理するタスクをアプリに任せるのが理想的です。

4. util clampの使い方
====================

util clamp は、ユーザー空間を補助する電力と性能管理の概念を促進します。
を促進します。スケジューラ・レベルでは、最適な判断を下すために必要な情報はありません。
を決定するために必要な情報はありません。しかし、util clampを使えば、ユーザー空間がスケジューラーにヒントを与えて、タスクの配置と頻度の選択について、より良い決定を下すことができます。
タスクの配置や頻度の選択について、より良い決定をするためのヒントを与えることができる。

最良の結果は、アプリケーションが動作しているシステムに関していかなる仮定も立てず、それを利用することで達成される。
アプリケーションを動的に監視し、調整するためのフィードバックループと併用することである。
動的に監視し調整する。最終的には、これによってより良いユーザー体験を、より良いパフォーマンス/ワット
ユーザー・エクスペリエンスを、より良いパフォーマンス/ワットで実現できる。

システムやユースケースによっては、静的なセットアップが良い結果を出すのに役立つ。
この場合、移植性が問題になる。100、200、1024でどれだけの仕事ができるか、
200や1024でどれだけの仕事ができるかは、システムごとに異なる。特定の
静的なセットアップは避けるべきだ。

utilクランプをベースにしたフレームワーク全体や、utilクランプを利用した自己完結型のアプリを作る可能性は十分にある。
をベースとしたフレームワーク全体を作成したり、それを直接利用する自己完結型のアプリを作成したりする可能性は十分にある。

4.1 重要でDVFSレイテンシに敏感なタスクをブースト
-----------------------------------------

GUIタスクは、起動時に周波数を高くするほどビジーではないかもしれません。
は、ウェイクアップ時に周波数を高くするほど忙しくはないかもしれません。しかし、期待されるユーザー体験を提供するために、特定の時間枠内に作業を終了する必要があります。
しかし、期待されるユーザー・エクスペリエンスを提供するためには、特定の時間内に作業を終了する必要があります。ウェイクアップ時に必要な適切な周波数はシステムに依存します。
ウェイクアップ時に必要となる適切な周波数は、システムに依存する。ある種のパワー不足のシステムでは周波数が高くなる、
一方、オーバーパワーなシステムでは、低いか0になる。

このタスクは、次のウェイクアップ時に実行されるように、期限を過ぎるたびに UCLAMP_MIN 値を増やすことができます。
を増加させることができる。このタスクは
このタスクは、次のウェイクアップ時に、より高いパフォーマンスポイントで実行できるように、デッドラインに間に合わないたびにUCLAMP_MIN値を増やすことができます。
そのシステムで可能な限り最高のパフォーマンス/ワットを達成するためである。

ヘテロジニアスシステムでは、このタスクは以下のCPUで実行することが重要かもしれない。
より高速なCPUで実行することが重要かもしれない。

**一般的には、入力を性能レベルまたはポイントとして認識することを推奨する。
これはタスクの配置と周波数の選択の両方を意味する。**

4.2. バックグラウンドタスクにキャップ
-------------------------------

冒頭でAndroidの場合について説明したのと同じです。どのようなアプリでも
バックグラウンド・タスクの UCLAMP_MAX を下げることができます。

4.3. パワーセーブモード
-------------------

sched_util_clamp_max システム・ワイド・インターフェイスを使用することで、すべてのタ スクが、システム上の不要なシステム・リソースを消費しないように制限することができま す。
すべてのタスクが、通常エネルギー効率の悪い高パフォーマンス・ポイントで動作しないように制限することができます。
を制限することができる。

これはuclampに限ったことではありません。
の周波数を下げることで同じことが実現できる。より便利な
代替インターフェースと考えることができる。

4.4. アプリごとの性能制限
----------------------

ミドルウェア/ユーティリティは、実行されるたびにアプリに対して UCLAMP_MIN/MAX を設 定するオプションをユーザに提供することができます。
を設定するオプションをユーザに提供することができます。
アプリが実行されるたびに、そのアプリに対して UCLAMP_MIN/MAX を設定するオプショ ンをユーザに提供することができます。
を設定するオプションがあります。

外出先でラップトップが加熱するのを防ぎたい場合
カーネルをコンパイルしている間にノートパソコンが熱くなるのを防ぎたい。
それでもブラウザーのパフォーマンスを維持したいのであれば、uclampはそれを可能にする。
が可能だ。

5. 制限事項
==============

5.1. uclamp_maxを使った周波数の上限設定は特定の条件下で失敗
----------------------------------------------------

タスクp0が512で実行されるように上限が設定されている場合：

::

        p0->uclamp[UCLAMP_MAX] = 512

で実行され、どの性能点でも自由に実行できるp1とrqを共有する：

::

        p1->uclamp[UCLAMP_MAX] = 1024

を共有する場合、最大アグリゲーションにより、 rq は最大性能ポイントに達することが許される。
に達する：

::

        rq->uclamp[UCLAMP_MAX] = max(512, 1024) = 1024

p0とp1の両方がUCLAMP_MIN = 0であると仮定すると、rqの周波数選択は実際の性能に依存することになる。
の頻度選択は、タスクの実際の使用率に依存する。

p1が小さなタスクで、p0がCPU負荷の高いタスクである場合、両タスクが同じrqで動作しているため、rqの周波数選択はタスクの実際の使用値に依存する。
が同じrqで実行されているという事実により、p1はrqから周波数上限を外すことになる。
p1はどの性能点でも実行可能であるが、p0はrqから周波数上限を取り残すことになる、
は実際にはその周波数で実行する必要はない。

5.2. UCLAMP_MAXがPELT（util_avg）シグナルを壊す可能性
------------------------------------------------

PELTは、信号が大きくなるにつれて周波数が常に上昇し、CPUのアイドル時間が常に確保されることを想定している。
PELTは、CPUに常にアイドル時間があることを保証するために、信号が大きくなるにつれて周波数が常に上がると仮定している。しかし、UCLAMP_MAXを使用すると、この周波数の増加が妨げられます。
を使用すると、この周波数の増加が妨げられ、アイドル時間がなくなる場合があります。
状況によってはアイドル時間がなくなる。アイドル時間がない場合、タスクはビジー・ループにはまります、
util_avgが1024になる。

後述の問題と組み合わせると、これは不要な頻度スパイクを引き起こす可能性がある。
を共有する場合。

例として、以下のようなタスクpがあるとする：

::

        p0->util_avg = 300
        p0->uclamp[UCLAMP_MAX] = 0

がアイドル状態のCPUでウェイクアップした場合、そのタスクは、そのCPUが可能な最小周波数（Fmin）で実行されます。
CPUの最大周波数（Fmax）も重要で。終了させる最短の計算時間を指定するからです。

::

        rq->uclamp[UCLAMP_MAX] = 0

Fmax/Fminの比が3であれば、最大値は次のようになる：

::

        300 * (Fmax/Fmin) = 900


これは、900が1024未満であるため、CPUがまだアイドル時間であることを示している。これは
実際のutil_avgは900ではなく、300と900の間のどこかになります。アイドル時間がある限り
アイドル時間がある限り、p->util_avgの更新は多少の誤差が生じる、
しかし、Fmax/Fminには比例しない。

::

        p0->util_avg = 300 + small_error

ここで、Fmax/Fminの比を4とすると、最大値は次のようになる：

::

        300 * (Fmax/Fmin) = 1200

これは1024より高く、CPUにアイドル時間がないことを示す。この場合
この場合、実際のutil_avgは次のようになる：

::

        p0->util_avg = 1024


タスクp1がこのCPU上でウェイクアップすると、次のようになる：

::

        p1->util_avg = 200
        p1->uclamp[UCLAMP_MAX] = 1024

である場合、このCPUの実効UCLAMP_MAXは1024になります。
になります。しかし、キャップされたp0タスクが実行され、スロットルされているため、rq->uclamp[UCLAMP_MAX] = 1024となります。
しかし、キャップされたp0タスクが実行され、厳しくスロットルされているので、rq->util_avgは次のようになる：

::

        p0->util_avg = 1024
        p1->util_avg = 200

        rq->util_avg = 1024
        rq->uclamp[UCLAMP_MAX] = 1024

したがって、もしp0がスロットルされていなければ、周波数スパイクが発生するはずである：

::

        p0->util_avg = 300
        p1->util_avg = 200

        rq->util_avg = 500

となり、Fmaxではなく、そのCPUの中間性能ポイント付近で動作することになる。

5.3. Schedutil の応答時間の問題
-----------------------------

schedutilには3つの制限がある：

        1. ハードウェアが周波数変更要求に応答するのに0ではない時間がかかる。リクエストに応答するのに0ではない時間がかかる。プラットフォームによっては、数msのオーダーになることもある。
        2.高速スイッチでないシステムでは、ワーカーデッドラインスレッドがウェイクアップして周波数変更を実行する必要がある。これは、測定可能なオーバーヘッドを追加する。
        3. schedutilのrate_limit_usは、このrate_limit_usウィンドウの間にあるリク エストをすべてドロップする。ウィンドウの間、全てのリクエストを落とす。

比較的小さなタスクがクリティカルな仕事をしていて、それがウェイクアップし
比較的小さなタスクがクリティカルな仕事をしていて、起動時に一定のパフォーマン
このような制限は、そのタスクが期待する時間スケールで望むものを得ることを妨げます。
を期待することができなくなる。

この制限は、uclampを使用するときに影響があるだけでなく、今後さらに広まっていくだろう。
この制限は、uclampを使用しているときに影響があるだけでなく、徐々にランプを上げたり下げたりしなくなるため、より一般的になる。私たちは簡単に
タスクのウェイクアップの順番と、それぞれのuclampの値によって、周波数が飛び交うことになる。
それぞれのuclampの値によって、簡単に周波数を飛び越えることができる。

これは、基本的なシステム自体の能力の限界と考えます。
の能力の限界だと考えている。

schedutilのrate_limit_usの動作を改善する余地はあるが、1,2.についてはあまりできない。
1,2については、それほど多くのことはできません。これらはシステムのハード的な制限と考えられる。
