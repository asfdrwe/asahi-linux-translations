.. SPDX-License-Identifier: GPL-2.0

`Utilization Clamping <https://docs.kernel.org/scheduler/sched-util-clamp.html>`_  の非公式日本語訳です。
ライセンスは原文のGPL-2.0に従います。

==============================
Utilization Clamping(稼働率固定)
==============================

1.はじめに
=========

Utilization Clamping (util clampまたはuclampとも呼ばれる）はスケジューラ機能の１つで、タスクの
性能要件を管理するのに役立ちます。v5.3 リリースで導入されました。CGroupでの対応は v5.4 で統合されました。

uclampは、スケジューラがタスクの性能要件と制約を理解できるようにするヒント機構で、スケジューラがより良い判断を
下すのに役立ちます。また、schedutil cpufreqガバナーが使用されていると、util clampはCPUの周波数選択にも影響を与えます。

スケジューラとschedutilはともにPELT
(訳注: `Per Entity Load Tracking <https://docs.kernel.org/scheduler/schedutil.html#pelt-per-entity-load-tracking>`_)（util_avg）信号によって駆動されるので、util clamp は、その信号をあるポイントにclamp(固定)することで
目的を達成します。これが名前の由来です。つまり、utilization(稼働率)をclamp(固定)することでシステムをある性能ポイントで
動作させるということになります。

util clampの正しい見方は、性能制約の要求やヒントを出すための機構であるということです。
2つの調整変数で構成されています::

        * UCLAMP_MIN、下限を設定
        * UCLAMP_MAX、上限を設定

この2つの境界がタスクがこの性能範囲内で動作することを保証します。UCLAMP_MINはタスクをブーストすることを意味し、
UCLAMP_MAXはタスクに上限を設定することを意味します。

システム（スケジューラ）に対して、望ましいユーザー体験を提供するために、あるタスクが最小限の性能ポイントを必要と
していると示すことができます。あるいは、システム（スケジューラ）に対して、あるタスクはリソースを消費し過ぎないように
制限されるべきで、ある性能ポイント以上になるべきではないと示すこともできます。
uclampの値を、稼働率ではなく性能ポイントとして見ることは、ユーザー空間の観点からはより良い抽象化になります。

例として、ゲームは uclamp を利用して、認識可能なFPS（Frames Per Second）とフィードバックループを形成することができます。
フレームがドロップしないように、ディスプレイパイプラインが必要とする最小性能ポイントを動的に上げることができます。
また、数百ミリ秒後に計算負荷の高いシーンが発生することがわかっている場合、これらのタスクを動的に『盛る(prime up)』ことも
できます。

機器の能力が多様なモバイルハードウェアでは、この動的なフィードバックループが大きな柔軟性を提供し、
あらゆるシステムの能力を考慮した上で、最高のユーザー体験を保証することができます。

もちろん静的な構成も可能です。システムやアプリケーションそして望む結果によって正しい使い方が決定されます。

別の例として、Androidでは、タスクはバックグラウンド、フォアグラウンド、トップアプリなどに分類されます。
util clampを使用すると、バックグラウンドタスクが実行できる性能ポイントに上限を設定することで、バックグラウンドタスクが
消費するリソースの量を制限できます。この制約は、現在アクティブなアプリ（トップアプリグループ）に属するような重要なタスクの
リソースを確保するのに役立ちます。また、消費電力の制限にも役立ちます。これは、ヘテロジニアスシステム（Arm big.LITTLEなど）
ではより顕著になります。この制約によってバックグラウンドタスクが little コアにとどまるように方向づけできます::

  1. bigコアはトップアプリタスクを即座に実行可能。トップアプリタスクは、ユーザーが現在操作しているタスクであり、システムで最も重要なタスク
  2. たとえCPU負荷の高いタスクであっても、電力消費の激しいコアで実行されてバッテリーを消耗することはありません


.. 注釈::
  **little コア**:
    CPUs with capacity < 1024

  **big コア**:
    CPUs with capacity = 1024

uclampがこのような性能要求やヒントを出すことで、ユーザースペースはシステムリソースが可能な限り最高のユーザーエクスペリエンスが
提供されるよう保証します。

もう1つの使用例は、 **スケジューラ稼働率信号の計算方法に継承される遅延増加の克服を** 支援することです。

一方、最大の性能ポイントで実行する必要があるビジーなタスクは、スケジューラが認識するのに200ms(PELT HALFIFE = 32ms)以下の
遅延を被ることになります。これは、モバイル機器でのゲームのような作業負荷に影響することが知られており、タスクが時間内に作業を
終えるために必要な高い周波数を選択するための応答時間が遅いために、フレームがドロップします。UCLAMP_MIN=1024 を設定することで、
そのようなタスクが実行を開始したときに、常に最高の性能レベルが表示されます。

目に見える全体的な効果は、知覚されるユーザーエクスペリエンスや性能が向上するだけではありません。
効果的に使用された場合、全体的により良い 性能/ワット比 を達成するのに役立ちます。

ユーザースペースは、機器を押さえつけて熱くならないようにするために、熱量サブシステムとフィードバックループを形成できます。

SCHED_NORMAL/OTHERもSCHED_FIFO/RRも、uclampの要求やヒントを尊重します。

SCHED_FIFO/RRの場合、uclampはRTタスク(訳注: `Real Timeタスク <https://docs.kernel.org/scheduler/sched-rt-group.html>`_)を
常にMAX周波数に縛られるのではなく任意の性能ポイントで実行するオプションを与えます。
これはは、バッテリー駆動の機器で動作する一般的なシステムで有用です。

設計上、RTタスクはタスクごとのPELT信号を持たず、常に一定の周波数で実行しなければならないことに注意してください。

schedutilを使用すると、RTタスクが起床するときに、周波数を変更するために常に1回の遅延が発生することに注意してください。
このコストはuclampを使っても変わりません。uclampは、schedutilがすべてのRTタスクに対して常にMAXを要求する代わりに、
要求する周波数を選ぶのを助けるだけです。

デフォルト値については 
:ref:`3.4節 <uclamp-default-values>` を参照してください。
RTタスクのデフォルト値を変更する方法については 
:ref:`3.4.1 <sched-util-clamp-min-rt-default>` を参照してください。

2. 設計
=======

util clampはシステム内のすべてのタスクのプロパティです。その稼働率信号の境界を設定します。
スケジューラ内の特定の決定に影響を与える偏りを与える機構(bias mechanism)として機能します。

タスクの実際の稼働率信号が固定化(clamped)されることは現実にはありません。もし　PELT 信号を検査すれば、
そのままのシグナルが表示されるはずです。固定化は必要な時にだけ行われます。例えば、タスクが起動し、
スケジューラがそのタスクに適したCPUを選択する必要があるときなどです。

util clamp の目的は、タスクが実行するための最小性能ポイントと最大性能ポイントを要求できるようにすることなので、
周波数選択だけでなくタスク配置にも影響を与えることができなければなりません。どちらもCPU実行キュー
（runqueue、略してrq）レベルの稼働率値に影響を与えます。

タスクがrq上で起床するとき、そのrqの稼働率信号は、そのrqにキューイングされているすべてのタスクのuclamp設定に影響されます。
例えばあるタスクが UTIL_MIN = 512 での実行を要求した場合、rqの稼働率信号は、この要求だけでなく、すべてのキューイングされた
タスクからの他の要求も尊重する必要があります。

rqにアタッチされたすべてのタスクのutil clamp値を集約するために、uclampは、スケジューラのホットパスである
エンキュー/デキューごとに管理しなければなりません。したがって、速度低下は多くのユースケースに大きな影響を与え、
実際の使い勝手を妨げる可能性があるため、注意が必要です。

これを処理する方法は、稼働率範囲をバケット(構造体uclamp_bucket）に分割することです。
rq上のすべてのタスクから一番上のバケット上のタスクのサブセットだけに探索空間を縮小することができます。

タスクがエンキューされると、適合するバケットのカウンタが増加され、デキューされると減少されます。これにより、
rqでの実効uclamp値の追跡が非常に簡単になります。

タスクがエンキューされたりデキューされたりする際に、rqレベルの実効uclamp値を追跡します。
この仕組みの詳細については :ref:`2.1節 <uclamp-buckets>` を参照してください。

後でrqの有効なuclamp値を特定したいパスでは、単にそのrqの有効なuclamp値を読み取る必要があります。

タスク配置の場合、今のところ、エネルギーを考慮したスケー樹リングと容量を考慮したスケジューリング(Energy Aware Scheduling, 
EASおよびにCapacity Aware Scheduling  CAS)のみがuclampを利用しており、ヘテロジニアスシステムにのみ適用されます。
タスクが起床すると、スケジューラは各rqの現在の有効uclamp値を見て、そのタスクがそこでエンキューされた場合の新しい値と比較します。
最もエネルギー効率の良い組み合わせになるrqを優先します。

同様にschedutilでは、周波数更新が必要な場合、現在そこにキューイングされているタスクセットの影響を受けるrqの現在の
有効なuclamp値を調べ、要求からの制約を満たす適切な周波数を選択します。

過稼働状態の設定（これは事実上EASを無効化）のような他のパスも同様にuclampを使用します。このようなケースは、上記の2つの
主なユースケースを可能にするために必要な管理と考えられ、実装の詳細によって変わる可能性があるため、ここでは詳しく説明しません。

.. _uclamp-buckets:

2.1. バケット
-------------

.. image:: uc01.png

(訳注: Githubがうまく処理してくれないので画像で貼り付け)

.. note::
  上の図は、内部データ構造を忠実に描写したものではなく説明図です。

タスクがエンキュー/デキューされるときに、rqの有効なuclamp値を決定しようとするときの探索空間を縮小するため、
利用範囲全体はN個のバケットに分割され、Nはコンパイル時にCONFIG_UCLAMP_BUCKETS_COUNTで設定します。
デフォルトでは5です。

rqはuclamp_idごとにバケットを持ちます： [uclamp_min, uclamp_max]。

各バケットの範囲は1024/Nです。例えば、デフォルト値の5の場合、5つのバケットがあり、それぞれのバケットは以下の範囲をカバーします。

::

        DELTA = round_closest(1024/5) = 204.8 = 205

        Bucket 0: [0:204]
        Bucket 1: [205:409]
        Bucket 2: [410:614]
        Bucket 3: [615:819]
        Bucket 4: [820:1024]

以下の調整可能なパラメータを持つタスクpの場合

::

        p->uclamp[UCLAMP_MIN] = 300
        p->uclamp[UCLAMP_MAX] = 1024

がrqにエンキューされると、rqがこの範囲のタスクを持っていることを反映するために、バケット1がUCLAMP_MINまで
増加され、バケット4がUCLAMP_MAXまで増加されます。

rqはそれからuclamp_idの現在の有効uclamp値を追跡します。

タスクpがエンキューされると、rqの値は次のように変化します。

::

        // update bucket logic goes here
        rq->uclamp[UCLAMP_MIN] = max(rq->uclamp[UCLAMP_MIN], p->uclamp[UCLAMP_MIN])
        // repeat for UCLAMP_MAX

同様に、pがデキューされると、rqの値は次のように変化します。

::

        // update bucket logic goes here
        rq->uclamp[UCLAMP_MIN] = search_top_bucket_for_highest_value()
        // repeat for UCLAMP_MAX

すべてのバケットが空になると、rq uclamp 値はシステムのデフォルト値にリセットされます。
デフォルト値の詳細については :ref:`3.4節 <uclamp-default-values>` を参照してください。

2.2. 最大値集約
-------------
  
util clamp は、最も高い性能ポイントを必要とするタスクの要求を尊重するように調整さます。

複数のタスクが同じrqにアタッチされている場合、util clampは、最も高い性能ポイントを必要とするタスクが
たとえそのポイントを必要としないタスクや、そのポイントへの到達を許可されないタスクがあったとしても、
確実にそのポイントを獲得できるようにしなければなりません。

例えば、次のようなrqに複数のタスクがアタッチされている場合

::

        p0->uclamp[UCLAMP_MIN] = 300
        p0->uclamp[UCLAMP_MAX] = 900

        p1->uclamp[UCLAMP_MIN] = 500
        p1->uclamp[UCLAMP_MAX] = 500

p0とp1の両方が同じrqにキューイングされていると仮定すると、UCLAMP_MINとUCLAMP_MAXの両方が次のようになります。

::

        rq->uclamp[UCLAMP_MIN] = max(300, 500) = 500
        rq->uclamp[UCLAMP_MAX] = max(900, 500) = 900

:ref:`5.1節 <uclamp-capping-fail>` で説明するように、この最大値集約はutil clampを使用する際の制限の一つです。
特に、ユーザースペースが電力を節約したいときに、UCLAMP_MAXヒントを使用するときの制限の1つです。

2.3. 階層的集約
-------------

先に述べたように、util clampはシステム内のすべてのタスクの特性です。
しかし、実際に適用される(実効)値は、タスクまたはタスクに代わって別のアクター(ミドルウェアライブラリ)が行う要求だけではありません。

どのタスクのutil clampの実効値も次のように制限されます。

  1. cgroup CPUコントローラが接続し定義しているuclamp設定（もしあれば）
  2. (1)で制限された値は、システム全体のuclamp設定によってさらに制限

:ref:`3章 <uclamp-interfaces>` ではインターフェースについてさらに詳しく説明し、拡張します。

今のところタスクが要求した場合、その実際の実効値は、cgroupやシステム全体の設定によって課されるいくつかの制限に
従わなければならない、ということだけで十分です。

システムはたとえ実効値が制約を越えても要求を受け入れますが、タスクが別の cgroup に移動したり、
システム管理者ががシステム設定を変更すると、要求は新しい制約の範囲内である場合にのみ満たされます。

言い換えると、この集約は、タスクがuclamp値を変更したときにエラーを発生させません。
というか、そのような要因に基づく要求を満たすことができないかもしれないということになります。

2.4. 範囲
--------

Uclamp性能要求は0から1024の範囲です。

cgroup インタフェースではパーセンテージが使用されます (0 から 100 まで含まれます)。
他のcgroupインターフェイスと同様に、100の代わりに『max』を使用できます。

.. _uclamp-interfaces:

3. インターフェイス
================

3.1. タスクごとのインターフェース
----------------------------
  
sched_setattr() syscall が拡張され、2つの新しいフィールドを受け付けるようになりました。

* sched_util_min: このタスク実行時にシステムが実行すべき最小性能ポイントを要求、または、性能の下限を要求
* sched_util_max: このタスク実行時にシステムが実行すべき最大性能ポイントを要求、または、性能の上限を要求

例えば、次のシナリオでは40%から80%の稼働率制限になります。

::

        attr->sched_util_min = 40% * 1024;
        attr->sched_util_max = 80% * 1024;

タスク@p が実行されているとき、**スケジューラはタスク@pが40%の性能レベルで開始されるように最善を尽くさなければなりません**。
タスクが十分長い時間実行され、実際の稼働率が80%以上になると、稼働率、つまり性能レベルには上限が設定されます。

特別な値 -1 は、uclamp設定をシステムのデフォルトにリセットするために使われます。

-1 を使用してuclamp値をシステムデフォルトにリセットすることは、uclamp値を手動でシステムデフォルトに設定することとは異なります。
この区別は重要です。というのも、システムインターフェースで見るように、RTのデフォルト値は変更可能だからです。
SCHED_NORMAL/OTHERも将来、同様のノブを持つようになるかもしれません。

3.2. cgroupインターフェース
-------------------------

CPU cgroupコントローラには、uclamp関連の値が2つあります。

* cpu.uclamp.min
* cpu.uclamp.max

タスクがCPUコントローラにアタッチされると、そのuclamp値は次のように影響を与えます。

* cpu.uclamp.min は `cgroup v2文書の3.3節 <https://docs.kernel.org/admin-guide/cgroup-v2.html#protections>`_ で説明されている保護です。

  タスクの uclamp_min 値が cpu.uclamp.min より小さい場合、タスクは cgroup cpu_min を継承します。

  cgroup 階層では、実効 cpu.uclamp.min は 子または親の最大値です。

* cpu.uclamp.max は `cgroup v2文書の3.2節 <https://docs.kernel.org/admin-guide/cgroup-v2.html#limits>`_ で説明されている制限値です。

  タスクの uclamp_max 値が cpu.uclamp.max より大きい場合、タスクは cgroup cpu_max を継承します。

  cgroup 階層では、実効 cpu.uclamp.max は 子または親の最小値です。

例えば、次のようなパラメータがあるとします。

::

        p0->uclamp[UCLAMP_MIN] = // system default;
        p0->uclamp[UCLAMP_MAX] = // system default;

        p1->uclamp[UCLAMP_MIN] = 40% * 1024;
        p1->uclamp[UCLAMP_MAX] = 50% * 1024;

        cgroup0->cpu.uclamp.min = 20% * 1024;
        cgroup0->cpu.uclamp.max = 60% * 1024;

        cgroup1->cpu.uclamp.min = 60% * 1024;
        cgroup1->cpu.uclamp.max = 100% * 1024;                                


p0とp1がcgroup0にアタッチされている場合、値は次のようになります。
  
::

        p0->uclamp[UCLAMP_MIN] = cgroup0->cpu.uclamp.min = 20% * 1024;
        p0->uclamp[UCLAMP_MAX] = cgroup0->cpu.uclamp.max = 60% * 1024;

        p1->uclamp[UCLAMP_MIN] = 40% * 1024; // intact
        p1->uclamp[UCLAMP_MAX] = 50% * 1024; // intact

p0とp1がcgroup1にアタッチされている場合、値は次のようになります。
  
::

        p0->uclamp[UCLAMP_MIN] = cgroup1->cpu.uclamp.min = 60% * 1024;
        p0->uclamp[UCLAMP_MAX] = cgroup1->cpu.uclamp.max = 100% * 1024;

        p1->uclamp[UCLAMP_MIN] = cgroup1->cpu.uclamp.min = 60% * 1024;
        p1->uclamp[UCLAMP_MAX] = 50% * 1024; // intact

cgroupインターフェースでは、cpu.uclamp.maxの値がcpu.uclamp.minの値より小さくなることが許可されていることに
注意してください。他のインターフェースでは許可されていません。

3.3. システムインターフェース
-------------------------

3.3.1 sched_util_clamp_min
--------------------------

システム全体で許可されるUCLAMP_MINの範囲です。デフォルトでは1024に設定されています。
つまり、有効な UCLAMP_MIN の範囲は [0:1024] です。例えば512に変更すると[0:512]になります。
これはタスクが獲得できるブースト量を制限するのに便利です。

タスクからのこのノブ値を超える要求は成功しますが、p->uclamp[UCLAMP_MIN]以上になるまでその要求は満たされません。

この値はsched_util_clamp_max以下でなければなりません。

3.3.2 sched_util_clamp_max
--------------------------

システム全体で許容されるUCLAMP_MAXの範囲。デフォルトでは1024に設定されています。
つまり、有効な UCLAMP_MAX 範囲は [0:1024] です。

例えば512に変更すると[0:512]になります。 これは、512以上のタスクは実行できないことを意味し、
rqも制限されます。つまり、システム全体の性能は半分に制限されます。

これは、システム全体の最大性能ポイントを制限するのに便利です。例えば、バッテリー残量が少ないときに性能を制限したり、
システムがアイドル状態や画面がオフのときに、よりエネルギーを消費する性能レベルへのアクセスを制限したいときに便利です。

タスクがこのノブ値を超えても要求は成功しますが、p->uclamp[UCLAMP_MAX]以上になるまで要求は満たされません。
p->uclamp[UCLAMP_MAX]以上でなければなりません。

この値はsched_util_clamp_min以上でなければなりません。

.. _uclamp-default-values:

3.4. デフォルト値
---------------

デフォルトでは、すべてのSCHED_NORMAL/SCHED_OTHERタスクは初期化されます。

::

        p_fair->uclamp[UCLAMP_MIN] = 0
        p_fair->uclamp[UCLAMP_MAX] = 1024


つまり、デフォルトでは、ブート時または実行時に変更された最大性能ポイントで実行されるようにブーストされます。
なぜこれを提供しなければならないかについては、まだ議論されていませんが、しかし、将来的に追加することは可能です。

SCHED_FIFO/SCHED_RRタスクの場合。

::

        p_rt->uclamp[UCLAMP_MIN] = 1024
        p_rt->uclamp[UCLAMP_MAX] = 1024


つまりデフォルトでは、RTタスクの過去の動作を維持したまま、システムの最大性能ポイントで実行されるようにブーストされます。

RTタスクのデフォルトのuclamp_min値は、ブート時または実行時にで変更できます。次の節ンを参照してください。

.. _sched-util-clamp-min-rt-default:

3.4.1 sched_util_clamp_min_rt_default
-------------------------------------

最大性能ポイントでRTタスクを実行することは、バッテリー駆動の機器では高価であり不必要です。
これらのタスクに対して最大性能ポイントまで追い込むことなく十分な性能保証をシステム開発者に提供できるようにするために、
このsysctlノブにより、常に最大パフォーマンスポイントで動作させることで電力を消費することなく、システム要件に対応する
最適なブースト値を調整することができます。

アプリケーション開発者は、タスクごとのutil clampインターフェイスを使用することが推奨されます。
理想的には、システム設計者は、このノブを0に設定し、性能要件を管理するタスクをアプリに任せるのが理想的です。

4. util clampの使い方
====================

util clamp は、ユーザースペースが電力と性能の管理を補助する概念を促進します。
スケジューラレベルでは、最適な判断を下すために必要な情報はありません。
ですが、util clampを使えば、ユーザースペースがスケジューラーにヒントを与えて、タスクの配置と頻度の選択について、
より良い決定を下すことができます。

アプリケーションが動作しているシステムに関していかなる仮定も持たず、動的に監視し調整するためのフィードバックループと
併用することで、最良の結果が得られます。最終的には、これによってより良いユーザーエクスペリエンスを、より良い性能/ワットで
実現できます。

システムやユースケースによっては、静的なセットアップが良い結果を出すのに役立ちます。
この場合、移植性が問題になります。100、200、1024でどれだけの仕事ができるかはシステムごとに異なります。
特定のターゲットシステムがない限り、静的なセットアップは避けるべきです。

util clampをベースにしたフレームワーク全体や、util clampを利用した自己完結型のアプリを作る可能性は十分あります。

4.1 重要でDVFS遅延に敏感なタスクをブースト
------------------------------------

GUIタスクは、起床時に周波数を高くするほどビジーではないかもしれません。
しかし、期待されるユーザー・エクスペリエンスを提供するためには、特定の時間内に作業を終了する必要があります。
起床時に必要な適切な周波数はシステムに依存します。ある種のパワー不足のシステムでは周波数が高くなり、
別のオーバーパワーなシステムでは、低いか0になります。

このタスクは、期限を守れなかったたびにUCLAMP_MIN値を増やし、次の起床時に高い性能で実行できるようにすることができます。
そのシステムで可能な限り最高の性能/ワットを達成するために、特定のシステムで期限を守ることができる最低のUCLAMP_MIN値に
近づこうとするはずです。

ヘテロジニアスシステムでは、このタスクはより高速なPUで実行することが重要かもしれません。

**一般的には、タスク配置と周波数選択の両方を意味する性能レベルまたはポイントとして入力を認識することを推奨します**

4.2. バックグラウンドタスクに制限
-------------------------------

冒頭でAndroidの場合について説明したのと同じです。
どんなアプリでも、性能に関係ないがビジーになりシステム上の不要なシステムリソースを消費する可能性のある
バックグラウンドタスクのUCLAMP_MAXを下げることができます。

4.3. パワーセーブモード
--------------------

sched_util_clamp_max システムワイドインターフェイスを使用することで、すべてのタスクが、通常エネルギー効率の悪い、
より高い性能ポイントで動作しないように制限できます。

これはuclampに限ったことではなく、cpufreqガバナーの周波数を下げることで同じことが実現できます。
これはより便利な代替インターフェースと考えることができます。

4.4. アプリごとの性能制限
----------------------

ミドルウェア/ユーティリティは、アプリが実行されるたびにそのアプリにUCLAMP_MIN/MAXを設定するオプションをユーザーに提供し、
最小限の性能ポイントを保証するか、またはこれらのアプリの性能を低下させる代償としてシステム電力を消耗しないように制限することができます。

外出先でラカーネルをコンパイルしている間にノートパソコンが熱くなるのを防ぎたいが、ブラウザの性能を維持したいのであれば、
uclampによって可能になります。

5. 制限事項
==========

5.1. uclamp_maxを使った周波数上限設定は特定の条件下で失敗
----------------------------------------------------

タスクp0が512で実行されるように上限が設定されていて

::

        p0->uclamp[UCLAMP_MAX] = 512

どの性能ポイントでも自由に実行できるp1とrqを共有している場合

::

        p1->uclamp[UCLAMP_MAX] = 1024

最大値集約により、 rq は最大性能ポイントに達することが許されます。

::

        rq->uclamp[UCLAMP_MAX] = max(512, 1024) = 1024

p0とp1の両方がUCLAMP_MIN = 0であると仮定すると、rqの周波数選択は実際の稼働率に依存することになります。

p1が小さなタスクだけどp0がCPU負荷の高いタスクである場合、両タスクが同じrqで動作しているため、
p1はどの性能ポイントでも走ることが許されていて、実際にはその周波数で走る必要はないのだけれども、
p1はrqから周波数上限を取り残すことになります。

5.2. UCLAMP_MAXがPELT（util_avg）信号を壊す可能性
------------------------------------------------

PELTは、信号が大きくなるにつれて周波数が常に上昇し、CPUのアイドル時間が常に確保されることを想定していますが、
UCLAMP_MAXを使用すると、この周波数の増加が妨げられ、アイドル時間がなくなる場合があります。
アイドル時間がない場合、タスクはビジーループに陥り、util_avgが1024になります。

後述の問題と組み合わせると、キャップされたタスクがキャップされていない小さなタスクとrqを共有すると、不要な
周波数スパイクが発生する可能性があります。

例として、以下のようなタスクpがあるとします。

::

        p0->util_avg = 300
        p0->uclamp[UCLAMP_MAX] = 0

アイドル状態のCPUで起床した場合、タスクは、そのCPUが可能な最小周波数（Fmin）で実行されます。
CPUの最大周波数（Fmax）も重要で、このCPUでタスクの仕事を終了させる最短の計算時間を示すからです。

::

        rq->uclamp[UCLAMP_MAX] = 0

Fmax/Fminの比が3であれば、最大値は次のようなります。

::

        300 * (Fmax/Fmin) = 900


これは、900< 1024であるため、CPUがまだアイドル時間であることを示しています。実際のutil_avgは900ではなく、
300と900の間のどこかになります。アイドル時間がある限り、p->util_avgの更新は多少の誤差が生じますが、
Fmax/Fminには比例しません。

::

        p0->util_avg = 300 + small_error

ここで、Fmax/Fminの比を4とすると、最大値は次のようになります。

::

        300 * (Fmax/Fmin) = 1200

これは1024より高く、CPUにアイドル時間がないことを示します。この場合、実際のutil_avgは次のようになります。

::

        p0->util_avg = 1024

タスクp1がこのCPU上で起床すると、次のようになります。

::

        p1->util_avg = 200
        p1->uclamp[UCLAMP_MAX] = 1024

このCPUの実際のUCLAMP_MAXは最大値集約ルールにより1024になります。
しかし、キャップされたp0タスクが実行され、強く抑制されているので、rq->util_avgは次のようになります。

::

        p0->util_avg = 1024
        p1->util_avg = 200

        rq->util_avg = 1024
        rq->uclamp[UCLAMP_MAX] = 1024

したがって、もしp0が抑制されなければ、周波数スパイクが発生するでしょう。

::

        p0->util_avg = 300
        p1->util_avg = 200

        rq->util_avg = 500

Fmaxではなく、そのCPUの中間性能ポイント付近で動作することになります。

5.3. Schedutil の応答時間の問題
-----------------------------

schedutilには3つの制限があります。

        1. ハードウェアが周波数変更要求に応答するのに0ではない時間がかかります。プラットフォームによっては、数msのオーダーになることもあります
        2.高速スイッチでないシステムでは、ワーカーデッドラインスレッドが起床して周波数変更を実行する必要があり、測定可能なオーバーヘッドを追加します
        3. schedutilのrate_limit_usは、このrate_limit_usウィンドウの間にある要求をすべて落とします

比較的小さなタスクがクリティカルな仕事をしていて、起動時に一定の性能ポイントを要求している場合、
このような制限はそのタスクが期待する時間スケールで望むものを得ることを妨げます。

この制限は、uclampを使用しているときに影響があるだけでなく、徐々に強化したりしなくなったりするため、より一般的になります。
タスクの起床順番やそれぞれのuclampの値によって、簡単に周波数を飛び越えることができます。

これは、基本的なシステム自体の能力の限界と考えています。

schedutilのrate_limit_usの動作を改善する余地はありますが、1,2.について多くのことはできないでしょう。
これらはシステムのハード的な制限と考えられます。
