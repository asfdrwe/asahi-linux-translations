コントローラ
===========

.. _cgroup-v2-cpu:

CPU
---
cpuコントローラーは、CPUサイクルの配分を調整する。 この
このコントローラは、通常のスケジューリングポリシーではウェイトモデルと絶対帯域幅制限モデル
を実装している。

上記のすべてのモデルにおいて、サイクル分布は時間ベースのみで定義される。
で定義され、タスクが実行される頻度は考慮されない。
(オプションの)利用率クランピングサポートにより、スケジュー ルガバナーであるschedutil
cpufreqガバナーは、CPUが常に提供すべき最小の希望頻度をヒントにすることができます。
CPUが提供すべき最小希望頻度、およびCPUが超えてはならない最大希望頻度について、schedutil cpufreqガバナーにヒントを与えることができる。
を超えてはならない。

警告: cgroup2 はまだリアルタイムプロセスの制御をサポートしていません。
cpuコントローラは、すべてのRTプロセスがルートcgroupにある場合にのみ有効にできます。
にある場合のみ有効です。 システム管理ソフトウェアがすでに
システム管理ソフトウェアが、システムブートプロセス中にRTプロセスを非ルートcgroupsに配置している場合があります。
に配置されている場合があり、cpu コントローラを有効にするには、これらのプロセスをルート cgroupに移動する必要がある場合があります。

CPUインターフェースファイル
~~~~~~~~~~~~~~~~~~~~~~

時間の単位はすべてマイクロ秒です。

  cpu.stat
	読み取り専用のフラットキーファイル。
        このファイルは、コントローラが有効であるかどうかに関係なく存在する。

	常に以下の3つの統計情報を報告する::

	- usage_usec
	- user_usec。
	- system_usec

	コントローラが有効な場合は、以下の5つの統計情報を報告します::

	- nr_periods
	- nr_throttled
	- スロットル
	- nr_bursts
	- バースト秒数

  cpu.weight
	非ルートのcgroups に存在する読み書き可能な単一の値ファイル。 デフォルトは "100 "です。

	非アイドルグループ(cpu.idle = 0)の場合、ウェイトは	の範囲 [1, 10000] になります。

	cグループがSCHED_IDLE（cpu.idle = 1）に設定されている場合、ウェイトは0と表示されます、
	
  cpu.weight.nice
	非ルートのcgroups に存在する読み書き可能な単一の値ファイル。 デフォルトは "0" です。

	nice 値は [-20, 19] の範囲である。

	このインターフェイスファイルは"cpu.weight" の代替インターフェイスであり、 nice(2) で使用されるのと同じ値を使って
	nice(2) で使用されるのと同じ値を使用して、 重みの読み込みと設定を可能にする。 範囲が小さく
	粒度は nice の値の方が粗いので、読み込まれる値はが現在の重みに最も近い近似値となります。

  cpu.max
	非 root cgroup に存在する読み書き可能な 2 つの値ファイル。
	デフォルトは "max 100000"。

	帯域幅の上限。 以下の形式::

	  $MAX $PERIOD

	という形式である。MAXの "max "は、制限がないことを示す。 もしが1つだけ書かれた場合、$MAXは更新される。

  cpu.max.burst
	非ルートに存在する読み書き可能な単一値ファイル。デフォルトは "0" です。

	範囲 [0, $MAX] のバースト。

  cpu.pressure
	読み書き可能なネストされたキーファイル。

	CPUの圧力ストール情報を示す。参照
	詳細は :を参照してください。

  cpu.uclamp.min
	非 root cgroup に存在する読み書き可能な単一値ファイル。
	デフォルトは "0"、つまり利用率のブーストはありません。

	要求された最小利用率（保護）をパーセンテージで指定します。
	有理数、例えば 12.34% の場合は 12.34。

	このインターフェイスでは、sched_setattと同様に、最小利用率クランプ値
	sched_setattr(2) と同様です。この最小利用率
	値は、タスク固有の最小利用率クランプに使用されます。

	要求された最小利用率（プロテクション）は、常に、最大利用率（プロテクション）の現在値である
	最大利用率 (制限) の現在の値、すなわち
	すなわち `cpu.uclamp.max` である。

  cpu.uclamp.max
	非ルートcグループに存在する読み書き可能な単一値ファイル。
	デフォルトは "max "である。

	要求された最大利用率（制限）をパーセンテージの合理的な、例えば、98.76% の場合は 98.76。

	このインターフェースは、sched_setattと同様に、最大利用率クランプ値の読み取りと設定を可能にする。
	sched_setattr(2) と同様の値の読み込みと設定が可能です。この最大利用率値は、タスク固有の最大利用率クランプに使用される。

　　cpu.idle
	非 root cgroup に存在する読み書き可能な単一値ファイル。デフォルトは 0 である。

	これは、タスクごとの スケジューポリシーの cgroup アナログである。

メモリ
-----

メモリコントローラーは、メモリの分配を調整する。 メモリは
ステートフルであり、制限モデルと保護モデルの両方を実装している。 そのため
メモリ使用量と再生圧力の間の絡み合いと、メモリのステートフルな性質のため
メモリのステートフルな性質により、分配モデルは比較的複雑である。

完全に防水というわけではないが、与えられた
cgroupによる主要なメモリ使用はすべて追跡される。
説明され、合理的な範囲で制御される。 現在
現在、以下の種類のメモリ使用量が追跡されている。

- ユーザーランドメモリ - ページキャッシュと匿名メモリ。

- デントリやinodeなどのカーネルデータ構造。

- TCPソケット・バッファ。

上記のリストは、より良いカバレッジのために将来拡張される可能性がある。

メモリーインターフェースファイル
~~~~~~~~~~~~~~~~~~~~~~

メモリ量はすべてバイト単位である。 PAGE_SIZEにアライメントされていない値が書き込まれた場合
PAGE_SIZEに整列されていない値が書き込まれた場合、その値は最も近いPAGE_SIZEの倍数に切り上げられることがある。
に最も近いPAGE_SIZE倍数に切り上げられるかもしれない。

  memory.current
	非ルートの
	cgroups に存在する読み取り専用の単一値ファイル。

	cgroup およびその子孫で現在使用されているメモリの合計量。
	およびその子孫によって現在使用されているメモリの合計量です。

  memory.min
	非ルートの
	cgroups に存在する読み書き可能な単一値ファイルです。 デフォルトは "0" です。

	ハードメモリ保護。 cgroup のメモリ使用量が
	のメモリ使用量が有効な最小境界内にある場合、cgroup のメモリ
	が再要求されることはありません。もし
	保護されていない再生可能メモリがない場合、OOM キラー
	が呼び出される。有効最小境界より上（または
	を超えると、超過分に比例してページが再生される。
	オーバーエイジに比例して再生される。
	より小さなオーバーエイジに対しては、リクレイム圧力が減少する。
	有効な最小値の境界は、すべての先祖 cgroup の memory.min 値によって制限される。
	値によって制限されます。memory.min のオーバーコミットがある場合
	がある場合 (子 cgroup または cgroup が、親が許可するよりも多くの保護メモリ
	親が許可するよりも多くの保護メモリを必要とする)、各子 cgroup は
	親の保護に比例する部分を取得します。
	を下回る実際のメモリ使用量に比例する親の保護部分を取得します。

	この
	この保護下に一般的に使用可能なメモリ以上のメモリを置くことは推奨されず、常に OOM につながる可能性があります。

	メモリ cgroup にプロセスが投入されていない場合、 memory.min は無視される、
	その memory.min は無視される。

  memory.low
	root 以外の cgroup に存在する読み書き可能な単一値ファイル。
	ファイル。 デフォルトは "0" です。

	ベストエフォート型のメモリ保護。 cgroup のメモリ使用量が
	cgroup のメモリ使用量が有効な低バウンダリ内にある場合、cgroup の
	メモリは再要求されません。
	ない限り、cgroup のメモリは再要求されません。
	実効低バウンダリ（または 
	を超えると、超過分に比例してページが再要求されます。
	オーバーエイジに比例して再要求され、オーバーエイジが小さいほど再要求の圧力が減ります。
	より小さいオーバーエイジでは、リクレイム圧力が減少する。

        効果的な低さの境界は、すべての先祖のcグループのmemory.low値によって制限される。
	値によって制限されます。memory.low のオーバーコミットがある場合
	(がある場合（子 cgroup または cgroup が親の許容量よりも多くの保護メモリ
	親が許可するよりも多くの保護メモリを必要とする)、各子 cgroup は
	親の保護に比例する部分を取得します。
	を下回る実際のメモリ使用量に比例する親の保護の一部を取得します。

	一般的に使用可能なメモリよりも多くのメモリをこの
	以上のメモリをこの保護下に置くことは推奨されません。

  memory.high
	非ルートグループに存在する読み書き可能な単一値ファイル。
	cグループに存在する読み書き可能な単一値ファイル。 デフォルトは "max"。

	メモリ使用量のスロットル制限。 cgroup の使用量が
	を超えると、その cgroup のプロセスはスロットルされ
	のプロセスはスロットルされ、大きな再生プレッシャーにさらされます。

	高リミットを超えても OOM キラーは発動しません。
	極端な条件下では制限を突破することもあります。ハイ
	リミットは、外部プロセスが制限された cgroup を監視するシナリオで使用する必要があります。
	が制限された cgroup を監視し、大きな再生圧力を緩和する場合に使用される。
	圧力を緩和するために、外部プロセスが制限された

  memory.max
	非ルートグループに存在する読み書き可能な単一値ファイル。
	cグループに存在する読み書き可能な単一値ファイル。 デフォルトは "max"。

	メモリ使用量のハードリミット。 これは
	cgroup のメモリ使用量を制限する主なメカニズムです。 cgroup のメモリ使用量が
	に達すると、OOM キラーが起動します。
	が起動されます。特定の状況下では、使用量が
	を一時的に超えることがあります。

	デフォルトの設定では、OOM killer が現在のメモリを選択しない限り、 通常の 0-order のアロケーションは常に成功する。
	OOMキラーが現在のタスクを犠牲者に選ばない限り成功する。

	いくつかの種類の割り当てでは、OOMキラーが起動されない。
	呼び出し元は、別の方法で再試行したり、-ENOMEMとしてユーザー空間に戻ったり、あるいは黙ってOOMキラーを呼び出したりすることができる。
	に戻したり、ディスクのリードアヘッドのような場合には無視したりすることができる。

  memory.reclaim
	すべての cgroup に存在する書き込み専用のネストされたキー付きファイル。

	のメモリ再要求をトリガーするシンプルなインターフェイスです。
	をトリガする簡単なインターフェイスです。

	このファイルは、再要求するバイト数である 1 つのキーを受け入れます。
	現在のところ、ネストされたキーはサポートされていません。

	例::

	  echo "1G" > memory.reclaim

	このインターフェイスは、後でネストしたキーで拡張することができる。
	リクレイムの動作を設定する。例えば
	を指定する。

	カーネルはターゲットcgroupからの再要求をオーバーまたはアンダーできることに注意してください。
	から過剰または過小にリクレイムできることに注意してください。リクレイムされたバイト数が指定した量より少ない場合
	指定された量より少ない場合は、-EAGAIN が返される。

  memory.reclaim
	（このインターフェイスによってトリガーされる）プロアクティブ・リクレイムは
	メモリの圧力を示すものではないことに注意すること。そのため
	によってトリガーされるソケットメモリバランシングは、この場合通常実行されない。
	つまり、ネットワーキング層は
	つまり、ネットワーク層は memory.reclaim によって引き起こされる

  memory.peak
	非 root のcgroups に存在する読み取り専用の単一値ファイルです。

	その cgroup とその子孫で記録された最大メモリ使用量。
	の子孫に記録された最大メモリ使用量。

  memory.oom.group
	非ルートの cgroup に存在する読み書き可能な単一値ファイル。
	cgroups に存在する読み書き可能な単一値ファイル。 デフォルト値は「0」です。

	cgroup を次のように分割できないワークロードとして扱うかどうかを決定します。
	cgroup を OOM キラーによって分割不可能なワークロードとして扱うかどうかを決定します。設定すると
	設定されている場合は、cgroup またはその子孫に属するすべてのタスク
	(メモリー cgroup がリーフ cgroup でない場合) に属するすべてのタスクは、一緒に kill されるか、まったく kill されない。
	される。これは
	ワークロードの整合性を保証するために、部分的な強制終了を避けるために使用できる。

	OOM 保護（oom_score_adj を -1000 に設定）を持つタスクは例外として扱われ、決して強制終了されない。
	を持つタスクは例外として扱われ、決して強制終了されない。

        OOMキラーがあるcgroupで起動された場合、そのcgroupの外のタスクを殺すことはない。
	に関係なく、この cgroup の外のタスクを kill しない。
	memory.oom.group 値に関係なく、この cgroup の外のタスクを kill しない。

  memory.events
	非ルート cgroup に存在する読み取り専用のフラットキーファイル。
	以下のエントリが定義されています。 以下のエントリが定義されています。
	このファイルの値が変更されると、ファイル
	変更イベントを生成する。

	このファイルのすべてのフィールドは階層化されており
	イベントによって生成される可能性があることに注意してください。
	イベントが発生する可能性がある。cgroupレベルのローカル・イベントについては
	を参照してください。

	  min
		cgroup の使用率が低いにもかかわらず、メモリ圧が高いために再要求された回数。
		メモリ使用量が
		を下回っているにもかかわらず、メモリ圧力が高いために再要求された回数。 これは通常
		境界がオーバーコミットされていることを示す。
	  high
		cgroup のプロセスが、直接メモリ再要求を実行するためにスロットルされ、ルーティングされる回数。
		スロットルされ、直接メモリ再要求を実行するようにルーティングされた回数。
		された回数。 メモリ使用量が
		メモリ使用量の上限がグローバルメモリ圧力ではなく
		によって上限が設定されている cgroup では、このイベント
		の発生が予想されます。

	  max
		cgroup のメモリ使用量が最大値を超えそうになった回数。
		を超えた回数。 直接リクレイム
		が失敗すると、cgroup は OOM 状態になります。

	  OOM
		cgroup のメモリ使用量が上限に達し、割り当てが行われようとした回数。
		限界に達し、割り当てが失敗しそうになった回数。

		OOM キラーがオプションとして考慮されない場合、このイベントは発生しません。
		がオプションとして考慮されていない場合、このイベントは発生しない。
		このイベントは発生しない。

	  oom_kill
		この cgroup に属するプロセスの数。
		に属するプロセスの数。

          oom_group_kill
                グループ OOM が発生した回数。

  memory.events.local
	memory.eventsに似ているが、ファイル内のフィールドはcgroupのローカルなものである。
	つまり階層的ではありません。ファイル変更イベント
	はローカルイベントのみを反映します。

  memory.stat
	非 root cgroup に存在する読み取り専用のフラットキーファイル。

	これは、cgroup のメモリフットプリントをさまざまなメモリタイプに分解します。
	メモリのタイプ、タイプ固有の詳細、およびその他の情報に分解されます。
	メモリ管理システムの状態や過去のイベントに関するその他の情報を提供します。

	メモリ量はすべてバイト単位です。

	エントリは人間が読めるように順番に並んでおり、新しいエントリ
	が現れることもある。項目が一定の位置にあることを当てにしないでください。
	特定の値を調べるにはキーを使用する！

	エントリーにノードごとのカウンターがない場合（または
	memory.numa_stat)。タグとして'npn'(non-per-node)を使用します。
	を使用して、memory.numa_statに表示されないことを示します。

	  anon
		のような匿名マッピングで使用されるメモリ量。
		brk()、sbrk()、mmap(MAP_ANONYMOUS) などの匿名マッピングで使用されるメモリ量。

	  file
		ファイルシステムのデータをキャッシュするために使用されるメモリ量、
		tmpfs や共有メモリを含む。

	  kernel（npn）
		カーネルの総メモリ量。
		(kernel_stack、pagetables、percpu、vmalloc、slab）。
		その他のカーネルメモリの使用例も含む。

	  kernel_stack
		カーネルスタックに割り当てられたメモリ量。

	  pagetables
                ページ・テーブルに割り当てられたメモリー量。

	  sec_pagetables
		セカンダリページテーブルに割り当てられたメモリ量、
		これは現在、x86およびarm64のKVM mmu割り当てを含む。
		およびarm64でのKVM mmu割り当てが含まれます。

	  percpu (npn)
		CPUごとのカーネルデータ構造を格納するために使用されるメモリ量。
		データ構造。

	  sock (npn)
		ネットワーク転送バッファで使用されるメモリ量。

	  vmalloc (npn)
		vmap バックアップメモリに使用されるメモリ量。

	  shmem
		スワップバックされるキャッシュファイルシステムデータの量、
		tmpfs、shm セグメント、共有匿名 mmap()s など。

	  zswap
		zswap 圧縮バックエンドが消費するメモリ量。

	  zswapped
		zswap にスワップアウトされたアプリケーションメモリの量。

	  file_mapped
		mmap() でマップされたファイルシステムのキャッシュ・データ量。

	  file_dirty
		変更されたがまだディスクに書き戻されていない、キャッシュされたファイルシステムのデータ量。
		ディスクに書き戻されていない

	  file_writeback
		キャッシュされたファイルシステムのデータのうち、変更され
		現在ディスクに書き戻されている

	  swapcached
		メモリにキャッシュされているスワップ量。スワップキャッシュは
		メモリとスワップ使用量の両方に対して計算される。

	  anon_thp
		による匿名マッピングで使用されるメモリ量。
		透過的なヒュッゲページ

	  file_thp
		トランスペアレントなハゲページ

	  shmem_thp
		shm、tmpfs、共有匿名 mmap() の量。
		透過的なヒュッゲページ

	  inactive_anon、active_anon、inactive_file、active_file、unevictable
		スワップバックアップメモリとファイルシステムバックアップメモリの量、
		スワップバックアップメモリとファイルシステムバックアップメモリの量。
		ページ再生アルゴリズムが使用する内部メモリ管理リストのスワップバックアップメモリとファイルシステムバックアップメモリの量。

		これらは内部リストの状態を表すので（例えば、shmemページはanon
		メモリ管理リスト上にある)、inactive_foo + active_foo は
		fooカウンターは型ベースであり、リストベースではないからである。
		リスト・ベースではないからだ。

	  shmem_thp
		スラブ "の一部で再生可能なもの。
		デントリやinodeなど。

	  slab_unreclaimable
		スラブ "の一部。
		圧力。

	  slab (npn)
		カーネル内データ構造の格納に使用されるメモリ量。
		構造体を格納するために使用されるメモリ量。

	  workingset_refault_anon
		以前に退避された匿名ページのリフォールト数。

	  workingset_refault_file
		以前に退避されたファイルページのリフォールト数。

	  workingset_activate_anon
		すぐにアクティブ化されたリフォールトされた匿名ページの数。
		の数。

	  workingset_activate_file
		即座にアクティブにされたリフォールトされたファイルページの数。

	  workingset_restore_匿名
		として検出された、復元された匿名ページの数。
		復元された匿名ページの数。

	  workingset_restore_file
		として検出された、リストアされたファイルページの数。
		として検出されたリストアされたファイルページの数。

	  workingset_nodereclaim
		シャドウ・ノードが再要求された回数。

	  pgscan (npn)
		(非アクティブなLRUリストで)スキャンされたページの量。

	  pgsteal (npn)
		再要求されたページの量。

	  pgscan_kswapd (npn)
		kswapd がスキャンしたページの量 (無効な LRU リスト内)

	  pgscan_direct (npn)
		直接スキャンされたページの量 (無効な LRU リスト内)

	  pgscan_khugepaged (npn)
		khugepagedによってスキャンされたページの量 (無効なLRUリスト内)

	  pgsteal_kswapd (npn)
		kswapdによる再生ページ量。

	  pgsteal_direct (npn)
		直接再生されたページの量。

	  pgsteal_khugepaged (npn)
		khugepagedによって取り戻されたページの量。

	  pgfault (npn)
		発生したページフォルトの総数

	  pgmajfault (npn)
		発生したメジャーページフォルトの数

	  pgrefill (npn)
		(アクティブな LRU リスト内の) スキャンされたページの量。

	  pgactivate (npn)
		アクティブなLRUリストに移動したページの量

	  pgdeactivate (npn)
		非活性 LRU リストに移動したページ量。

	  pglazyfree (npn)
		メモリ不足のために解放が延期されたページの量。

	  pglazyfreed (npn)
		再生された遅延フリーページの量。

	  thp_fault_alloc (npn)
		ページフォールトを満たすために割り当てられた透過的なヒュッゲページの数。
		の数。このカウンタは CONFIG_TRANSPARENT_HUGEPAGE
                が設定されていない場合は存在しない。

	  thp_collapse_alloc (npn)
		既存のページ範囲を折りたたむために割り当てられた透過ヒュッゲページの数。
		既存のページ範囲を折りたたむために割り当てられた透明なヒュッゲページの数。このカウンタは
		CONFIG_TRANSPARENT_HUGEPAGE が設定されていないときは存在しない。

	  thp_swpout (npn)
		分割されずに一度にスワップアウトされる透過ヒュッゲページの数。
		分割せずに一度にスワップアウトされる透明なヒュッゲページの数。

	  thp_swpout_fallback (npn)
		スワップアウトの前に分割された透過 hugepage の数。
		通常、巨大ページのための連続的なスワップ領域の確保に失敗したためである。
		が失敗したため。

  memory.numa_stat
	非 root cgroup に存在する読み取り専用のネストされたキーファイル。

	これは、cgroup のメモリフットプリントをさまざまな
	メモリのタイプ、タイプ固有の詳細、およびメモリ管理の状態に関するノードごとのその他の情報
	メモリ管理システムの状態に関するノードごとの情報です。

	これは、memcg 内の NUMA ローカリティ情報を可視化するのに便利です。
	これは、memcg 内の NUMA ローカリティ情報を可視化するのに便利です。
	これは、memcg 内の NUMA ロカリティ情報を可視化するのに便利です。ユースケースの1つは
	この情報をアプリケーションのCPU割り当てと組み合わせることで
	アプリケーションの CPU 割り当てと組み合わせて、アプリケーションのパフォーマンスを評価することです。

	メモリ量はすべてバイト単位である。

	memory.numa_stat の出力形式は次のとおりです::

	  type N0=<bytes in node 0> N1=<bytes in node 1> ...

	エントリーは人間が読めるように順番に並べられており、新しいエントリーが途中で表示されることもある。
	エントリーは人間が読みやすいように並べられている。項目が一定の位置にあることを当てにしないでください。
	キーを使って特定の値を検索する！

	エントリーはmemory.stat.currentを参照できる。

  memory.swap.current
	非ルートのcグループに存在する読み取り専用の単一値ファイル。

	cgroup およびその子孫で現在使用されているスワップの合計量。
	およびその子孫で現在使用されているスワップの合計量です。

  memory.swap.high
	非ルートのcgroups に存在する読み書き可能な単一値ファイルです。 デフォルトは "max"。

	スワップ使用スロットルリミット。 cgroup のスワップ使用量が
	を超えると、それ以降のすべての割り当てがスロットルされます。
	ユーザースペースがカスタム メモリ外プロシージャを実装できるようにします。

	このリミットは cgroup の戻れないポイントになります。これは
	スワップの量を管理するように設計されていません。
  	このリミットは、cグループにとって戻れないポイントである。これは
	ワークロードのスワップ量を管理するようには設計されていません。
	を管理するためのものではありません。memory.swap.max と比較してください。
	と比較してください。
	は、他のメモリが再利用できる限り、無制限に継続される。

	健全なワークロードがこの制限に達することはない。

  memory.swap.peak
	非ルートのcグループに存在する読み取り専用の単一値ファイルです。

	cgroupとその子孫で記録された最大スワップ使用量。
	子孫に対して記録された最大スワップ使用量。

  memory.swap.max
	非ルートの cgroup に存在する読み書き可能な単一値ファイル。
	cgroup に存在する読み書き可能な単一値ファイルです。 デフォルトは「max」です。

	スワップ使用量のハードリミット。 cgroup のスワップ使用量がこの
	に達すると、cgroup の匿名メモリはスワップアウトされません。

  memory.swap.events
	非 root cgroup に存在する読み取り専用のフラットキーファイル。
	以下のエントリが定義されています。 以下のエントリが定義されています。
	このファイルの値が変更されると、ファイル
	変更イベントを生成します。

	  high
		cgroupのスワップ使用量が高閾値を超えた回数。
		を超えた回数。

	  max
		cgroup のスワップ使用量が最大値を超えようとしていた回数。
		スワップ割り当てが失敗した回数。
		に失敗した回数。

	  fail
		スワップ割り当てが失敗した回数。
		スワップ割り当てが失敗した回数。
		制限。

	現在の使用量でスワップが削減されると、既存のスワップ・エントリは徐々に回収され、スワップ使用量は維持される。
	エントリが徐々に回収され、スワップ使用量が制限値より高い状態が長期間続くことがある。
	スワップ使用量が上限より高い状態が これにより	は作業負荷とメモリ管理への影響を軽減する。

  memory.zswap.current
	非ルートの
	cグループに存在する読み取り専用の単一値ファイル。

	zswap圧縮バックエンドが消費するメモリの合計量。
	バックエンドによって消費されるメモリの総量。

  memory.zswap.max
	非ルートcグループに存在する読み書き可能な単一値ファイル。
	cgroupsに存在する読み書き可能な単一値ファイルです。 デフォルトは "max"。

	Zswap 使用のハードリミット。cgroup の zswap プールがこの制限に達すると
	に達すると、既存のエントリがフォールトバックされるか書き出される前に
	エントリがディスクに書き戻されるか書き出される前に、それ以上の保存を拒否します。

  memory.zswap.writeback
	読み書き可能な単一値ファイル。デフォルト値は「1」である。ルートcグループの初期値は
	ルート cgroup の初期値は 1 で、新しい cgroup が作成されると、親の現在の値を継承します。
	が作成されると、親の現在の値を継承する。

	この値を 0 に設定すると、スワッピングデバイスへのすべてのスワッピング試行
	へのスワッピングの試みはすべて無効になる。これには、zswapライトバックと、zswapストア失敗によるスワッピングの両方が含まれる。
	zswapストア失敗によるスワップも含まれる。zswapストアの失敗が繰り返される場合
	(ページが非圧縮性である場合など）。
	同じページが何度も拒否される可能性があるため）。

	これは、memory.swap.maxを
	0に設定するのとは微妙に異なることに注意してください。

  memory.pressure
	読み取り専用のネストされたキー・ファイル。

	メモリの圧力ストール情報を示す。参照
	詳細は :ref:`Documentation/accounting/psi.rst <psi>` を参照。

利用ガイドライン
~~~~~~~~~~~~~~~~

"memory.high "はメモリ使用量を制御する主なメカニズムである。
高リミットでのオーバーコミット（高リミットの合計＞利用可能メモリ）
を過剰にコミットし、グローバル・メモリー・プレッシャーに任せて使用量に応じてメモリーを分配するのは、有効な戦略です。
が有効な戦略である。

なぜなら、ハイリミットの違反は OOM キラーをトリガーせず、違反した cgroup をスロットルするからである。
管理エージェントには、次のような適切なアクションを取る十分な機会がある。
を監視し、適切なアクションを取る機会が十分にある。
メモリ増設やワークロードの終了など、適切なアクションを取ることができます。

cgroupに十分なメモリがあるかどうかを判断するのは簡単ではありません。
メモリ使用量は、ワークロードがより多くのメモリから利益を得られるかどうかを示さないからです。
とは限らないからである。 例えば、ネットワークから受信したデータをファイルに書き込むワークロードは、利用可能な メモリをすべて使用する可能性がある。
ネットワークから受信したデータをファイルに書き込むワークロードは、利用可能なメモリをすべて使用する可能性がありますが、少量のメモリで高いパフォーマンスを発揮することもできます。
として動作することもある。 メモリ
メモリ不足のために作業負荷がどの程度影響を受けているかを示すメモリ圧力の測定は、メモリが不足しているかどうかを判断するために必要です。
作業負荷がより多くのメモリを必要とするかどうかを判断するには、メモリ圧の測定が必要である。
残念ながら、メモリ不足監視メカニズムはまだ実装されていない。
残念ながら、メモリプレッシャー監視メカニズムはまだ実装されていない。

メモリの所有権
~~~~~~~~~~~~~~~~

メモリ領域は、それをインスタンス化した cgroup にチャージされ、領域が解放されるまで cgroup にチャージされたままになります。
にチャージされたままです。 プロセスを別の
プロセスを別の cgroup に移行しても、そのプロセスが前の cgroup にいる間にインスタンス化したメモリ使用量は移動しない。
を新しい cgroup に移動することはありません。

メモリ領域は、異なる cgroup に属するプロセスによって使用されることがあります。
しかし、その領域がどの cgroup にチャージされるかは不確定です、
メモリ領域がどの cgroup にチャージされるかは決定不可能である。
メモリ領域は、高いリクレイム圧力を回避するのに十分なメモリ許容量を持つcgroupに行き着く可能性が高い。

cgroup が、他の cgroup によって繰り返しアクセスされることが予想される、かなりの量のメモリをスイープする場合
他の cgroup によって繰り返しアクセスされることが予想される、かなりの量のメモリをスイープする場合は
POSIX_FADV_DONTNEED を使用して、 影響を受けるファイルに属するメモリ領域の所有権を放棄する。
を使用して、影響を受けるファイルに属するメモリ領域の所有権を放棄する。
