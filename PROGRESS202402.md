[Conformant OpenGL 4.6 on the M1](https://asahilinux.org/2024/02/conformant-gl46-on-the-m1/)の非公式日本語訳です。

訳注: 本家ブログへのリンクは対応する日本語訳へのリンクに変更

---
# M1 が OpenGL 4.6 に準拠

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202401.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202406.md)

何年もの間、M1 は OpenGL 4.1 にしか対応していませんでした。今日変わります。OpenGL® 4.6とOpenGL® ES 3.2のリリースです！
最新の M1/M2 シリーズ・ドライバーのために[Fedoraをインストール](https://fedora-asahi-remix.org/)してください。

すでにインストール済みですか？`dnf upgrade --refresh` してください。

ベンダーの不準拠な 4.1 ドライバとは異なり、私たちの[オープンソース](https://gitlab.freedesktop.org/asahi/mesa) Linux ドライバは、最新の OpenGL バージョンに
**準拠** しており、最終的には [Blender](https://www.blender.org/) のような最新の OpenGL ワークロードとの幅広い互換性を約束します。

![Fedora Linux 39上のApple M1で動作するBlenderのスクリーンショット。シーンは『Wanderer』で、宇宙服を着たヒューマノイドが、ソーラーパネルを搭載したローバーのそばの岩だらけの地形にいる様子を描いています](https://asahilinux.org/img/blog/2024/02/Blender-Wanderer-high.avif)

4.6/3.2 に準拠するドライバは、正確性を保証するために100,000以上のテストに合格しなければなりません。現在、公式の準拠ドライバのリストには、私たちの
[OpenGL 4.6](https://www.khronos.org/conformance/adopters/conformant-products/opengl#submission_347) と [ES 3.2](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1045) が含まれています。

ベンダーはまだ最新の OpenGL のようなグラフィックス標準に対応していませんが、私たちは対応しています。このバレンタインデーに、相互運用可能なオープン標準への愛を公言
したいです。ユーザーと開発者をロックインから解放し、アプリケーションが特別なポートなしで、心が望む場所で実行できるようにしたいと考えています。
そのためには、標準への準拠が必要です。6ヶ月前、私たちはOpenGL ES 3.1ドライバを公開し、[M1用のあらゆる標準グラフィックス API に準拠した最初のドライバ](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202308.md)となりました。今日、OpenGL を完全な 4.6 に仕上げ...そして Vulkan への道を順調に進んでいます。

---

4.1 と比較して、OpenGL 4.6 には以下を含む数十の必要な機能が追加されています。

- 堅牢性(robustness)
- SPIR-V
- [クリップ制御](https://rosenzweig.io/blog/asahi-gpu-part-6.html)(訳注:リンクがおかしいので正しいリンクにしたつもり)
- カリング距離(Cull Distance) (訳注: [カリングの解説](https://gamemakers.jp/article/2024_10_04_77250/)、[距離でのカリング](https://miyahuji111.hatenablog.com/entry/2017/07/24/202630)
- [コンピュート・シェーダ](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202308.md)
- アップグレードされたトランスフォーム・フィードバック

残念なことに、M1 は OpenGL ES 3.1 より新しいグラフィックス標準にはうまくマッピングできません。Vulkan はこれらの機能のいくつかをオプションにしていますが、
欠けている機能は DirectX と OpenGL を載せるために必要です。M1 の既存のソリューションでは、OpenGL 4.1の機能セットを乗り越えるものはありません。

どうやって 4.1 の壁を破りましょうか? ハードウェア対応がなければ、新しい機能には新しいトリックが必要です。ジオメトリー・シェーダー、テッセレーション、
トランスフォーム・フィードバックは、コンピュート・シェーダになります。カリング距離は変換され補間された値になります。クリップ制御は頂点シェーダーのエピローグになります。
リストはまだまだ続きます。

克服した課題の一例として、**堅牢性**を見てみましょう。

ゲーム用に作られた GPU は、伝統的に安全性よりも生性能を優先します。バッファを境界外(out-of-bounds)で読み込むシェーダーのような無効なアプリケーションコードは、
未定義の動作を引き起こす可能性があります。ドライバはこれを悪用して性能を最大化します。

ウェブブラウザのようなアプリケーションにとって、このトレードオフは望ましくありません。ブラウザは信頼されていないシェーダーを扱い、安定性とセキュリティを確保する
ためにそれをサニタイズしなければなりません。悪意のあるリンクをクリックしても、ブラウザがクラッシュするようなことがあってはなりません。グラフィックス　API　は
セキュリティの障壁ではないので、ある程度のサニタイズは必要ですが、API の未定義の振る舞いを減らすことは、『深層防御(defense in depth)』を助けることができます。

『堅牢性』機能は助けになります。堅牢性がなければ、シェーダ内の境界外バッファアクセスがクラッシュする可能性があります。堅牢性があれば、アプリケーションは
定義された境界外の振る舞いを選択することができ、性能をある程度引き下げる代わりに攻撃対象が少なくできます。

最近のクロスベンダー API にはすべて堅牢性が含まれています。（偶然かもしれませんが?）多くのゲームは堅牢性に依存しています。不思議なことに、ベンダー独自の API は
バッファの堅牢性を省いています。私たちは、適合性、正確性、互換性のためにもっとうまくやらなければなりません。

まず問題を定義しましょう。堅牢性が有効になっているときに、API ごとに境界外ロードが何を返すかの定義が異なります。

- ゼロ（Direct3D、`robustBufferAccess2` 付きVulkan）
- ゼロまたはバッファ内のデータ（OpenGL、`robustBufferAccess`付きVulkan）のどちらか
- 任意の値を返すが、クラッシュしない（OpenGL ES）

OpenGL は2番目の定義を使用します：ゼロまたはバッファからデータを返します。1つのアプローチは、境界外アクセスのためにバッファの*最後*の要素を返すことです。
バッファサイズが与えられれば、最後のインデックスを計算できます。ここで、アクセスされているインデックスと最後のインデックスの*最小値*を考えます。これは、
アクセスされているインデックスが有効であればそれに等しく、そうでなければ他の有効なインデックスに等しくなります。最小のインデックスをロードすることは
安全であり、仕様に準拠した結果が得られます。

例として、堅牢性を排除したユニフォームバッファ(uniform buffer)ロードは以下のようになります。

```
load.i32 result, buffer, index
```

堅牢性は、1つの符号なし最小命令（`umin`）を追加します。

```
umin idx, index, last
load.i32 result, buffer, idx
```

堅牢性版の方が遅いですか？遅くなるでしょう。算術演算はメモリよりも高速なので、その差はパーセンテージで見れば小さいはずです。何千ものスレッドが並列に実行されている場合、
演算コストはロードのレイテンシによって隠されることさえあります。

堅牢なユニフォームバッファを高速化する別のトリックがあります。他の GPU と同様、M1 は『プリアンブル(preambles)』に対応しています。考え方は簡単で、すべてのスレッドで同じ値を計算する代わりに
一度計算して結果を再利用した方が高速になります。コンパイラは適格な計算を識別し、メインシェーダの前に実行されるプリアンブルに移動させます。このような冗長性はよくあることなので、
プリアンブルはすばらしいスピードアップをもたらします。

すべてのスレッドが同じインデックスをロードする場合、通常、単一バッファロードをプリアンブルに移動します。ユニフォームバッファのサイズは固定なので、余分な堅牢性演算もプリアンブルに
移動します。堅牢性はメインシェーダにとって『フリー』です。堅牢ストレージバッファの場合、ロードやストアができなくても、
クランピング(訳注:[データを最大値と最小値間に押さえる](https://en.wikipedia.org/wiki/Clamping_(graphics)))がプリアンブルに移動する可能性があります。

堅牢な単一バッファとストレージバッファで武装して、堅牢な『頂点バッファ』を考えてみましょう。グラフィックス APIでは、アプリケーションはBase GPU アドレスと、
各バッファ内の『属性(Attributes)』の選択されたレイアウトを持つ頂点バッファを設定することができます。各属性にはOffsetとフォーマットがあり、バッファには頂点(Vertex)ごとの
バイト数を示す『Stride』があります。頂点シェーダは、頂点による暗黙のインデックスで属性を読み込むことができます。そのために、シェーダはアドレスをロードします。

$$ Base + Stride(Vertex) + Offset $$

堅牢な頂点フェッチをネイティブに実装しているハードウェアもあります。また、堅牢なソフトウェア頂点フェッチを高速化するために、境界チェックされたバッファを持つ
ハードウェアもあります。残念ながら、M1 はどちらもありません。生のメモリロードで頂点フェッチを実装する必要があります。

ある命令セット機能が役に立ちます。M1 GPU のメモリロードは、64ビットのベース・アドレスに加えて、`要素`のオフセットも取ります。ハードウェアはオフセットをシフトし、
64ビットのベースアドレスに加算して、フェッチするアドレスを決定します。さらにM1には、整数乗加算命令`imad`があります。これらの機能を組み合わせることで、
頂点ロードを2命令で実装できます。例えば、32ビット属性ロードは次のようになります。

```
imad idx, stride/4, vertex, offset/4
load.i32 result, base, idx
```

ハードウェアロードは、さらに小さなシフトを実行できます。属性が4つの32ビット値のベクトルで、Offsetなしでバッファに密集しているとします。この属性を1命令でロードすることができます。

```
load.v4i32 result, base, vertex << 2
```

...ハードウェアがアドレスを計算します。

$$ Base + 4(Vertex << 2)= Base + 16(Vertex) $$

堅牢性についてはどうでしょうか?

ユニフォームバッファで行ったように、クランピングで堅牢性を実装したいです。問題は、最適化されたロードが『頂点』のインデックスを取るのに対し、頂点バッファのサイズが
バイト単位で与えられることです。1つの頂点バッファには、フォーマットやOffsetが異なる複数の属性が含まれる可能性があるため、バイト単位のサイズを『頂点』単位の
サイズに変換することはできません。

後者の問題を処理しましょう。アドレス指定方程式を次のように書き直すことができます。

$$ \underbrace{\mbox{Base + Offset}_{\mbox{Attribute base}}} + Stride(Vertex) $$ 

つまり、異なるOffsetで多くの属性を持つ1つのバッファは、1つの属性でOffsetなしの多くのバッファと等価です。これは、同じデータレイアウトに別の視点を与えます。
これは改善になるでしょうか?アドレスは 64 ビットですが、属性のOffsetは [16 ビット](https://vulkan.gpuinfo.org/listreports.php?limit=maxVertexInputAttributeOffset&value=4294967295&platform=all0)です。より重要なのは、バイト単位の頂点バッファサイズを、各頂点属性の
『頂点』単位のサイズに変換できることです。Offsetをクランピングする代わりに、頂点インデックスをクランピングします。ハードウェアアドレッシングモードをフルに活用し、
堅牢性を高めています：

```
umin idx, vertex, last valid
load.v4i32 result, base, idx << 2
```

各属性について、最後に有効な頂点インデックスを前もって計算する必要があります。各属性には、特定のサイズを持つフォーマット(Fmt)があります。アドレッシング方程式を
操作することで、Baseに対してバッファにアクセスされた最後のバイト（プラス1）を計算することができます。

$$ Offset + Stride(Vertex) + Fmt $$

この値がバイト単位のバッファサイズに境界をつけられているとき、ロードは有効です。整数不等式を次のように解きます。

$$ Vertex \leq \lfloor \frac{Size - Offset - Fmt}{Stride} \rfloor $$

ドライバは右辺を計算しシェーダに渡します。

最後の問題です。バッファが小さすぎて*何も*ロードできない場合はどうしましょう?クランピングしても救われません。コードは負のインデックスにクランピングすることになります。
この場合、属性はまったく無効なので、アプリケーションのバッファをゼロの小さなバッファと交換します。それぞれの属性にBaseアドレスを与えたので、この判定は
属性ごとに行われます。そして、インデックスをゼロにくらんっピングすると、正しくゼロがロードされます。

これをまとめると、わずかなドライバの計算により、1つの`umin`命令のコストで堅牢なバッファを得ることができます。

---

バッファの堅牢性に加えて、画像の堅牢性も必要です。バッファの堅牢性と同様に、画像の堅牢性も、境界外の画像ロードがゼロを返すことを必要とします。これは、
合理的なハードウェアがすでに行っている保証を公式化したものです。

...しかし、私たちのハードウェアが合理的であるのは面白くないです。

画像の堅牢性に関する適合性テストを実行すると、『ミップマップ(mipmapping、(訳注: [解説](https://ja.wikipedia.org/wiki/%E3%83%9F%E3%83%83%E3%83%97%E3%83%9E%E3%83%83%E3%83%97)』に影響するテスト失敗が1つあります。

背景として、ミップマップされた画像は複数の『詳細レベル』を含んでいます。基本レベルはオリジナル画像で、各レベルは前のレベルをダウンスケールしたものです。
レンダリングの際、ハードウェアは画面上のサイズに最も近いレベルを選択することで、効率とビジュアル品質を向上させます。

堅牢性について、仕様では画像ロードが戻ることに同意していています。

- X座標またはY座標が境界外の場合はゼロ
- レベルが範囲外の場合はゼロ

一方、M1 GPU の画像ロードは...

- X座標またはY座標が境界外の場合はゼロ
- レベルが境界外の場合は最後のレベルの値

うーん。境界外のレベルに対してゼロを返すのではなく、ハードウェアがレベルをクランピングしてゼロ以外の値を返すのです。理由は謎です。このベンダーはハードウェアの
文書を公開していないため、リバースエンジニアリングに頼ってドライバーを作らざるを得ません。文書がなければ、この動作が意図的なものなのかハードウェアのバグ
なのかもわかりません。いずれにせよ、適合性テストに合格するためには回避策が必要です。

明らかな回避策は、無効なレベルから決してロードしないことです。

```
if (level <= levels) {
    return imageLoad(x, y, level)；
if (level <= levels) { return imageLoad(x, y, level); } else {
    return 0；
}
```

これは分岐を伴うので非効率的です。境界外のレベルをロードしてもクラッシュしないので、投機的にロードすることが可能で、分岐の代わりに比較と選択の操作を使用します。

```
vec4 data = imageLoad(x, y, level)；

return (level <= levels) ? data ： 0;
```

この回避策は問題ありませんが、改善できるでしょう。M1 GPU は比較と洗濯を組み合わせた命令を持っていますが、命令セットは*スカラ*です。各スレッドは一度に1つの値を処理し、
複数の値のベクトルは処理しません。しかし、画像ロードは4つの成分（赤、緑、青、アルファ）のベクトルを返します。擬似コードは効率的に見えますが、結果のアセンブリはそうではありません。

```
image_load R, x, y, level
ulesel R[0], level, levels, R[0], 0
ulesel R[1], level, levels, R[1], 0
ulesel R[2], level, levels, R[2], 0
ulesel R[3], level, levels, R[3], 0
```

幸いなことに、ベンダードライバにはトリックがあります。XかYのどちらかが境界外の場合、ハードウェアはゼロを返すことが分かっているので、XかYを境界外に*設定*することで、
強制的にゼロを出力させることができます。最大画像サイズは幅16384ピクセルなので、16384より大きいXはすべて境界外となります。そのため、別の回避策が正当化されます。

```
bool valid = (level <= levels)；
int x_ = valid ? x : 20000；

return imageLoad(x_, y, level)；
```

なぜこの方が良いのでしょうか?ベクトル全体を変更するのではなく、単一のスカラーを変更するだけなので、コンパクトなスカラ・アセンブリにコンパイルできます。

```
ulesel x_, level, levels, x, #20000
image_load R, x_, y, level
```

定数をユニフォーム・レジスタにプリロードすれば、回避策は1命令で済みます。これは最適です。また、適合性テストに合格します。


[Daniel Bystedt氏](https://www.artstation.com/dbystedt)による Blender 『[Wanderer](https://download.blender.org/demo/eevee/wanderer/wanderer.blend)』デモ は CC BY-SA でライセンスされます。

#### Alyssa Rosenzweig - 2024-02-14
