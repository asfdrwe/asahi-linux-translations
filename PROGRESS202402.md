[Conformant OpenGL 4.6 on the M1](https://asahilinux.org/2024/02/conformant-gl46-on-the-m1/)の非公式日本語訳です。

訳注: DeepLの結果を貼っただけ(2024/10/19)

---
# M1 が OpenGL 4.6 に準拠

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202401.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202406.md)

何年もの間、M1はOpenGL 4.1しかサポートしていませんでした。それが今日、OpenGL® 4.6とOpenGL® ES 3.2のリリースによって変わりました！最新のM1/M2シリーズ・ドライバーのためにFedoraをインストールしてください。

すでにインストール済みですか？dnf upgrade --refresh するだけです。

ベンダーの不適合な4.1ドライバとは異なり、私たちのオープンソースLinuxドライバは、最新のOpenGLバージョンに適合しており、Blenderのような最新のOpenGLワークロードとの幅広い互換性を最終的に約束します。

![Fedora Linux 39上のApple M1で動作するBlenderのスクリーンショット。シーンは'Wanderer'で、宇宙服を着たヒューマノイドが、ソーラーパネルを搭載したローバーのそばの岩だらけの地形にいる様子を描いています](https://asahilinux.org/img/blog/2024/02/Blender-Wanderer-high.avif)

適合する4.6/3.2ドライバは、正しさを保証するために100,000以上のテストに合格しなければなりません。現在、公式の適合ドライバのリストには、私たちのOpenGL 4.6とES 3.2が含まれています。

ベンダーはまだ最新のOpenGLのようなグラフィックス標準をサポートしていませんが、私たちはサポートしています。このバレンタインデーに、我々は相互運用可能なオープン・スタンダードへの愛を公言したい。私たちは、ユーザーと開発者をロックインから解放し、アプリケーションが特別なポートなしで、心が望む場所で実行できるようにしたいと考えています。そのためには、標準への準拠が必要です。半年前、私たちはOpenGL ES 3.1ドライバーをリリースし、M1用のあらゆる標準グラフィックスAPIに準拠した最初のドライバーとなりました。今日、我々はOpenGLを完全な4.6に仕上げ...そしてVulkanへの道を順調に進んでいる。

---
4.1と比較して、OpenGL 4.6には以下を含む数十の必要な機能が追加されている：

- 堅牢性
- SPIR-V
- クリップ制御
- カル・ディスタンス
- コンピュート・シェーダー
- アップグレードされたトランスフォームフィードバック

残念なことに、M1はOpenGL ES 3.1より新しいグラフィックス標準にはうまくマッピングできない。Vulkanはこれらの機能のいくつかをオプションにしているが、欠けている機能はDirectXとOpenGLを重ねるために必要だ。M1の既存のソリューションでは、OpenGL 4.1の機能セットを乗り越えるものはない。

4.1の壁を破るには？ハードウェアのサポートがなければ、新しい機能には新しいトリックが必要です。ジオメトリー・シェーダー、テッセレーション、トランスフォーム・フィードバックは、コンピュート・シェーダーになります。カル・ディスタンスは、変換された補間値になります。クリップ制御は頂点シェーダーのエピローグになる。リストはまだまだ続く。

私たちが克服した課題の一例として、堅牢性を見てみましょう。

ゲーム用に作られたGPUは、伝統的に安全性よりも生のパフォーマンスを優先します。バッファをアウトオブバウンズで読み込むシェーダーのような無効なアプリケーションコードは、未定義の動作を引き起こす可能性があります。ドライバはそれを悪用してパフォーマンスを最大化します。

ウェブブラウザーのようなアプリケーションにとって、このトレードオフは望ましくない。ブラウザは信頼されていないシェーダーを扱い、安定性とセキュリティを確保するためにそれをサニタイズしなければならない。悪意のあるリンクをクリックしても、ブラウザがクラッシュするようなことがあってはならない。グラフィックスAPIはセキュリティの障壁ではないので、ある程度のサニタイズは必要ですが、APIの未定義の振る舞いを減らすことは、「深層防御」を助けることができます。

「堅牢性」機能は助けになります。ロバスト性がなければ、シェーダ内の境界外バッファアクセスがクラッシュする可能性があります。ロバスト性があれば、アプリケーションは定義されたアウトオブバウンズの振る舞いを選択することができ、攻撃対象が少なくなる代わりにパフォーマンスをある程度引き下げることができます。

最近のクロスベンダー API にはすべてロバストネスが含まれています。多くのゲームは（偶然か）ロバストネスに依存しています。不思議なことに、ベンダー独自のAPIはバッファの堅牢性を省略している。私たちは、適合性、正しさ、互換性のためにもっとうまくやらなければならない。

まず問題を定義しよう。APIによって、ロバストネスが有効になっているときに、アウトオブバウンズロードが何を返すかの定義が異なります：

- ゼロ（Direct3D、robustBufferAccess2を持つVulkan）
- ゼロまたはバッファ内のデータ（OpenGL、robustBufferAccess付きVulkan）のいずれか。
- 任意の値を返すが、クラッシュしない（OpenGL ES）

OpenGLは2番目の定義を使用します：バッファからゼロまたはデータを返します。1つのアプローチは、境界外アクセスのためにバッファの最後の要素を返すことです。バッファサイズが与えられれば、最後のインデックスを計算できます。ここで、アクセスされているインデックスと最後のインデックスの最小値を考えます。これは、アクセスされているインデックスが有効であればそれに等しく、そうでなければ他の有効なインデックスに等しくなります。最小のインデックスをロードすることは安全であり、仕様に準拠した結果が得られます。

例として、ロバスト性を排除した一様バッファ・ロードは以下のようになる：

```
load.i32 result, buffer, index
```

ロバストネスは、1つの符号なし最小（umin）命令を追加します：

```
umin idx, index, last
load.i32 result, buffer, idx
```

ロバストバージョンの方が遅い？遅くなる。算術演算はメモリよりも高速なので、その差はパーセンテージで見れば小さいはずだ。何千ものスレッドが並列に実行されている場合、演算コストはロードのレイテンシによって隠されることさえある。

ロバストなユニフォーム・バッファを高速化する別のトリックがあります。他のGPUと同様、M1は「プリアンブル」をサポートしている。考え方は簡単で、すべてのスレッドで同じ値を計算するのではなく、一度計算して結果を再利用した方が高速になります。コンパイラーは適格な計算を識別し、メインシェーダーの前に実行されるプリアンブルに移動させます。このような冗長性はよくあることなので、プリアンブルはすばらしいスピードアップをもたらします。

通常、すべてのスレッドが同じインデックスをロードする場合、一様バッファロードをプリアンブルに移動します。一様バッファのサイズは固定なので、余分なロバストネス演算もプリアンブルに移動します。ロバストネスはメインシェーダにとって 「無料 」です。ロバストストレージバッファの場合、ロードやストアができなくても、クランピングがプリアンブルに移動する可能性があります。

ロバストなユニフォームバッファとストレージバッファで武装して、ロバスト な「頂点バッファ」を考えてみましょう。グラフィックスAPIでは、アプリケーションはベースGPUアドレスと、各バッファ内の「属性」の選択されたレイアウトを持つ頂点バッファを設定することができます。各属性にはオフセットとフォーマッ トがあり、バッファには頂点ごとのバイト数を示す「ストライド」があります。バーテックスシェーダは、頂点による暗黙のインデッ クスでアトリビュートを読み込むことができます。そのために、シェーダはアドレスをロードします：

#数式

ロバストな頂点フェッチをネイティブに実装しているハードウェアもあります。また、ロバストなソフトウェア頂点フェッチを高速化するために、境界チェックされたバッファを持つハードウェアもあります。残念ながら、M1にはどちらもありません。生のメモリロードで頂点フェッチを実装する必要がある。

ある命令セット機能が役に立つ。M1 GPUのメモリ・ロードは、64ビットのベース・アドレスに加えて、要素のオフセットも取ります。ハードウェアはオフセットをシフトし、64ビットのベースアドレスに加算して、フェッチするアドレスを決定します。さらにM1には、整数乗加算命令imadがあります。これらの機能を組み合わせることで、頂点ロードを2命令で実装できる。例えば、32ビット属性ロードは次のようになる：

```
imad idx, stride/4, vertex, offset/4
load.i32 result, base, idx
```

ハードウェア・ロードは、さらに小さなシフトを実行できます。アトリビュートが4つの32ビット値のベクトルで、オフセットなしでバッファに密集しているとします。この属性を1命令でロードすることができる：

```
load.v4i32 result, base, vertex << 2
```

...ハードウェアがアドレスを計算する：


#数式

ベース＋4×頂点左シフト2、これはベース＋16×頂点に等しい。

ロバスト性についてはどうだろう？

ユニフォーム・バッファでやったように、クランプでロバストネスを実装したい。問題は、最適化されたロードが 「頂点 」のインデックスを取るのに対し、頂点バッファのサイズがバイト単位で与えられることだ。1つの頂点バッファには、フォーマットやオフセットが異なる複数のアトリビュートが含まれる可能性があるため、バイト単位のサイズを「頂点」単位のサイズに変換することはできません。

後者の問題を処理しよう。アドレス指定方程式を次のように書き直すことができます：
ベース＋オフセット（属性ベース）＋ストライド×頂点

つまり、異なるオフセットで多くの属性を持つ1つのバッファは、1つの属性でオフセットなしの多くのバッファと等価である。これは、同じデータレイアウトに別の視点を与えます。これは改善でしょうか？アドレスは 64 ビットですが、アトリビュートのオフセットは 16 ビットです。より重要なのは、バイト単位の頂点バッファサイズを、各頂点アトリビュートの「頂点」単位のサイズに変換できることです。オフセットをクランプする代わりに、頂点インデックスをクランプします。ハードウェアアドレッシングモードをフルに活用し、ロバスト性を高めています：

```
umin idx, vertex, last valid
load.v4i32 result, base, idx << 2
```

各アトリビュートについて、最後に有効な頂点インデックスを前もって計算する必要があります。各アトリビュートには、特定のサイズを持つフォーマットがある。アドレッシング方程式を操作することで、ベースに対してバッファにアクセスされた最後のバイト（プラス1）を計算することができる：


#数式
オフセット＋ストライド×頂点＋フォーマット

この値がバイト単位のバッファサイズに束縛されるとき、ロードは有効である。整数不等式を次のように解く：
Vertexは、sizeからoffsetを引いた値をformatで割った値をstrideで割った値の階以下である。


#数式

ドライバは右辺を計算し、シェーダに渡します。

最後の問題：バッファが小さすぎて何もロードできない場合は？クランプしても救われません。コードは負のインデックスにクランプすることになります。この場合、アトリビュートはまったく無効なので、アプリケーションのバッファをゼロの小さなバッファと交換します。それぞれのアトリビュートにベース・アドレスを与えたので、この判定はアトリビュートごとに行われます。そして、インデックスをゼロにクランプすると、正しくゼロがロードされる。

これをまとめると、ちょっとしたドライバの計算で、1つのumin命令のコストで堅牢なバッファを得ることができます。

---
バッファの堅牢性に加えて、画像の堅牢性も必要である。バッファのロバスト性と同様に、イメージのロバスト性も、アウトオブバウンドのイメージロードがゼロを返すことを要求する。これは、合理的なハードウェアがすでに行っている保証を公式化したものだ。

...しかし、私たちのハードウェアが合理的であったら、面白くないだろう。

画像の堅牢性に関する適合性テストを実行すると、「mipmapping 」に影響する1つのテスト失敗がある。

背景として、ミップマップされた画像は複数の 「詳細レベル 」を含んでいる。基本レベルはオリジナル画像で、各レベルは前のレベルをダウンスケールしたものです。レンダリングの際、ハードウェアは画面上のサイズに最も近いレベルを選択し、効率とビジュアル品質を向上させます。

ロバスト性では、画像の負荷が...

- X座標またはY座標が範囲外の場合はゼロ。
- レベルが範囲外の場合はゼロ

一方、M1 GPUの画像ロードは...

- X座標またはY座標が境界外の場合はゼロ
- レベルがアウトオブバウンズの場合、最後のレベルの値

うーん。アウトオブバウンズのレベルに対してゼロを返すのではなく、ハードウェアがレベルをクランプしてゼロ以外の値を返すのだ。その理由は謎だ。このベンダーはハードウェアのドキュメントを公開していないため、我々はリバースエンジニアリングに頼ってドライバーを作らざるを得ない。ドキュメントがなければ、この動作が意図的なものなのかハードウェアのバグなのかもわからない。いずれにせよ、コンフォーマンスに合格するためには回避策が必要だ。

明らかな回避策は、無効なレベルから決してロードしないことである：

```
if (level <= levels) {
    return imageLoad(x, y, level)；
if (level <= levels) { return imageLoad(x, y, level); } else {
    return 0；
}
```

これは分岐を伴うので非効率的である。境界外のレベルをロードしてもクラッシュしないので、投機的にロードしてから、分岐の代わりに比較と選択の操作を使用できます：

```
vec4 data = imageLoad(x, y, level)；

return (level <= levels) ? data ： 0;
```

この回避策は問題ありませんが、改善できるかもしれません。M1 GPUはコンペアとセレクトを組み合わせた命令を持っていますが、命令セットはスカラーです。各スレッドは一度に1つの値を処理し、複数の値のベクターは処理しません。しかし、画像ロードは4つの成分（赤、緑、青、アルファ）のベクトルを返します。擬似コードは効率的に見えるが、結果のアセンブリはそうではない：

```
image_load R, x, y, level
ulesel R[0], level, levels, R[0], 0
ulesel R[1], level, levels, R[1], 0
ulesel R[2], level, レベル, R[2], 0
ulesel R[3], level, levels, R[3], 0
```

幸いなことに、ベンダードライバにはトリックがある。XかYのどちらかがアウトオブバウンズの場合、ハードウェアはゼロを返すことが分かっているので、XかYをアウトオブバウンズに設定することで、強制的にゼロを出力させることができる。最大画像サイズは幅16384ピクセルなので、16384より大きいXはすべてアウトオブバウンズとなる。そのため、別の回避策が正当化される：

```
bool valid = (level <= levels)；
int x_ = valid ? x : 20000；

return imageLoad(x_, y, level)；
```

なぜこの方が良いのか？ベクトル全体を変更するのではなく、単一のスカラーを変更するだけなので、コンパクトなスカラー・アセンブリにコンパイルできる：

```
ulesel x_, level, levels, x, #20000
image_load R, x_, y, level
```
定数をユニフォーム・レジスタにプリロードすれば、回避策は1命令で済む。これは最適です。


Daniel Bystedt 氏による Blender 『Wanderer』デモ は CC BY-SA でライセンスされます。

#### Alyssa Rosenzweig - 2024-02-14
