[Conformant OpenGL 4.6 on the M1](https://asahilinux.org/2024/02/conformant-gl46-on-the-m1/)の非公式日本語訳です。

訳注: 本家ブログaへのリンクは対応する日本語訳へのリンクに変更

---
# M1 が OpenGL 4.6 に準拠

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202401.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202406.md)

何年もの間、M1 は OpenGL 4.1 にしか対応していませんでした。今日変わります。OpenGL® 4.6とOpenGL® ES 3.2のリリースです！
最新の M1/M2 シリーズ・ドライバーのために[Fedoraをインストール](https://fedora-asahi-remix.org/)してください。

すでにインストール済みですか？`dnf upgrade --refresh` してください。

ベンダーの不準拠な 4.1 ドライバとは異なり、私たちの[オープンソース](https://gitlab.freedesktop.org/asahi/mesa) Linux ドライバは、最新の OpenGL バージョンに
**準拠** しており、最終的には [Blender](https://www.blender.org/) のような最新の OpenGL ワークロードとの幅広い互換性を約束します。

![Fedora Linux 39上のApple M1で動作するBlenderのスクリーンショット。シーンは『Wanderer』で、宇宙服を着たヒューマノイドが、ソーラーパネルを搭載したローバーのそばの岩だらけの地形にいる様子を描いています](https://asahilinux.org/img/blog/2024/02/Blender-Wanderer-high.avif)

4.6/3.2 に準拠するドライバは、正確性を保証するために100,000以上のテストに合格しなければなりません。現在、公式の準拠ドライバのリストには、私たちの
[OpenGL 4.6](https://www.khronos.org/conformance/adopters/conformant-products/opengl#submission_347) と [ES 3.2](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1045) が含まれています。

ベンダーはまだ最新の OpenGL のようなグラフィックス標準に対応していませんが、私たちは対応しています。このバレンタインデーに、相互運用可能なオープン標準への愛を公言
したいです。ユーザーと開発者をロックインから解放し、アプリケーションが特別なポートなしで、心が望む場所で実行できるようにしたいと考えています。
そのためには、標準への準拠が必要です。6ヶ月前、私たちはOpenGL ES 3.1ドライバを公開し、[M1用のあらゆる標準グラフィックス API に準拠した最初のドライバ](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202308.md)となりました。今日、OpenGL を完全な 4.6 に仕上げ...そして Vulkan への道を順調に進んでいます。

---

4.1 と比較して、OpenGL 4.6 には以下を含む数十の必要な機能が追加されています。

- 堅牢性(robustness)
- SPIR-V
- [クリップ制御](https://rosenzweig.io/blog/asahi-gpu-part-6.html)(訳注:リンクがおかしいので正しいリンクにしたつもり)
- カリング距離(Cull Distance) (訳注: [カリングの解説](https://gamemakers.jp/article/2024_10_04_77250/)、[距離でのカリング](https://miyahuji111.hatenablog.com/entry/2017/07/24/202630)
- [コンピュート・シェーダ](https://github.com/asfdrwe/asahi-linux-translations/blob/main/GPU202308.md)
- アップグレードされたトランスフォーム・フィードバック

残念なことに、M1 は OpenGL ES 3.1 より新しいグラフィックス標準にはうまくマッピングできません。Vulkan はこれらの機能のいくつかをオプションにしていますが、
欠けている機能は DirectX と OpenGL を載せるために必要です。M1 の既存のソリューションでは、OpenGL 4.1の機能セットを乗り越えるものはありません。

どうやって 4.1 の壁を破りましょうか? ハードウェア対応がなければ、新しい機能には新しいトリックが必要です。ジオメトリー・シェーダー、テッセレーション、
トランスフォーム・フィードバックは、コンピュート・シェーダになります。カリング距離は変換され補間された値になります。クリップ制御は頂点シェーダーのエピローグになります。
リストはまだまだ続きます。

克服した課題の一例として、**堅牢性**を見てみましょう。

ゲーム用に作られた GPU は、伝統的に安全性よりも生性能を優先します。バッファを境界外(out-of-bounds)で読み込むシェーダーのような無効なアプリケーションコードは、
未定義の動作を引き起こす可能性があります。ドライバはこれを悪用して性能を最大化します。

ウェブブラウザのようなアプリケーションにとって、このトレードオフは望ましくありません。ブラウザは信頼されていないシェーダーを扱い、安定性とセキュリティを確保する
ためにそれをサニタイズしなければなりません。悪意のあるリンクをクリックしても、ブラウザがクラッシュするようなことがあってはなりません。グラフィックス　API　は
セキュリティの障壁ではないので、ある程度のサニタイズは必要ですが、API の未定義の振る舞いを減らすことは、『深層防御(defense in depth)』を助けることができます。

『堅牢性』機能は助けになります。堅牢性がなければ、シェーダ内の境界外バッファアクセスがクラッシュする可能性があります。堅牢性があれば、アプリケーションは
定義された境界外の振る舞いを選択することができ、性能をある程度引き下げる代わりに攻撃対象が少なくできます。

最近のクロスベンダー API にはすべて堅牢性が含まれています。（偶然かもしれませんが?）多くのゲームは堅牢性に依存しています。不思議なことに、ベンダー独自の API は
バッファの堅牢性を省いています。私たちは、適合性、正確性、互換性のためにもっとうまくやらなければなりません。

まず問題を定義しましょう。堅牢性が有効になっているときに、API ごとに境界外ロードが何を返すかの定義が異なります。

- ゼロ（Direct3D、`robustBufferAccess2` 付きVulkan）
- ゼロまたはバッファ内のデータ（OpenGL、`robustBufferAccess`付きVulkan）のどちらか
- 任意の値を返すが、クラッシュしない（OpenGL ES）

OpenGL は2番目の定義を使用します：ゼロまたはバッファからデータを返します。1つのアプローチは、境界外アクセスのためにバッファの*最後*の要素を返すことです。
バッファサイズが与えられれば、最後のインデックスを計算できます。ここで、アクセスされているインデックスと最後のインデックスの*最小値*を考えます。これは、
アクセスされているインデックスが有効であればそれに等しく、そうでなければ他の有効なインデックスに等しくなります。最小のインデックスをロードすることは
安全であり、仕様に準拠した結果が得られます。

例として、堅牢性を排除したユニフォームバッファ(uniform buffer)ロードは以下のようになります。

```
load.i32 result, buffer, index
```

堅牢性は、1つの符号なし最小命令（`umin`）を追加します。

```
umin idx, index, last
load.i32 result, buffer, idx
```

堅牢性版の方が遅いですか？遅くなるでしょう。算術演算はメモリよりも高速なので、その差はパーセンテージで見れば小さいはずです。何千ものスレッドが並列に実行されている場合、
演算コストはロードのレイテンシによって隠されることさえあります。

堅牢なユニフォームバッファを高速化する別のトリックがあります。他の GPU と同様、M1 は『プリアンブル(preambles)』に対応しています。考え方は簡単で、すべてのスレッドで同じ値を計算する代わりに
一度計算して結果を再利用した方が高速になります。コンパイラは適格な計算を識別し、メインシェーダの前に実行されるプリアンブルに移動させます。このような冗長性はよくあることなので、
プリアンブルはすばらしいスピードアップをもたらします。

すべてのスレッドが同じインデックスをロードする場合、通常、単一バッファロードをプリアンブルに移動します。ユニフォームバッファのサイズは固定なので、余分な堅牢性演算もプリアンブルに
移動します。堅牢性はメインシェーダにとって『フリー』です。堅牢ストレージバッファの場合、ロードやストアができなくても、
clamping(訳注:[データを最大値と最小値間に押さえる](https://en.wikipedia.org/wiki/Clamping_(graphics)))がプリアンブルに移動する可能性があります。

堅牢な単一バッファとストレージバッファで武装して、堅牢な『頂点バッファ』を考えてみましょう。グラフィックス APIでは、アプリケーションはベース GPU アドレスと、
各バッファ内の『属性』の選択されたレイアウトを持つ頂点バッファを設定することができます。各属性にはオフセットとフォーマットがあり、バッファには頂点ごとの
バイト数を示す『ストライド』があります。頂点シェーダは、頂点による暗黙のインデックスで属性を読み込むことができます。そのために、シェーダはアドレスをロードします。

#数式

ロバストな頂点フェッチをネイティブに実装しているハードウェアもあります。また、ロバストなソフトウェア頂点フェッチを高速化するために、境界チェックされたバッファを持つハードウェアもあります。残念ながら、M1にはどちらもありません。生のメモリロードで頂点フェッチを実装する必要がある。

ある命令セット機能が役に立つ。M1 GPUのメモリ・ロードは、64ビットのベース・アドレスに加えて、要素のオフセットも取ります。ハードウェアはオフセットをシフトし、64ビットのベースアドレスに加算して、フェッチするアドレスを決定します。さらにM1には、整数乗加算命令imadがあります。これらの機能を組み合わせることで、頂点ロードを2命令で実装できる。例えば、32ビット属性ロードは次のようになる：

```
imad idx, stride/4, vertex, offset/4
load.i32 result, base, idx
```

ハードウェア・ロードは、さらに小さなシフトを実行できます。アトリビュートが4つの32ビット値のベクトルで、オフセットなしでバッファに密集しているとします。この属性を1命令でロードすることができる：

```
load.v4i32 result, base, vertex << 2
```

...ハードウェアがアドレスを計算する：


#数式

ベース＋4×頂点左シフト2、これはベース＋16×頂点に等しい。

ロバスト性についてはどうだろう？

ユニフォーム・バッファでやったように、クランプでロバストネスを実装したい。問題は、最適化されたロードが 「頂点 」のインデックスを取るのに対し、頂点バッファのサイズがバイト単位で与えられることだ。1つの頂点バッファには、フォーマットやオフセットが異なる複数のアトリビュートが含まれる可能性があるため、バイト単位のサイズを「頂点」単位のサイズに変換することはできません。

後者の問題を処理しよう。アドレス指定方程式を次のように書き直すことができます：
ベース＋オフセット（属性ベース）＋ストライド×頂点

つまり、異なるオフセットで多くの属性を持つ1つのバッファは、1つの属性でオフセットなしの多くのバッファと等価である。これは、同じデータレイアウトに別の視点を与えます。これは改善でしょうか？アドレスは 64 ビットですが、アトリビュートのオフセットは 16 ビットです。より重要なのは、バイト単位の頂点バッファサイズを、各頂点アトリビュートの「頂点」単位のサイズに変換できることです。オフセットをクランプする代わりに、頂点インデックスをクランプします。ハードウェアアドレッシングモードをフルに活用し、ロバスト性を高めています：

```
umin idx, vertex, last valid
load.v4i32 result, base, idx << 2
```

各アトリビュートについて、最後に有効な頂点インデックスを前もって計算する必要があります。各アトリビュートには、特定のサイズを持つフォーマットがある。アドレッシング方程式を操作することで、ベースに対してバッファにアクセスされた最後のバイト（プラス1）を計算することができる：


#数式
オフセット＋ストライド×頂点＋フォーマット

この値がバイト単位のバッファサイズに束縛されるとき、ロードは有効である。整数不等式を次のように解く：
Vertexは、sizeからoffsetを引いた値をformatで割った値をstrideで割った値の階以下である。


#数式

ドライバは右辺を計算し、シェーダに渡します。

最後の問題：バッファが小さすぎて何もロードできない場合は？クランプしても救われません。コードは負のインデックスにクランプすることになります。この場合、アトリビュートはまったく無効なので、アプリケーションのバッファをゼロの小さなバッファと交換します。それぞれのアトリビュートにベース・アドレスを与えたので、この判定はアトリビュートごとに行われます。そして、インデックスをゼロにクランプすると、正しくゼロがロードされる。

これをまとめると、ちょっとしたドライバの計算で、1つのumin命令のコストで堅牢なバッファを得ることができます。

---
バッファの堅牢性に加えて、画像の堅牢性も必要である。バッファのロバスト性と同様に、イメージのロバスト性も、アウトオブバウンドのイメージロードがゼロを返すことを要求する。これは、合理的なハードウェアがすでに行っている保証を公式化したものだ。

...しかし、私たちのハードウェアが合理的であったら、面白くないだろう。

画像の堅牢性に関する適合性テストを実行すると、「mipmapping 」に影響する1つのテスト失敗がある。

背景として、ミップマップされた画像は複数の 「詳細レベル 」を含んでいる。基本レベルはオリジナル画像で、各レベルは前のレベルをダウンスケールしたものです。レンダリングの際、ハードウェアは画面上のサイズに最も近いレベルを選択し、効率とビジュアル品質を向上させます。

ロバスト性では、画像の負荷が...

- X座標またはY座標が範囲外の場合はゼロ。
- レベルが範囲外の場合はゼロ

一方、M1 GPUの画像ロードは...

- X座標またはY座標が境界外の場合はゼロ
- レベルがアウトオブバウンズの場合、最後のレベルの値

うーん。アウトオブバウンズのレベルに対してゼロを返すのではなく、ハードウェアがレベルをクランプしてゼロ以外の値を返すのだ。その理由は謎だ。このベンダーはハードウェアのドキュメントを公開していないため、我々はリバースエンジニアリングに頼ってドライバーを作らざるを得ない。ドキュメントがなければ、この動作が意図的なものなのかハードウェアのバグなのかもわからない。いずれにせよ、コンフォーマンスに合格するためには回避策が必要だ。

明らかな回避策は、無効なレベルから決してロードしないことである：

```
if (level <= levels) {
    return imageLoad(x, y, level)；
if (level <= levels) { return imageLoad(x, y, level); } else {
    return 0；
}
```

これは分岐を伴うので非効率的である。境界外のレベルをロードしてもクラッシュしないので、投機的にロードしてから、分岐の代わりに比較と選択の操作を使用できます：

```
vec4 data = imageLoad(x, y, level)；

return (level <= levels) ? data ： 0;
```

この回避策は問題ありませんが、改善できるかもしれません。M1 GPUはコンペアとセレクトを組み合わせた命令を持っていますが、命令セットはスカラーです。各スレッドは一度に1つの値を処理し、複数の値のベクターは処理しません。しかし、画像ロードは4つの成分（赤、緑、青、アルファ）のベクトルを返します。擬似コードは効率的に見えるが、結果のアセンブリはそうではない：

```
image_load R, x, y, level
ulesel R[0], level, levels, R[0], 0
ulesel R[1], level, levels, R[1], 0
ulesel R[2], level, レベル, R[2], 0
ulesel R[3], level, levels, R[3], 0
```

幸いなことに、ベンダードライバにはトリックがある。XかYのどちらかがアウトオブバウンズの場合、ハードウェアはゼロを返すことが分かっているので、XかYをアウトオブバウンズに設定することで、強制的にゼロを出力させることができる。最大画像サイズは幅16384ピクセルなので、16384より大きいXはすべてアウトオブバウンズとなる。そのため、別の回避策が正当化される：

```
bool valid = (level <= levels)；
int x_ = valid ? x : 20000；

return imageLoad(x_, y, level)；
```

なぜこの方が良いのか？ベクトル全体を変更するのではなく、単一のスカラーを変更するだけなので、コンパクトなスカラー・アセンブリにコンパイルできる：

```
ulesel x_, level, levels, x, #20000
image_load R, x_, y, level
```
定数をユニフォーム・レジスタにプリロードすれば、回避策は1命令で済む。これは最適です。


Daniel Bystedt 氏による Blender 『Wanderer』デモ は CC BY-SA でライセンスされます。

#### Alyssa Rosenzweig - 2024-02-14
