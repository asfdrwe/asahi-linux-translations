[The first conformant M1 GPU driver](https://asahilinux.org/2023/08/first-conformant-m1-gpu-driver/)の非公式日本語訳です。

---
# 最初の準拠 M1 GPUドライバ

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202308.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202401.md)

OpenGL® ES 3.1 準拠ドライバが M1 ファミリーおよび M2 ファミリーの GPU で利用可能になりました。つまり、ドライバはあらゆる OpenGL ES 3.1 アプリケーションと
互換性があります。興味あります？[Linuxをインストールするだけですよ！](https://fedora-asahi-remix.org/)

すでに [Asahi Linux](https://asahilinux.org/) をお使いの方は、`dnf upgrade` (Fedora) または `pacman -Syu` (Arch) でシステムを
最新ドライバにアップグレードしてください。

私たちがリバースエンジニアリングしたフリーで[オープンソースのグラフィックスドライバ](https://gitlab.freedesktop.org/asahi/mesa)は、
M1 ファミリーと M2 ファミリーのグラフィックスハードウェア用の世界で*唯一の* OpenGL ES 3.1 準拠実装です。つまり、ドライバは、正確性を実証するために
何万回ものテストに合格しており、今や業界で認められていることを意味します。

規格準拠となるために、『実装』は仕様のすべての機能を検証するために設計された公式の適合性検証スイートに合格しなければなりません。テスト結果は、標準化団体である
 Khronos に提出されます。[30日間のレビュー期間](https://www.khronos.org/conformance/adopters/)後、問題が見つからなければ、その実装は準拠となります。
Khronos のウェブサイトには、[M1](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1007)、
[M1 Pro/Max/Ultra](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1014)、
[M2](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1016)、
[M2 Pro/Max](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1017)用ドライバーを含む、すべての準拠実装が掲載されています。

今日のマイルストーンは OpenGL ES に関するものだけではありません。私たちは M1 用のあらゆるグラフィックス標準の最初の準拠実装を公開します。そして、
ここで止まるつもりはありません。;-）

![image1](https://asahilinux.org/img/blog/2023/08/vkinstancing2.webp)

私たちのものとは異なり、メーカーの M1 ドライバは、残念ながら Vulkan であれ OpenGL であれ OpenGL ES であれ、*どの*標準グラフィックスAPIにも準拠していません。
つまり、（Linux を実行していない場合）標準規格を使用するアプリケーションが M1/M2 で動作する保証はないということになります。これは単なる理論上の問題ではありません。
Vulkan について考えてみましょう。サードパーティの [MoltenVK](https://github.com/KhronosGroup/MoltenVK) は、プロプライエタリ・ドライバの上に Vulkan のサブセットを
重ねています。しかし、これらのドライバには重要な機能が欠けており、有効な Vulkan アプリケーションを壊してしまいます。M1/M2 コンピューターをまだ Linux に切り替えて
いない場合、開発者にとってもユーザーにとっても障害となります。

メーカーがそうしなかったのに、なぜ*私たち*は標準準拠を追求したのでしょうか？つまるところ私たちの品質へのこだわりからです。ユーザーに私たちの Linux ドライバが信頼できることを
知ってもらいたいのです。M1 特有のハックや移植なしに標準的なソフトウェアが動作することを望んでいます。エコシステムのために正しい手本を示したいと思っています。
『移植性』のために妥協することなく、仕様に準拠したオープンスタンダードを実装することこそ、進むべき道なのです。標準規格の実装を拒否するプロプライエタリドライバや
プロプライエタリAPI に満足していません。他の業界は、進歩はベンダー間の協力から生まれることを知っています。私たちも知っています。規格準拠を達成することは、
私たちのコミュニティにとっても、オープンソースにとっても、オープングラフィックスにとっても勝利なのです。

もちろん、[Asahi Lina氏](https://vt.social/@lina/)と私(訳注:原文の著者のAlyssa Rosenzweig氏)は、最小限の資金しか持たない2人の個人です。
大企業に勝つなんて、ちょっと気が引けますね...

でも、まだ遅くありません。まだ間に合います！

---

OpenGL ES 3.1は、6月に公開した[実験的なOpenGL ES 3.0とOpenGL 3.1](https://rosenzweig.io/blog/opengl3-on-asahi-linux.html)
(訳注:原文はリンクがおかしいので正しいと思われるサイトへのリンクに修正)を更新したものです。特筆すべき点は、ES 3.1にコンピュートシェーダが追加されたことです。
これは通常、グラフィックス・アプリケーション内の一般的な計算を高速化するために使用されます。例えば、3D ゲームは物理シミュレーションをコンピュートシェーダで実行できます。
シミュレーション結果はレンダリングに使用され、CPU の物理シミュレーションと GPU を同期させるために必要なストールをなくすことができます。これにより、ゲームの実行速度が向上します。

新機能の1つである画像上のアトミック(atomic)に注目してみましょう。旧バージョンの OpenGL ES では、アプリケーションが画像を読み込んで画面に表示することができました。
ES 3.1では、アプリケーションは画像に*書き込む*ことができ、一般的にコンピュートシェーダから書き込むことができます。この新機能により、従来は固定関数の 3D パイプラインに
収める必要があった柔軟な画像処理アルゴリズムが可能になります。しかし、GPUは超並列であり、何千ものスレッドを同時に実行します。2つのスレッドが同じ場所に書き込むと、
競合が発生します。どちらのスレッドが先に実行されるかによって、結果は異なります。競合状態(race condition)が発生します。

メモリへの『アトミック』アクセス(訳注: [不可分操作](https://ja.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%88%86%E6%93%8D%E4%BD%9C))は、
競合状態に対する解決策を提供します。アトミックでは、メモリサブシステムの特別なハードウェアが、スレッドの順序に関係なく、セレクト操作の一貫した明確な結果を保証します。
最近のグラフィックス・ハードウェアは、加算などさまざまなアトミック演算をサポートしており、複雑な並列アルゴリズムの構築ブロックとして機能しています。

この2つの機能を組み合わせれば、アトミックに画像に書き込めるのでしょうか？

可能です。ES 3.2で必須のユビキタスな OpenGL ES [拡張](https://registry.khronos.org/OpenGL/extensions/OES/OES_shader_image_atomic.txt)は、
画像内のピクセルで動作するアトミックを追加します。例えば、コンピュートシェーダはピクセル(10, 20)の値をアトミックに増分できます。

他の GPU は画像上でアトミックを実行する専用命令を持っており、ドライバの実装は簡単です。私たちにとって、話はもっと複雑です。M1 には、非画像アトミックと
非アトミック画像があるにもかかわらず、画像アトミック用のハードウェア命令がありません。問題を再構成する必要があります。

考え方は単純です。ピクセルのアトミックを実行するには、メモリ上のピクセルのアドレスを代わりに計算し、そのアドレスに対して通常のアトミックを実行します。
ハードウェアは通常のアトミックに対応しているので、すべきことはピクセルのアドレスを計算する『だけ』です。

もし画像がメモリ上にリニアにレイアウトされていれば、これは簡単なことです。Y座標に行ごとのバイト数（『Stride』）を掛け、X座標にピクセルごとのバイト数(訳注:ytesPerPixel)を掛け、
足します。これで画像の最初のピクセルに対するピクセルのオフセットがバイト単位で得られます。最終的なアドレスを得るには、そのオフセットを最初のピクセルのアドレスに加えます。

$$ Address(X, Y) = Address(0,0) + Y \cdot Stride + X \cdot BytesPerPixel $$

残念なことに、画像がメモリ上で直線的であることはほとんどありません。キャッシュ効率を向上させるため、最近のグラフィックス・ハードウェアは X 座標と Y 座標を
インターリーブしています。メモリ上のピクセルは、次から次へと並ぶのではなく、[らせん状の曲線](https://fgiesen.wordpress.com/2011/01/17/texture-tiling-and-swizzling/)を描きます。

座標をインターリーブするには、先ほどの式を修正する必要があります。多くの命令を使って 1 ビットずつマスクし、シフトしてインターリーブ結果を構成することもできますが、
非効率的です。もっといい方法があります。

[ビットをインターリーブする有名な『ビットいじり(bit twiddling)』アルゴリズム](https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN)が
存在します。このアルゴリズムは、一度に1ビットをシャッフルするのではなく、ビットのグループをシャッフルし、問題を並列化します。このアルゴリズムをシェーダコードに
実装することで、性能が向上します。

実際には、各座標の下位7ビット（またはそれ以下）だけがインターリーブされます。そのため、X 座標と Y 座標を 32 ビットレジスタの下位 16 ビットと上位 16 ビットに入れて、
インターリーブを『ベクトル化』するために32ビット命令を使うことができます。この 32 ビット命令によって、X と Y を同時にインターリーブすることができ、命令数が半分になります。
さらに、GPU のシフトと加算を組み合わせた命令を利用することもできます。これらのトリックを組み合わせることで、M1 GPU アセンブリ 10 命令でインターリーブすることができます。

```
# Inputs x, y in r0l, r0h.
# Output in r1.

add r2, #0, r0, lsl 4
or  r1, r0, r2
and r1, r1, #0xf0f0f0f
add r2, #0, r1, lsl 2
or  r1, r1, r2
and r1, r1, #0x33333333
add r2, #0, r1, lsl 1
or  r1, r1, r2
and r1, r1, #0x55555555
add r1, r1l, r1h, lsl 1
```

ここでやめることもできますが、ビットをインターリーブする*専用*の命令があるとしたらどうしましょうか? PowerVR には『シャッフル』命令 `shfl` があり、M1 GPU は PowerVR を
借用しています。おそらくその命令も借用したのでしょう。残念なことに、仮にあったとしても、私たちのテスト用シェーダーをコンパイルする際、独自コンパイラはそれを使用しません。
そのため、コンパイルされたシェーダを観察してその命令をリバースエンジニアリングすることは（もし存在するとしても）難しいです。

そこで、魔法の幼稚園で習った強力なリバースエンジニアリングのテクニックの出番です。

[Dougall Johnson氏](https://mastodon.social/@dougall)はこの問題への推測を提供してくれました。すでに知っている命令を考慮する際に、Dougall Johnson氏は
『リバース・ビット(reverse bits)』命令に特別な注意を払いました。ビットの反転はビットシャッフルの一種なので、インターリーブ命令も同様に符号化されるべきです。
ビット反転命令には、演算を指定する2ビットのフィールドがあり、値は `01` です。*セットビット(set bits)の数を数える*命令と、*最初のセットビット*を見つける命令は、
それぞれ値 `10` と `11` を持ちます。これは、既知の『複雑なビット操作』命令をすべて網羅しています。

2ビットの列挙のうち、観測されていない未知の値が1つあります。`00` です。このインターリーブ命令が存在するとすれば、それはおそらくビット反転のようにエンコード
されているが、オペレーションコードは `01` ではなく `00` でしょう。

難点があります。既知の3つの命令は入力ソースが1つですが、この命令は2つのソースをインターリーブしています。2つ目のソースはどこに行くのでしょうか? 対称性から推測
できます。おそらくハードウェアデコーダを単純化するために、M1 GPU 命令は通常、命令間で一貫した場所にソースをエンコードします。他の 3 つの命令には、2 つのソースを
持つ演算命令で 2 番目のソースがあると予想される場所にギャップがあります。おそらく 2 番目のソースはそこにあるのでしょう。

この推測をもとに、今度は私たちがチェックする番になりました。GPUアセンブリを手書きするのではなく、コンパイラをハックして、（乗算のような）2つのソースの整数演算を、
推測したエンコーディングの『インターリーブ』に置き換えることができます。それから、この演算（数値を『乗算』）を使ってコンピュートシェーダを書き、ドライバの
新しいコンピュートサポートを使って実行します。

あとは、謎の命令が可能な入力ごとにインターリーブされた結果を返すことをチェックする[シェーダ](https://asahilinux.org/img/blog/2024/02/blog/interleave.shader_test)
(訳注:正しいリンクがわかりませんので原文のリンク先のまま)を
書くだけです。この命令は2つの16ビットソースを取るので、入力は約40億（ $2^{32}$ (訳注:誤記修正) ）あります。私たちのドライバを使えば、M1 GPU は1秒以内にそれらすべてを
チェックすることができます。

座標をインターリーブするための賢いベクトル化アセンブリについてはどうでしょうか? 1命令で置き換えできます。拍子抜けしますが、高速であり、適合性テストに合格しています。

それが重要なのです。

---

オープンドライバをサポートしてくれた[Khronos](https://www.khronos.org/)と[Software in the Public Interest](https://www.spi-inc.org/)に感謝します。

#### Alyssa Rosenzweig · 2023-08-22



