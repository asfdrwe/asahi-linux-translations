[The first conformant M1 GPU driver](https://asahilinux.org/2023/08/first-conformant-m1-gpu-driver/)の非公式日本語訳です。

訳注: DeepLの結果を貼っただけ(2024/10/25)

---
# 最初の準拠 M1 GPUドライバ

- [前回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202308.md)
- [次回](https://github.com/asfdrwe/asahi-linux-translations/blob/main/PROGRESS202401.md)

OpenGL® ES 3.1 準拠ドライバが M1 ファミリーおよび M2 ファミリーの GPU で利用可能になりました。つまり、ドライバはあらゆる OpenGL ES 3.1 アプリケーションと
互換性があります。興味があります？[Linuxをインストールするだけですよ！](https://fedora-asahi-remix.org/)

すでに [Asahi Linux](https://asahilinux.org/) をお使いの方は、`dnf upgrade` (Fedora) または `pacman -Syu` (Arch) でシステムを
最新ドライバにアップグレードしてください。

私たちがリバースエンジニアリングしたフリーで[オープンソースのグラフィックスドライバ](https://gitlab.freedesktop.org/asahi/mesa)は、
M1 ファミリーと M2 ファミリーのグラフィックスハードウェア用の世界で*唯一の* OpenGL ES 3.1 準拠実装です。つまり、ドライバは、正確性を実証するために
何万回ものテストに合格しており、今や業界で認められていることを意味します。

準拠になるために、『実装』は仕様のすべての機能を検証するために設計された公式の適合性検証スイートに合格しなければなりません。テスト結果は、標準化団体である
 Khronos に提出されます。[30日間のレビュー期間](https://www.khronos.org/conformance/adopters/)後、問題が見つからなければ、その実装は準拠となります。
Khronos のウェブサイトには、[M1](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1007)、
[M1 Pro/Max/Ultra](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1014)、
[M2](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1016)、
[M2 Pro/Max](https://www.khronos.org/conformance/adopters/conformant-products/opengles#submission_1017)用ドライバーを含む、すべての準拠実装が掲載されています。

今日のマイルストーンは OpenGL ES に関するものだけではありません。私たちは M1 用のあらゆるグラフィックス標準の最初の準拠実装を公開します。そして、
ここで止まるつもりはありません。;-）

![image1](https://asahilinux.org/img/blog/2023/08/vkinstancing2.webp)

私たちのものとは異なり、メーカーの M1 ドライバは、残念ながら Vulkan であれ OpenGL であれ OpenGL ES であれ、*どの*標準グラフィックスAPIにも準拠していません。
つまり、（Linux を実行していない場合）標準規格を使用するアプリケーションが　M1/M2　で動作する保証はないということになります。これは単なる理論上の問題ではありません。
Vulkan　を考えてみましょう。サードパーティの [MoltenVK](https://github.com/KhronosGroup/MoltenVK) は、プロプライエタリ・ドライバの上に Vulkan のサブセットを
重ねています。しかし、これらのドライバには重要な機能が欠けており、有効な Vulkan アプリケーションを破壊してしまいます。M1/M2 コンピューターをまだ Linux に切り替えて
いない場合、それは開発者にもユーザーにも障害となります。

メーカーがそうしなかったのに、なぜ*私たち*は標準準拠を追求したのでしょうか？何よりも私たちの品質へのこだわりからです。ユーザーに私たちの Linux ドライバが信頼できることを
知ってもらいたいのです。M1 特有のハックや移植なしに標準的なソフトウェアが動作することを望んでいます。エコシステムのために正しい手本を示したいと思っています。
『移植性』のために妥協することなく、仕様に準拠したオープン・スタンダードを実装することこそ、進むべき道なのです。標準規格の実装を拒否するプロプライエタリー・ドライバーや
プロプライエタリー・API　に満足していません。他の業界は、進歩はベンダー間の協力から生まれることを知っています。私たちも知っています。規格準拠を達成することは、
私たちのコミュニティにとっても、オープンソースにとっても、オープングラフィックスにとっても勝利なのです。

もちろん、[Asahi Lina氏](https://vt.social/@lina/)と私(訳注:原文の著者のAlyssa Rosenzweig氏)は、最小限の資金しか持たない2人の個人です。
大企業に勝つなんて、ちょっと気が引けますね...

でも、まだ遅くありません。まだ間に合います！

---

OpenGL ES 3.1は、6月に出荷した実験的なOpenGL ES 3.0とOpenGL 3.1を更新したものです。特筆すべきは、ES 3.1にコンピュート・シェーダーが追加されたことです。これは通常、グラフィックス・アプリケーション内の一般的な計算を高速化するために使用されます。例えば、3Dゲームは物理シミュレーションをコンピュートシェーダで実行できます。シミュレーション結果はレンダリングに使用され、CPUの物理シミュレーションとGPUを同期させるために必要なストールをなくすことができる。これにより、ゲームの実行速度が向上します。

新機能の1つである画像上のアトミックに注目してみよう。旧バージョンのOpenGL ESでは、アプリケーションが画像を読み込んで画面に表示することができました。ES 3.1では、アプリケーションは画像に書き込むことができ、通常はコンピュートシェーダから書き込むことができます。この新機能により、従来は固定関数の3Dパイプラインに収める必要があった柔軟な画像処理アルゴリズムが可能になります。しかし、GPUは超並列であり、何千ものスレッドを同時に実行します。2つのスレッドが同じ場所に書き込むと、競合が発生します。どちらのスレッドが先に実行されるかによって、結果は異なります。競合状態が発生するのだ。

メモリへの「アトミック」アクセスは、競合状態に対する解決策を提供する。アトミックでは、メモリサブシステムの特別なハードウェアが、スレッドの順序に関係なく、セレクト操作の一貫した明確な結果を保証します。最近のグラフィックス・ハードウェアは、加算のようなさまざまなアトミック演算をサポートしており、複雑な並列アルゴリズムのビルディング・ブロックとして機能している。

この2つの機能を組み合わせれば、アトミックに画像に書き込めるのでしょうか？

可能です。ユビキタスなOpenGL ES拡張（ES 3.2で必須）は、画像内のピクセルで動作するアトミックを追加します。例えば、コンピュートシェーダはピクセル(10, 20)の値をアトミックにインクリメントできます。

他のGPUは画像上でアトミックを実行する専用命令を持っており、ドライバの実装は簡単です。私たちにとっては、話はもっと複雑です。M1には、非画像アトミックと非アトミック画像があるにもかかわらず、画像アトミック用のハードウェア命令がありません。問題を再構成する必要がある。

ピクセルのアトミックを実行するには、代わりにメモリ上のピクセルのアドレスを計算し、そのアドレスに対して通常のアトミックを実行する。ハードウェアは通常のアトミックをサポートしているので、私たちのタスクはピクセルのアドレスを計算する「だけ」です。

Y座標に行ごとのバイト数（「ストライド」）を掛け、X座標にピクセルごとのバイト数を掛け、足す。これで、画像の最初のピクセルに対するピクセルのオフセットがバイト単位で得られます。最終的なアドレスを得るには、そのオフセットを最初のピクセルのアドレスに加える。

# 数式

残念なことに、画像がメモリ上で直線的であることはほとんどない。キャッシュ効率を向上させるため、最近のグラフィックス・ハードウェアはX座標とY座標をインターリーブしている。メモリ上のピクセルは、次から次へと並ぶのではなく、らせん状の曲線を描きます。

座標をインターリーブするには、先ほどの式を修正する必要がある。多くの命令を使って1ビットずつマスクし、シフトしてインターリーブ結果を構成することもできるが、それは非効率的だ。もっといい方法がある。

ビットをインターリーブする有名な 「ビットいじり 」アルゴリズムがある。このアルゴリズムは、一度に1ビットをシャッフルするのではなく、ビットのグループをシャッフルし、問題を並列化します。このアルゴリズムをシェーダコードに実装することで、性能が向上します。

実際には、各座標の下位7ビット（またはそれ以下）だけがインターリーブされます。そのため、X座標とY座標を32ビットレジスタの下位16ビットと上位16ビットに入れて、インターリーブを「ベクトル化」するために32ビット命令を使うことができます。この32ビット命令によって、XとYを同時にインターリーブすることができ、命令数が半分になります。さらに、GPUのシフトと加算を組み合わせた命令を利用することもできます。これらのトリックを組み合わせることで、M1 GPUアセンブリの10命令でインターリーブすることができます：

```
# Inputs x, y in r0l, r0h.
# Output in r1.

add r2, #0, r0, lsl 4
or  r1, r0, r2
and r1, r1, #0xf0f0f0f
add r2, #0, r1, lsl 2
or  r1, r1, r2
and r1, r1, #0x33333333
add r2, #0, r1, lsl 1
or  r1, r1, r2
and r1, r1, #0x55555555
add r1, r1l, r1h, lsl 1
```

ここでやめることもできるが、ビットをインターリーブする専用の命令があるとしたらどうだろう？PowerVRには「シャッフル」命令shflがあり、M1 GPUはPowerVRから拝借している。おそらくその命令も借用したのだろう。残念なことに、仮にあったとしても、私たちのテスト用シェーダーをコンパイルする際、独自コンパイラーはそれを使用しません。そのため、コンパイルされたシェーダーを観察してその命令をリバースエンジニアリングすることは（もし存在するとしても）難しい。

そこで、魔法の幼稚園で習った強力なリバースエンジニアリングのテクニックの出番だ。

ドーゴル・ジョンソンは、この推測を提供してくれた。私たちがすでに知っている命令を考えるとき、彼は「リバース・ビット」命令に特別な注意を払った。ビットの反転はビットシャッフルの一種であるから、インターリーブ命令も同様に符号化されるべきである。ビット反転命令には、演算を指定する2ビットのフィールドがあり、値は01である。セットビットの数を数える命令と、最初のセットビットを見つける命令は、それぞれ値10と11を持つ。これは、既知の「複雑なビット操作」命令をすべて網羅している。

2ビットの列挙のうち、観測されていない未知の値が1つある：00である。このインターリーブ命令が存在するとすれば、それはおそらくビット反転のようにエンコードされているが、オペレーションコードは01ではなく00である。

既知の3つの命令は入力ソースが1つだが、この命令は2つのソースをインターリーブしている。つ目のソースはどこに行くのだろうか？対称性から推測することができる。おそらくハードウェアデコーダを単純化するために、M1 GPU命令は通常、命令間で一貫した場所にソースをエンコードします。他の 3 つの命令には、2 つのソースを持つ演算命令で 2 番目のソースがあると予想される場所にギャップがあります。おそらく2番目のソースはそこにあるのでしょう。

推測をもとに、今度は私たちがチェックする番だ。GPUアセンブリを手書きするのではなく、コンパイラをハックして、（乗算のような）2つのソースの整数演算を、推測したエンコーディングの「インターリーブ」に置き換えることができます。それから、この演算（数値を「乗算」する）を使って計算シェーダを書き、ドライバの新し い計算サポートを使って実行します。

あとは、謎の命令が可能な入力ごとにインターリーブされた結果を返すことをチェックするシェーダを書くだけです。この命令は2つの16ビットソースを取るので、入力は約40億（$2^32$）あります。私たちのドライバを使えば、M1 GPUは1秒以内にそれらすべてをチェックすることができます。

座標をインターリーブするための賢いベクトル化アセンブリーについては？1つの命令で置き換えることができる。拍子抜けだが、高速でコンフォーマンス・テストに合格している。

それが重要なのだ。

---

オープン・ドライバをサポートしてくれたKhronosとSoftware in the Public Interestに感謝する。

#### Alyssa Rosenzweig · 2023-08-22



