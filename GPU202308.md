[The first conformant M1 GPU driver](https://asahilinux.org/2023/08/first-conformant-m1-gpu-driver/)の非公式日本語訳です。

訳注: DeepLの結果を貼っただけ(2024/10/25)

---
# 最初の準拠 M1 GPUドライバ

適合するOpenGL® ES 3.1ドライバがM1ファミリおよびM2ファミリGPUで利用可能になりました。つまり、ドライバはあらゆるOpenGL ES 3.1アプリケーションと互換性があります。興味がありますか？Linuxをインストールするだけです！

すでにAsahi Linuxをお使いの方は、dnf upgrade (Fedora) または pacman -Syu (Arch) でシステムをアップグレードしてください。

私たちのリバースエンジニアリングされた、フリーでオープンソースのグラフィックスドライバは、M1ファミリーとM2ファミリーのグラフィックスハードウェアのための、世界で唯一のコンフォーマントなOpenGL ES 3.1実装です。つまり、私たちのドライバは、正しさを実証するために何万回ものテストに合格し、今や業界で認められているのです。

コンフォーマントになるためには、「実装 」は仕様のすべての機能を検証するために設計された公式のコンフォーマンステストスイートに合格しなければなりません。テスト結果は、標準化団体であるKhronosに提出される。30日間のレビュー期間の後、問題が見つからなければ、その実装はコンフォーマントになる。Khronosのウェブサイトには、M1、M1 Pro/Max/Ultra、M2、M2 Pro/Max用ドライバーを含む、すべての適合実装が掲載されています。

今日のマイルストーンはOpenGL ESに関するものだけではありません。我々は、M1用のあらゆるグラフィックス標準の最初のコンフォーマント実装をリリースします。そして、私たちはここで止まるつもりはありません。）

![image1](https://asahilinux.org/img/blog/2023/08/vkinstancing2.webp)

私たちのものとは異なり、メーカーのM1ドライバは残念ながら、VulkanであれOpenGLであれOpenGL ESであれ、どの標準グラフィックスAPIにも準拠していません。つまり、（Linuxを実行していない場合）標準を使用するアプリケーションがM1/M2で動作する保証はないということだ。これは単なる理論上の問題ではない。Vulkanを考えてみよう。サードパーティのMoltenVKは、プロプライエタリ・ドライバの上にVulkanのサブセットを重ねている。しかし、これらのドライバには重要な機能が欠けており、有効なVulkanアプリケーションを壊してしまう。M1/M2コンピューターをまだLinuxに切り替えていない場合、それは開発者にもユーザーにも障害となる。

メーカーがそうしなかったのに、なぜ私たちは標準準拠を追求したのでしょうか？何よりも品質へのこだわりです。私たちは、ユーザーに私たちのLinuxドライバが信頼できることを知ってもらいたいのです。私たちは、M1特有のハックや移植なしに、標準的なソフトウェアが動作することを望んでいます。移植性」のために妥協することなく、仕様に準拠したオープン・スタンダードを実装することこそ、進むべき道なのです。私たちは、プロプライエタリー・ドライバーやプロプライエタリー・API、標準の実装を拒否することに満足していません。他の業界は、進歩はベンダー間の協力から生まれることを知っている。我々もそれを知っている。コンフォーマンスを達成することは、我々のコミュニティにとっても、オープンソースにとっても、オープングラフィックスにとっても勝利なのです。

もちろん、朝日リナと私は、最小限の資金しか持たない2人の個人です。大企業に勝つなんて、ちょっと気が引ける......。

でも、まだ遅くはない。でも、まだ間に合う！

---
OpenGL ES 3.1は、6月に出荷した実験的なOpenGL ES 3.0とOpenGL 3.1を更新したものです。特筆すべきは、ES 3.1にコンピュート・シェーダーが追加されたことです。これは通常、グラフィックス・アプリケーション内の一般的な計算を高速化するために使用されます。例えば、3Dゲームは物理シミュレーションをコンピュートシェーダで実行できます。シミュレーション結果はレンダリングに使用され、CPUの物理シミュレーションとGPUを同期させるために必要なストールをなくすことができる。これにより、ゲームの実行速度が向上します。

新機能の1つである画像上のアトミックに注目してみよう。旧バージョンのOpenGL ESでは、アプリケーションが画像を読み込んで画面に表示することができました。ES 3.1では、アプリケーションは画像に書き込むことができ、通常はコンピュートシェーダから書き込むことができます。この新機能により、従来は固定関数の3Dパイプラインに収める必要があった柔軟な画像処理アルゴリズムが可能になります。しかし、GPUは超並列であり、何千ものスレッドを同時に実行します。2つのスレッドが同じ場所に書き込むと、競合が発生します。どちらのスレッドが先に実行されるかによって、結果は異なります。競合状態が発生するのだ。

メモリへの「アトミック」アクセスは、競合状態に対する解決策を提供する。アトミックでは、メモリサブシステムの特別なハードウェアが、スレッドの順序に関係なく、セレクト操作の一貫した明確な結果を保証します。最近のグラフィックス・ハードウェアは、加算のようなさまざまなアトミック演算をサポートしており、複雑な並列アルゴリズムのビルディング・ブロックとして機能している。

この2つの機能を組み合わせれば、アトミックに画像に書き込めるのでしょうか？

可能です。ユビキタスなOpenGL ES拡張（ES 3.2で必須）は、画像内のピクセルで動作するアトミックを追加します。例えば、コンピュートシェーダはピクセル(10, 20)の値をアトミックにインクリメントできます。

他のGPUは画像上でアトミックを実行する専用命令を持っており、ドライバの実装は簡単です。私たちにとっては、話はもっと複雑です。M1には、非画像アトミックと非アトミック画像があるにもかかわらず、画像アトミック用のハードウェア命令がありません。問題を再構成する必要がある。

ピクセルのアトミックを実行するには、代わりにメモリ上のピクセルのアドレスを計算し、そのアドレスに対して通常のアトミックを実行する。ハードウェアは通常のアトミックをサポートしているので、私たちのタスクはピクセルのアドレスを計算する「だけ」です。

Y座標に行ごとのバイト数（「ストライド」）を掛け、X座標にピクセルごとのバイト数を掛け、足す。これで、画像の最初のピクセルに対するピクセルのオフセットがバイト単位で得られます。最終的なアドレスを得るには、そのオフセットを最初のピクセルのアドレスに加える。

# 数式

残念なことに、画像がメモリ上で直線的であることはほとんどない。キャッシュ効率を向上させるため、最近のグラフィックス・ハードウェアはX座標とY座標をインターリーブしている。メモリ上のピクセルは、次から次へと並ぶのではなく、らせん状の曲線を描きます。

座標をインターリーブするには、先ほどの式を修正する必要がある。多くの命令を使って1ビットずつマスクし、シフトしてインターリーブ結果を構成することもできるが、それは非効率的だ。もっといい方法がある。

ビットをインターリーブする有名な 「ビットいじり 」アルゴリズムがある。このアルゴリズムは、一度に1ビットをシャッフルするのではなく、ビットのグループをシャッフルし、問題を並列化します。このアルゴリズムをシェーダコードに実装することで、性能が向上します。

実際には、各座標の下位7ビット（またはそれ以下）だけがインターリーブされます。そのため、X座標とY座標を32ビットレジスタの下位16ビットと上位16ビットに入れて、インターリーブを「ベクトル化」するために32ビット命令を使うことができます。この32ビット命令によって、XとYを同時にインターリーブすることができ、命令数が半分になります。さらに、GPUのシフトと加算を組み合わせた命令を利用することもできます。これらのトリックを組み合わせることで、M1 GPUアセンブリの10命令でインターリーブすることができます：

```
# Inputs x, y in r0l, r0h.
# Output in r1.

add r2, #0, r0, lsl 4
or  r1, r0, r2
and r1, r1, #0xf0f0f0f
add r2, #0, r1, lsl 2
or  r1, r1, r2
and r1, r1, #0x33333333
add r2, #0, r1, lsl 1
or  r1, r1, r2
and r1, r1, #0x55555555
add r1, r1l, r1h, lsl 1
```

ここでやめることもできるが、ビットをインターリーブする専用の命令があるとしたらどうだろう？PowerVRには「シャッフル」命令shflがあり、M1 GPUはPowerVRから拝借している。おそらくその命令も借用したのだろう。残念なことに、仮にあったとしても、私たちのテスト用シェーダーをコンパイルする際、独自コンパイラーはそれを使用しません。そのため、コンパイルされたシェーダーを観察してその命令をリバースエンジニアリングすることは（もし存在するとしても）難しい。

そこで、魔法の幼稚園で習った強力なリバースエンジニアリングのテクニックの出番だ。

ドーゴル・ジョンソンは、この推測を提供してくれた。私たちがすでに知っている命令を考えるとき、彼は「リバース・ビット」命令に特別な注意を払った。ビットの反転はビットシャッフルの一種であるから、インターリーブ命令も同様に符号化されるべきである。ビット反転命令には、演算を指定する2ビットのフィールドがあり、値は01である。セットビットの数を数える命令と、最初のセットビットを見つける命令は、それぞれ値10と11を持つ。これは、既知の「複雑なビット操作」命令をすべて網羅している。

2ビットの列挙のうち、観測されていない未知の値が1つある：00である。このインターリーブ命令が存在するとすれば、それはおそらくビット反転のようにエンコードされているが、オペレーションコードは01ではなく00である。

既知の3つの命令は入力ソースが1つだが、この命令は2つのソースをインターリーブしている。つ目のソースはどこに行くのだろうか？対称性から推測することができる。おそらくハードウェアデコーダを単純化するために、M1 GPU命令は通常、命令間で一貫した場所にソースをエンコードします。他の 3 つの命令には、2 つのソースを持つ演算命令で 2 番目のソースがあると予想される場所にギャップがあります。おそらく2番目のソースはそこにあるのでしょう。

推測をもとに、今度は私たちがチェックする番だ。GPUアセンブリを手書きするのではなく、コンパイラをハックして、（乗算のような）2つのソースの整数演算を、推測したエンコーディングの「インターリーブ」に置き換えることができます。それから、この演算（数値を「乗算」する）を使って計算シェーダを書き、ドライバの新し い計算サポートを使って実行します。

あとは、謎の命令が可能な入力ごとにインターリーブされた結果を返すことをチェックするシェーダを書くだけです。この命令は2つの16ビットソースを取るので、入力は約40億（$2^32$）あります。私たちのドライバを使えば、M1 GPUは1秒以内にそれらすべてをチェックすることができます。

座標をインターリーブするための賢いベクトル化アセンブリーについては？1つの命令で置き換えることができる。拍子抜けだが、高速でコンフォーマンス・テストに合格している。

それが重要なのだ。

---

オープン・ドライバをサポートしてくれたKhronosとSoftware in the Public Interestに感謝する。

#### Alyssa Rosenzweig · 2023-08-22



